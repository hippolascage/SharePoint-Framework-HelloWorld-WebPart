"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var gulp_core_build_1 = require('gulp-core-build');
/* tslint:disable:typedef */
var cached = require('gulp-cache');
/* tslint:enable:typedef */
var through2 = require('through2');
var gutil = require('gulp-util');
var tslint = require('tslint');
var lodash_1 = require('lodash');
var md5 = require('md5');
var path = require('path');
var TSLintTask = (function (_super) {
    __extends(TSLintTask, _super);
    function TSLintTask() {
        var _this = this;
        _super.apply(this, arguments);
        this.name = 'tslint';
        this.taskConfig = {
            // lintConfig: require('../lib/defaultTslint.json'),
            lintConfig: {},
            reporter: function (result, file, options) {
                for (var _i = 0, _a = result.failures; _i < _a.length; _i++) {
                    var failure = _a[_i];
                    var pathFromRoot = path.relative(_this.buildConfig.rootPath, file.path);
                    var start = failure.getStartPosition().getLineAndCharacter();
                    _this.fileError(pathFromRoot, start.line + 1, start.character + 1, failure.getRuleName(), failure.getFailure());
                }
            },
            rulesDirectory: (function () {
                var msCustomRulesMain = require.resolve('tslint-microsoft-contrib');
                var msCustomRulesDirectory = path.dirname(msCustomRulesMain);
                return tslint.getRulesDirectories([msCustomRulesDirectory], __dirname);
            })(),
            sourceMatch: [
                'src/**/*.ts',
                'src/**/*.tsx'
            ],
            useOldConfig: false
        };
        /* tslint:disable:no-any */
        this._lintRules = undefined;
    }
    /* tslint:enable:no-any */
    TSLintTask.prototype.executeTask = function (gulp) {
        var taskScope = this;
        return gulp.src(this.taskConfig.sourceMatch)
            .pipe(cached(through2.obj(function (file, encoding, callback) {
            taskScope.logVerbose(file.path);
            // Lint the file
            if (file.isNull()) {
                return callback(undefined, file);
            }
            // Stream is not supported
            if (file.isStream()) {
                this.emit('error', new gutil.PluginError(this.name, 'Streaming not supported'));
                return callback();
            }
            var options = {
                configuration: taskScope._loadLintRules(),
                formatter: 'json',
                formattersDirectory: undefined,
                rulesDirectory: taskScope.taskConfig.rulesDirectory || []
            };
            var tslintOutput = new tslint(file.relative, file.contents.toString('utf8'), options);
            /* tslint:disable:no-string-literal */
            var result = file['tslint'] = tslintOutput.lint();
            /* tslint:enable:no-string-literal */
            if (result.failureCount > 0) {
                taskScope.taskConfig.reporter(result, file, taskScope.taskConfig);
            }
            this.push(file);
            callback();
        }), {
            // Scope the cache to a combination of the lint rules and the build path
            name: md5(tslint.VERSION + JSON.stringify(taskScope._loadLintRules()) +
                taskScope.name + taskScope.buildConfig.rootPath),
            // What on the result indicates it was successful
            success: function (jshintedFile) {
                /* tslint:disable:no-string-literal */
                return jshintedFile['tslint'].failureCount === 0;
                /* tslint:enable:no-string-literal */
            },
            // By default, the cache attempts to store the value of the objects in the stream
            // For this task, this is over-engineering since we never need to store anything extra.
            value: function (file) {
                return {
                    path: file.path
                };
            }
        }));
    };
    /* tslint:disable:no-any */
    TSLintTask.prototype._loadLintRules = function () {
        if (!this._lintRules) {
            var defaultConfig = this.taskConfig.useOldConfig
                ? require('./defaultTslint_oldRules.json')
                : require('./defaultTslint.json');
            this._lintRules = lodash_1.merge(defaultConfig, this.taskConfig.lintConfig || {});
        }
        return this._lintRules;
    };
    return TSLintTask;
}(gulp_core_build_1.GulpTask));
exports.TSLintTask = TSLintTask;

//# sourceMappingURL=TSLintTask.js.map
