"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var GulpTask_1 = require('./GulpTask');
var NukeTask = (function (_super) {
    __extends(NukeTask, _super);
    function NukeTask() {
        _super.apply(this, arguments);
        this.name = 'nuke';
        this.taskConfig = {};
    }
    NukeTask.prototype.executeTask = function (gulp, completeCallback) {
        var del = require('del');
        var _a = this.buildConfig, distFolder = _a.distFolder, libFolder = _a.libFolder, libAMDFolder = _a.libAMDFolder, tempFolder = _a.tempFolder;
        var nukePaths = [
            distFolder,
            libAMDFolder,
            libFolder,
            tempFolder
        ];
        // Give each registered task an opportunity to add their own nuke paths.
        for (var _i = 0, _b = this.buildConfig.uniqueTasks; _i < _b.length; _i++) {
            var executable = _b[_i];
            if (executable.getNukeMatch) {
                nukePaths = nukePaths.concat(executable.getNukeMatch());
            }
        }
        var uniquePaths = {};
        // Create dictionary of unique paths. (Could be replaced with ES6 set.)
        nukePaths.forEach(function (path) {
            if (!!path) {
                uniquePaths[path] = path;
            }
        });
        // Reset nukePaths to only unique non-empty paths.
        nukePaths = [];
        for (var path in uniquePaths) {
            if (uniquePaths.hasOwnProperty(path)) {
                nukePaths.push(path);
            }
        }
        del(nukePaths)
            .then(function () { return completeCallback(); })
            .catch(function (error) { return completeCallback(error); });
    };
    return NukeTask;
}(GulpTask_1.GulpTask));
exports.NukeTask = NukeTask;

//# sourceMappingURL=NukeTask.js.map
