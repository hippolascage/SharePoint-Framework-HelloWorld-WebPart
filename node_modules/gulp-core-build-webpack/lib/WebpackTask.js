"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var gulp_core_build_1 = require('gulp-core-build');
var WebpackTask = (function (_super) {
    __extends(WebpackTask, _super);
    function WebpackTask() {
        _super.apply(this, arguments);
        this.name = 'webpack';
        this.taskConfig = {
            configPath: './webpack.config.js',
            suppressWarnings: []
        };
        this.resources = {
            webpack: require('webpack')
        };
    }
    WebpackTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        var shouldInitWebpack = (process.argv.indexOf('--initwebpack') > -1);
        var path = require('path');
        if (shouldInitWebpack) {
            this.log('Initializing a webpack.config.js, which bundles lib/index.js ' +
                'into dist/packagename.js into a UMD module.');
            this.copyFile(path.resolve(__dirname, '..', 'webpack.config.js'));
            completeCallback();
        }
        else {
            var webpackConfig = null;
            if (!this.taskConfig.configPath && !this.taskConfig.config) {
                this.logMissingConfigWarning();
                completeCallback();
                return;
            }
            else if (this.taskConfig.configPath) {
                if (this.fileExists(this.taskConfig.configPath)) {
                    try {
                        webpackConfig = require(this.resolvePath(this.taskConfig.configPath));
                    }
                    catch (err) {
                        completeCallback("Error parsing webpack config: " + this.taskConfig.configPath + ": " + err);
                        return;
                    }
                }
                else if (!this.taskConfig.config) {
                    var relativeConfigPath = path.relative(this.buildConfig.rootPath, this.taskConfig.config);
                    this.logWarning(("The webpack config location '" + relativeConfigPath + "' doesn't exist. ") +
                        "Run again using --initwebpack to create a default config, or call " +
                        "webpack.setConfig({ configPath: null }).");
                    completeCallback();
                    return;
                }
                else {
                    webpackConfig = this.taskConfig.config;
                }
            }
            else if (this.taskConfig.config) {
                webpackConfig = this.taskConfig.config;
            }
            else {
                this.logMissingConfigWarning();
                completeCallback();
                return;
            }
            var webpack = require('webpack');
            var gutil_1 = require('gulp-util');
            var startTime_1 = new Date().getTime();
            var outputDir_1 = this.buildConfig.distFolder;
            webpack(webpackConfig, function (error, stats) {
                if (!_this.buildConfig.properties) {
                    _this.buildConfig.properties = {};
                }
                /* tslint:disable:no-string-literal */
                _this.buildConfig.properties['webpackStats'] = stats;
                /* tslint:enable:no-string-literal */
                var statsResult = stats.toJson({
                    hash: false,
                    source: false
                });
                if (statsResult.errors && statsResult.errors.length) {
                    _this.logError(("'" + outputDir_1 + "':") + '\n' + statsResult.errors.join('\n') + '\n');
                }
                if (statsResult.warnings && statsResult.warnings.length) {
                    var unsuppressedWarnings_1 = [];
                    var warningSuppressonRegexes_1 = (_this.taskConfig.suppressWarnings || []).map(function (regex) {
                        return new RegExp(regex);
                    });
                    statsResult.warnings.forEach(function (warning) {
                        var suppressed = false;
                        for (var i = 0; i < warningSuppressonRegexes_1.length; i++) {
                            var suppressionRegex = warningSuppressonRegexes_1[i];
                            if (warning.match(suppressionRegex)) {
                                suppressed = true;
                                break;
                            }
                        }
                        if (!suppressed) {
                            unsuppressedWarnings_1.push(warning);
                        }
                    });
                    if (unsuppressedWarnings_1.length > 0) {
                        _this.logWarning(("'" + outputDir_1 + "':") + '\n' + unsuppressedWarnings_1.join('\n') + '\n');
                    }
                }
                var duration = (new Date().getTime() - startTime_1);
                var statsResultChildren = statsResult.children ? statsResult.children : [statsResult];
                statsResultChildren.forEach(function (child) {
                    child.chunks.forEach(function (chunk) {
                        chunk.files.forEach(function (file) { return (_this.log(("Bundled: '" + gutil_1.colors.cyan(path.basename(file)) + "', ") +
                            ("size: " + gutil_1.colors.magenta(chunk.size) + " bytes, ") +
                            ("took " + gutil_1.colors.magenta(duration) + " ms."))); }); // end file
                    }); // end chunk
                }); // end child
                completeCallback();
            }); // endwebpack callback
        }
    };
    WebpackTask.prototype.logMissingConfigWarning = function () {
        this.logWarning('No webpack config has been provided.' +
            'Run again using --initwebpack to create a default config,' +
            "or call webpack.setConfig({ configPath: null }).");
    };
    return WebpackTask;
}(gulp_core_build_1.GulpTask));
exports.WebpackTask = WebpackTask;

//# sourceMappingURL=WebpackTask.js.map
