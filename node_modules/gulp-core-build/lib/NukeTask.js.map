{"version":3,"sources":["NukeTask.ts"],"names":[],"mappings":";;;;;;AAAA,yBAAyB,YAAY,CAAC,CAAA;AAMtC;IAA8B,4BAAqB;IAAnD;QAA8B,8BAAqB;QAC1C,SAAI,GAAW,MAAM,CAAC;QAEtB,eAAU,GAAgB,EAChC,CAAC;IA+CJ,CAAC;IA7CQ,8BAAW,GAAlB,UACE,IAAe,EACf,gBAA2C;QAE3C,4BAA4B;QAC5B,IAAM,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;QAC3B,4BAA4B;QAE5B,IAAA,qBAA4E,EAApE,0BAAU,EAAE,wBAAS,EAAE,8BAAY,EAAE,0BAAU,CAAsB;QAC7E,IAAI,SAAS,GAAG;YACd,UAAU;YACV,YAAY;YACZ,SAAS;YACT,UAAU;SACX,CAAC;QAEF,wEAAwE;QACxE,GAAG,CAAC,CAAqB,UAA4B,EAA5B,KAAA,IAAI,CAAC,WAAW,CAAC,WAAW,EAA5B,cAA4B,EAA5B,IAA4B,CAAC;YAAjD,IAAM,UAAU,SAAA;YACnB,EAAE,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC;gBAC5B,6DAA6D;gBAC7D,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC1E,CAAC;SACF;QAED,IAAI,WAAW,GAA8B,EAAE,CAAC;QAEhD,uEAAuE;QACvE,SAAS,CAAC,OAAO,CAAC,UAAA,IAAI;YACpB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACX,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YAC3B,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,kDAAkD;QAClD,SAAS,GAAG,EAAE,CAAC;QACf,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,WAAW,CAAC,CAAC,CAAC;YAC7B,EAAE,CAAC,CAAC,WAAW,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvB,CAAC;QACH,CAAC;QAED,GAAG,CAAC,SAAS,CAAC;aACX,IAAI,CAAC,cAAM,OAAA,gBAAgB,EAAE,EAAlB,CAAkB,CAAC;aAC9B,KAAK,CAAC,UAAC,KAAK,IAAK,OAAA,gBAAgB,CAAC,KAAK,CAAC,EAAvB,CAAuB,CAAC,CAAC;IAC/C,CAAC;IACH,eAAC;AAAD,CAnDA,AAmDC,CAnD6B,mBAAQ,GAmDrC;AAnDY,gBAAQ,WAmDpB,CAAA","file":"NukeTask.js","sourcesContent":["import { GulpTask } from './GulpTask';\nimport gulp = require('gulp');\n\nexport interface INukeConfig {\n}\n\nexport class NukeTask extends GulpTask<INukeConfig> {\n  public name: string = 'nuke';\n\n  public taskConfig: INukeConfig = {\n  };\n\n  public executeTask(\n    gulp: gulp.Gulp,\n    completeCallback: (result?: Object) => void\n  ): void {\n    /* tslint:disable:typedef */\n    const del = require('del');\n    /* tslint:disable:typedef */\n\n    const { distFolder, libFolder, libAMDFolder, tempFolder } = this.buildConfig;\n    let nukePaths = [\n      distFolder,\n      libAMDFolder,\n      libFolder,\n      tempFolder\n    ];\n\n    // Give each registered task an opportunity to add their own nuke paths.\n    for (const executable of this.buildConfig.uniqueTasks) {\n      if (executable.getNukeMatch) {\n        // Set the build config, as tasks need this to build up paths\n        nukePaths = nukePaths.concat(executable.getNukeMatch(this.buildConfig));\n      }\n    }\n\n    let uniquePaths: { [key: string]: string } = {};\n\n    // Create dictionary of unique paths. (Could be replaced with ES6 set.)\n    nukePaths.forEach(path => {\n      if (!!path) {\n        uniquePaths[path] = path;\n      }\n    });\n\n    // Reset nukePaths to only unique non-empty paths.\n    nukePaths = [];\n    for (let path in uniquePaths) {\n      if (uniquePaths.hasOwnProperty(path)) {\n        nukePaths.push(path);\n      }\n    }\n\n    del(nukePaths)\n      .then(() => completeCallback())\n      .catch((error) => completeCallback(error));\n  }\n}\n"],"sourceRoot":"/source/"}