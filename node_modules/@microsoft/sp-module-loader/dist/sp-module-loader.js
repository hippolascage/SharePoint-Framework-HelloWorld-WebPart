var spModuleLoader =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonpspModuleLoader"];
/******/ 	window["webpackJsonpspModuleLoader"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		0:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + "." + ({"1":"developer-tools"}[chunkId]||chunkId) + "_" + {"1":"75a402b4b6c4fa9cbd6a"}[chunkId] + ".js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable:no-any */
	var result = window.spModuleLoader;
	/* tslint:enable:no-any */
	if (!result) {
	    __webpack_require__(1);
	    result = __webpack_require__(9).default.instance;
	}
	module.exports = result;
	/* tslint:enable:export-name */
	


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright Microsoft Corporation. All rights reserved.
	 *
	 * @file This file contains an inventory of all of our framework's polyfills.
	 * All webpart and application code can rely on these libraries being polyfilled by our framework.
	 */
	"use strict";
	/**
	 * ES6 Harmony Collections Polyfill
	 * ES6 Harmony Collections  was added as a polyfill to provide a lightweight unobtrusive shim for
	 * ES2015 collections. The implementations of Map, Set, and WeakMap provided by this polyfill
	 * adhere to the ES2015 standard. Functions that abide by the ES2015 standard such as Map.get()
	 * and Set.has() are guaranteed to run in sublinear time rather than the expected constant time
	 * for a standard hashmap implementation. (See http://stackoverflow.com/a/31092145) The alternative
	 * popular library to ES6 Harmony Collections is ES6 shim. After running some samples tests, we have
	 * determined that ES6 Harmony Collections performs better on a larger set of operations than
	 * the es6-shim. (Tests were run here: https://jsperf.com/es6-shim-vs-es6-collections/2 ).
	 * ES6 shim is also a much larger library in size, so the decision stick with ES6 collections
	 * was easy to make.
	 * https://github.com/WebReflection/es6-collections
	 */
	__webpack_require__(2);
	/**
	 * ES6 Promise Polyfill
	 * Adds an implementation of the ES2015-Promise to the browser. The implementation is a subset
	 * of rsvp.js.
	 * (See: https://github.com/tildeio/rsvp.js) ES6 Promise is compliant with Promises/A+
	 * (See: https://promisesaplus.com/)
	 * Very useful for using Promise in the Safari/IE/Edge (already supported by Chrome/Firefox)
	 * https://github.com/jakearchibald/es6-promise
	 */
	__webpack_require__(3);
	/**
	 * Window.Fetch PolyFill
	 * Adds an implementation of the Fetch standard to the browser.
	 * Very useful for using the fetch api in the Safari/IE (already supported by Chrome/Firefox/Edge)
	 * https://github.com/github/fetch
	 */
	__webpack_require__(8);
	/**
	 * We don't load whatwg-fetch polyfill for Firefox because it has a native implementation, but
	 * (unlike Chrome) it is missing the forEach() method.  Ideally we should be using for..of
	 * instead of forEach(), however TypeScript won't support that syntax until version 2.0.
	 * As a temporary workaround, we will polyfill the missing forEach() method for Firefox.
	 * Discussion: https://github.com/github/fetch/issues/149
	 */
	if (typeof Headers.prototype.forEach === 'undefined') {
	    Headers.prototype.forEach = function (callback) {
	        var iterator = this.entries();
	        for (;;) {
	            var entry = iterator.next();
	            if (entry.done) {
	                break;
	            }
	            // NOTE: The array returns [name,value] but the callback takes (value, name).
	            callback(entry.value[1], entry.value[0]);
	        }
	    };
	}
	/**
	 * This is a polyfill for window.location.origin, which is not supported by the IE browser
	 */
	if (!window.location.origin) {
	    window.location.origin = window.location.protocol
	        + '//'
	        + window.location.hostname
	        + (window.location.port ? ':' + window.location.port : '');
	}
	


/***/ },
/* 2 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {(function (exports) {'use strict';
	  //shared pointer
	  var i;
	  //shortcuts
	  var defineProperty = Object.defineProperty, is = function(a,b) { return (a === b) || (a !== a && b !== b) };
	
	
	  //Polyfill global objects
	  if (typeof WeakMap == 'undefined') {
	    exports.WeakMap = createCollection({
	      // WeakMap#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // WeakMap#clear():
	      clear: sharedClear,
	      // WeakMap#get(key:void*):void*
	      get: sharedGet,
	      // WeakMap#has(key:void*):boolean
	      has: mapHas,
	      // WeakMap#set(key:void*, value:void*):void
	      set: sharedSet
	    }, true);
	  }
	
	  if (typeof Map == 'undefined' || typeof ((new Map).values) !== 'function' || !(new Map).values().next) {
	    exports.Map = createCollection({
	      // WeakMap#delete(key:void*):boolean
	      'delete': sharedDelete,
	      //:was Map#get(key:void*[, d3fault:void*]):void*
	      // Map#has(key:void*):boolean
	      has: mapHas,
	      // Map#get(key:void*):boolean
	      get: sharedGet,
	      // Map#set(key:void*, value:void*):void
	      set: sharedSet,
	      // Map#keys(void):Iterator
	      keys: sharedKeys,
	      // Map#values(void):Iterator
	      values: sharedValues,
	      // Map#entries(void):Iterator
	      entries: mapEntries,
	      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
	      forEach: sharedForEach,
	      // Map#clear():
	      clear: sharedClear
	    });
	  }
	
	  if (typeof Set == 'undefined' || typeof ((new Set).values) !== 'function' || !(new Set).values().next) {
	    exports.Set = createCollection({
	      // Set#has(value:void*):boolean
	      has: setHas,
	      // Set#add(value:void*):boolean
	      add: sharedAdd,
	      // Set#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // Set#clear():
	      clear: sharedClear,
	      // Set#keys(void):Iterator
	      keys: sharedValues, // specs actually say "the same function object as the initial value of the values property"
	      // Set#values(void):Iterator
	      values: sharedValues,
	      // Set#entries(void):Iterator
	      entries: setEntries,
	      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
	      forEach: sharedForEach
	    });
	  }
	
	  if (typeof WeakSet == 'undefined') {
	    exports.WeakSet = createCollection({
	      // WeakSet#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // WeakSet#add(value:void*):boolean
	      add: sharedAdd,
	      // WeakSet#clear():
	      clear: sharedClear,
	      // WeakSet#has(value:void*):boolean
	      has: setHas
	    }, true);
	  }
	
	
	  /**
	   * ES6 collection constructor
	   * @return {Function} a collection class
	   */
	  function createCollection(proto, objectOnly){
	    function Collection(a){
	      if (!this || this.constructor !== Collection) return new Collection(a);
	      this._keys = [];
	      this._values = [];
	      this._itp = []; // iteration pointers
	      this.objectOnly = objectOnly;
	
	      //parse initial iterable argument passed
	      if (a) init.call(this, a);
	    }
	
	    //define size for non object-only collections
	    if (!objectOnly) {
	      defineProperty(proto, 'size', {
	        get: sharedSize
	      });
	    }
	
	    //set prototype
	    proto.constructor = Collection;
	    Collection.prototype = proto;
	
	    return Collection;
	  }
	
	
	  /** parse initial iterable argument passed */
	  function init(a){
	    var i;
	    //init Set argument, like `[1,2,3,{}]`
	    if (this.add)
	      a.forEach(this.add, this);
	    //init Map argument like `[[1,2], [{}, 4]]`
	    else
	      a.forEach(function(a){this.set(a[0],a[1])}, this);
	  }
	
	
	  /** delete */
	  function sharedDelete(key) {
	    if (this.has(key)) {
	      this._keys.splice(i, 1);
	      this._values.splice(i, 1);
	      // update iteration pointers
	      this._itp.forEach(function(p) { if (i < p[0]) p[0]--; });
	    }
	    // Aurora here does it while Canary doesn't
	    return -1 < i;
	  };
	
	  function sharedGet(key) {
	    return this.has(key) ? this._values[i] : undefined;
	  }
	
	  function has(list, key) {
	    if (this.objectOnly && key !== Object(key))
	      throw new TypeError("Invalid value used as weak collection key");
	    //NaN or 0 passed
	    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);){}
	    else i = list.indexOf(key);
	    return -1 < i;
	  }
	
	  function setHas(value) {
	    return has.call(this, this._values, value);
	  }
	
	  function mapHas(value) {
	    return has.call(this, this._keys, value);
	  }
	
	  /** @chainable */
	  function sharedSet(key, value) {
	    this.has(key) ?
	      this._values[i] = value
	      :
	      this._values[this._keys.push(key) - 1] = value
	    ;
	    return this;
	  }
	
	  /** @chainable */
	  function sharedAdd(value) {
	    if (!this.has(value)) this._values.push(value);
	    return this;
	  }
	
	  function sharedClear() {
	    (this._keys || 0).length =
	    this._values.length = 0;
	  }
	
	  /** keys, values, and iterate related methods */
	  function sharedKeys() {
	    return sharedIterator(this._itp, this._keys);
	  }
	
	  function sharedValues() {
	    return sharedIterator(this._itp, this._values);
	  }
	
	  function mapEntries() {
	    return sharedIterator(this._itp, this._keys, this._values);
	  }
	
	  function setEntries() {
	    return sharedIterator(this._itp, this._values, this._values);
	  }
	
	  function sharedIterator(itp, array, array2) {
	    var p = [0], done = false;
	    itp.push(p);
	    return {
	      next: function() {
	        var v, k = p[0];
	        if (!done && k < array.length) {
	          v = array2 ? [array[k], array2[k]]: array[k];
	          p[0]++;
	        } else {
	          done = true;
	          itp.splice(itp.indexOf(p), 1);
	        }
	        return { done: done, value: v };
	      }
	    };
	  }
	
	  function sharedSize() {
	    return this._values.length;
	  }
	
	  function sharedForEach(callback, context) {
	    var it = this.entries();
	    for (;;) {
	      var r = it.next();
	      if (r.done) break;
	      callback.call(context, r.value[1], r.value[0], this);
	    }
	  }
	
	})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window );
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.1.2
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(6);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	      var state = parent._state;
	
	      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
	        return this;
	      }
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	      var result = parent._result;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
	        return promise;
	      }
	
	      var length = entries.length;
	
	      function onFulfillment(value) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      }
	
	      function onRejection(reason) {
	        lib$es6$promise$$internal$$reject(promise, reason);
	      }
	
	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
	      }
	
	      return promise;
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	    var lib$es6$promise$promise$$counter = 0;
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this._id = lib$es6$promise$promise$$counter++;
	      this._state = undefined;
	      this._result = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (Array.isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, this._validationError());
	      }
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
	      return new Error('Array Methods must be provided an Array');
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(7)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), (function() { return this; }()), __webpack_require__(5)(module)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 8 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  var support = {
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob();
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers;
	  self.Request = Request;
	  self.Response = Response;
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return;
	      }
	
	      xhr.onload = function() {
	        var status = (xhr.status === 1223) ? 204 : xhr.status
	        if (status < 100 || status > 599) {
	          reject(new TypeError('Network request failed'))
	          return
	        }
	        var options = {
	          status: status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText;
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @Copyright (c) Microsoft Corporation.  All rights reserved.
	 *
	 * @file SPModuleLoader.ts
	 */
	"use strict";
	__webpack_require__(10);
	var Combokeys = __webpack_require__(11);
	var sp_module_interfaces_1 = __webpack_require__(44);
	var SystemJsWrapper_1 = __webpack_require__(46);
	var ManifestStore_1 = __webpack_require__(49);
	var DebugManifestProvider_1 = __webpack_require__(50);
	var _allowDebug = undefined;
	function ensureDebugAllowed(ask) {
	    if (ask === void 0) { ask = true; }
	    if (!ask || _allowDebug !== undefined) {
	        return !!_allowDebug;
	    }
	    else {
	        // Inform the user that they might be loading debug manifests
	        _allowDebug = confirm('WARNING: This page is requesting to load unsafe scripts, which could potentially harm ' +
	            'your computer! Do not proceed unless you trust the developer and understand the risks.\n\n' +
	            'If you are unsure, click "Cancel."');
	        return _allowDebug;
	    }
	}
	exports.ensureDebugAllowed = ensureDebugAllowed;
	/**
	 * The global module loader for SP client-side applications and webparts.
	 *
	 * This is an API that lives in a global variable on the window, similar to how systemJS works.
	 *
	 * @public
	 */
	var SPModuleLoader = (function () {
	    function SPModuleLoader() {
	        var _this = this;
	        /**
	         * @public
	         *
	         * Combokeys reference. Placed here so any other component can use it without having to bundle it again.
	         */
	        this.combokeys = Combokeys;
	        // Watching for hotkeys on the whole document.
	        var fullWindowCombokeys = new Combokeys(document.documentElement);
	        // Bind the debugger to "ctrl+shift+`"
	        fullWindowCombokeys.bind('ctrl+shift+`', function () { return _this._toggleDeveloperTools(); });
	        // Easter egg - Konami code. Obfuscate, so it's not obvious from looking at the minimized source.
	        var keyMap = __webpack_require__(24);
	        fullWindowCombokeys.bind([keyMap[38], keyMap[38], keyMap[40], keyMap[40], keyMap[37],
	            keyMap[39], keyMap[37], keyMap[39], 'b', 'a', keyMap[13]].join(' '), function () {
	            var audio = new Audio(__webpack_require__(51));
	            audio.volume = 0.25;
	            audio.play();
	        });
	        if (!SPModuleLoader._headElement) {
	            SPModuleLoader._headElement = document.getElementsByTagName('head')[0];
	        }
	    }
	    Object.defineProperty(SPModuleLoader, "instance", {
	        get: function () {
	            if (!this._instance) {
	                this._instance = new SPModuleLoader();
	            }
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SPModuleLoader.prototype.initialize = function (preloadedData) {
	        var _this = this;
	        return new Promise(function (resolve) {
	            ManifestStore_1.default.instance.populateManifests(preloadedData);
	            _this._loadDebugManifests().then(function () {
	                if (preloadedData && preloadedData.spPageContextInfo) {
	                    SystemJsWrapper_1.default.instance.currentLocale = preloadedData.spPageContextInfo.currentUICultureName;
	                }
	                resolve();
	            });
	        });
	    };
	    /**
	     * Get the component manifest by id.
	     *
	     * @param id - GUID id of the component.
	     */
	    /* tslint:disable:no-any */
	    SPModuleLoader.prototype.getManifestById = function (id) {
	        /* tslint:enable:no-any */
	        return ManifestStore_1.default.instance.getManifestById(id);
	    };
	    /**
	     * This is called by the page scripts to start loading the framework. Do not call it from your own code.
	     */
	    SPModuleLoader.prototype.start = function (preloadedData) {
	        var _this = this;
	        this.initialize(preloadedData).then(function () {
	            if (preloadedData) {
	                var applicationManifestId = preloadedData.clientSideApplicationId
	                    ? preloadedData.clientSideApplicationId
	                    : (preloadedData.clientSideApplicationManifest
	                        ? preloadedData.clientSideApplicationManifest.id
	                        : undefined);
	                var manifest_1 = ManifestStore_1.default.instance.getManifestById(applicationManifestId);
	                if (manifest_1) {
	                    var platformModule = sp_module_interfaces_1.standardLibraryModules['@microsoft/sp-client-preview'];
	                    var loadingComplete_1 = false;
	                    Promise.all([
	                        _this.loadStandardLibraryModule(platformModule),
	                        SystemJsWrapper_1.default.instance.loadManifestModules(manifest_1.id, manifest_1.loaderConfig)
	                    ])
	                        .then(function (modules) {
	                        /* tslint:enable:no-any */
	                        loadingComplete_1 = true;
	                        /* tslint:disable:no-any */
	                        var platform = modules[0];
	                        /* tslint:enable:no-any */
	                        var application = modules[1];
	                        if (!platform || !application) {
	                            throw new Error(("@microsoft/sp-client-preview or " + manifest_1.loaderConfig.entryModuleId + " failed ") +
	                                'to load.');
	                        }
	                        else {
	                            try {
	                                platform._spShell.start(application, preloadedData);
	                            }
	                            catch (e) {
	                                console.error("Error loading application. Error: " + e);
	                                throw e;
	                            }
	                        }
	                        // @todo VSO #210443: preload WebPart manifests
	                    }).catch(function (e) {
	                        if (!loadingComplete_1) {
	                            console.error(manifest_1.loaderConfig.entryModuleId + " failed to load. Error: " + e);
	                        }
	                        throw e;
	                    });
	                }
	                else {
	                    throw new Error('Invalid manifest.');
	                }
	            }
	            else {
	                throw new Error('Invalid preloaded data.');
	            }
	        });
	    };
	    /**
	     * Given a URL, load a script.
	     *
	     * @param {scriptSource} The script URL.
	     * @param {globalExportsName} (optional) If the script isn't an AMD mdoule and loads a global member on the page,
	     *                  specify the global member's name.
	     * @returns A promse containing the loaded module.
	     */
	    /* tslint:disable:no-any */
	    SPModuleLoader.prototype.loadScript = function (scriptSource, globalExportsName) {
	        /* tslint:enable:no-any */
	        return SystemJsWrapper_1.default.instance.loadScript(scriptSource, globalExportsName);
	    };
	    /**
	     * Load a standard library manifest.
	     *
	     * @param {standardLibraryModule} The standard library module object.
	     * @returns A promse containing the loaded module.
	     */
	    /* tslint:disable:no-any */
	    SPModuleLoader.prototype.loadStandardLibraryModule = function (standardLibraryModule, moduleName) {
	        /* tslint:enable:no-any */
	        if (true) {
	            // Special case for NPM modules to resolve React, React-DOM, and Flux
	            /* tslint:disable:no-any */
	            var resultPromise = this._npmLoadPackage(moduleName);
	            /* tslint:enable:no-any */
	            if (resultPromise) {
	                return resultPromise;
	            }
	        }
	        var references = [standardLibraryModule.bundleReference].concat(standardLibraryModule.aliases || []);
	        return this._internalLoadManifestModules(references);
	    };
	    /**
	     * Load a manifest, or resolve a manifest ID and load it.
	     *
	     * @param {idOrManifest} The ID of a manifest, the manifest payload, or an array of IDs. In the case of an array
	     *                        of IDs, all of the IDs are considered equally valid, so pick the first one that's resolvable
	     *                        to a manifest.
	     * @returns A promse containing the loaded module.
	     */
	    /* tslint:disable:no-any */
	    SPModuleLoader.prototype.loadManifestModules = function (idOrManifest) {
	        /* tslint:enable:no-any */
	        if (typeof idOrManifest === 'string') {
	            return this._internalLoadManifestModules([{
	                    id: idOrManifest
	                }]);
	        }
	        else {
	            var manifest = idOrManifest;
	            return this._internalLoadManifestModules(manifest);
	        }
	    };
	    /**
	     * Loads additional manifests into the manifest store, updating existing manifests.
	     *
	     * @param {manifests} The manifests to load into the store.
	     */
	    SPModuleLoader.prototype.importManifests = function (manifests, overwriteExisting) {
	        if (overwriteExisting === void 0) { overwriteExisting = false; }
	        ManifestStore_1.default.instance.importManifests(manifests, overwriteExisting);
	    };
	    /**
	     * If debug manfiests haven't already been loaded, force them to load without prompting the user.
	     *
	     * @returns A promise that is fulfilled when the manifests are loaded.
	     */
	    SPModuleLoader.prototype.forceLoadDebugManifests = function () {
	        return this._loadDebugManifests(true, true, 'http://localhost:4321/temp/manifests.js');
	    };
	    /**
	     * Get all registered manifests.
	     *
	     * @returns All registered manifests.
	     */
	    SPModuleLoader.prototype.getManifests = function () {
	        return ManifestStore_1.default.instance.getAllManifests();
	    };
	    /**
	     * Inserts a <link ... /> tag for a stylesheet.
	     *
	     * @param {url} - The CSS file URL.
	     */
	    SPModuleLoader.prototype.loadCss = function (url) {
	        var linkTag = document.createElement('link');
	        linkTag.rel = 'stylesheet';
	        linkTag.type = 'text/css';
	        linkTag.href = url;
	        SPModuleLoader._headElement.appendChild(linkTag);
	    };
	    SPModuleLoader.prototype._loadDebugManifests = function (noPrompt, noCache, alternativeManifestsFile) {
	        if (noPrompt === void 0) { noPrompt = false; }
	        if (noCache === void 0) { noCache = false; }
	        if (noPrompt) {
	            _allowDebug = true;
	        }
	        return DebugManifestProvider_1.default.instance.getDebugManifests(noCache, alternativeManifestsFile).then(function (debugManifests) {
	            ManifestStore_1.default.instance.populateDebugManifests(debugManifests);
	            ensureDebugAllowed(debugManifests && Object.keys(debugManifests).length > 0);
	        });
	    };
	    SPModuleLoader.prototype._internalLoadManifestModules = function (referenceOrManifest) {
	        /* tslint:enable:no-any */
	        var references = referenceOrManifest;
	        var manifest;
	        var entryName;
	        if (references.length) {
	            // We have an array of manifests, so find the first one that matches
	            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
	                var reference = references_1[_i];
	                manifest = ManifestStore_1.default.instance.getManifestById(reference.id);
	                if (manifest) {
	                    entryName = reference.entryName;
	                    break;
	                }
	            }
	        }
	        else {
	            manifest = referenceOrManifest;
	        }
	        if (manifest) {
	            return SystemJsWrapper_1.default.instance.loadManifestModules(manifest.id, manifest.loaderConfig, entryName);
	        }
	        else {
	            throw new Error("Manifest \"" + JSON.stringify(referenceOrManifest) + "\" not found.");
	        }
	    };
	    SPModuleLoader.prototype._toggleDeveloperTools = function () {
	        var _this = this;
	        if (this._developerTools) {
	            this._developerTools.toggleDeveloperTools();
	        }
	        else {
	            var loadDeveloperTools_1 = function () {
	                __webpack_require__.e/* nsure */(1, function (require) {
	                    var developerToolsClass = __webpack_require__(60).default;
	                    _this._developerTools = developerToolsClass.instance;
	                    _this._developerTools.initialize();
	                    _this._developerTools.showHideDeveloperTools(true);
	                });
	            };
	            // If we're building an NPM module, we need to make sure React, Flux, and React-DOM aren't bundled. Instead,
	            // we'll load them from node_modules.
	            if (true) {
	                // Ensure the fake react, flux, and react-dom modules are included in this chunk
	                __webpack_require__(52);
	                __webpack_require__(53);
	                __webpack_require__(54);
	                /* tslint:disable:no-any */
	                var reactPromise = this._npmLoadPackage('react');
	                var fluxPromise = this._npmLoadPackage('flux');
	                var reactDomPromise = this._npmLoadPackage('react-dom');
	                /* tslint:enable:no-any */
	                Promise.all([reactPromise, reactDomPromise, fluxPromise])
	                    .then(function (results) {
	                    /* tslint:disable:no-any */
	                    var react = results[0];
	                    var reactDom = results[1];
	                    var flux = results[2];
	                    /* tslint:enable:no-any */
	                    // Inject react, react-dom, and flux into the module cache
	                    __webpack_require__.c[/*require.resolve*/(52)].exports = react;
	                    __webpack_require__.c[/*require.resolve*/(54)].exports = reactDom;
	                    __webpack_require__.c[/*require.resolve*/(53)].exports = flux;
	                    loadDeveloperTools_1();
	                });
	            }
	            else {
	                loadDeveloperTools_1();
	            }
	        }
	    };
	    /**
	     * This function contains some magic to load special packages (React, React-DOM, and Flux) while we're serving
	     *  from a local workbench without bunding any of them.
	     */
	    /* tslint:disable:no-any */
	    SPModuleLoader.prototype._npmLoadPackage = function (packageName) {
	        /* tslint:enable:no-any */
	        if (true) {
	            var url = __webpack_require__(55);
	            var relativeReactUrl = '../../../react/dist/react.js';
	            var relativeFluxUrl = '../../../flux/dist/Flux.js';
	            if (relativeReactUrl === '__RELATIVE_' + 'REACT_PATH__' ||
	                relativeFluxUrl === '__RELATIVE_' + 'FLUX_PATH__') {
	                // If the package hasn't been installed (i.e. - it's NPMX linked), don't try to load from incorrect paths
	                return undefined;
	            }
	            var reactUrl = url.resolve(__webpack_require__.p, relativeReactUrl);
	            var fluxUrl = url.resolve(__webpack_require__.p, relativeFluxUrl);
	            // Stick these on the SPModuleLoader object
	            /* tslint:disable:no-any */
	            var staticContainer = SPModuleLoader;
	            /* tslint:enable:no-any */
	            if (!staticContainer._reactPromise) {
	                staticContainer._reactPromise = this.loadScript(reactUrl);
	            }
	            if (!staticContainer._fluxPromise) {
	                staticContainer._fluxPromise = this.loadScript(fluxUrl);
	            }
	            switch (packageName) {
	                case 'react':
	                    return staticContainer._reactPromise;
	                case 'react-dom':
	                    /* tslint:disable:no-any */
	                    return staticContainer._reactPromise.then(function (react) { return react.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; });
	                /* tslint:enable:no-any */
	                case 'flux':
	                    return staticContainer._fluxPromise;
	                default:
	                    break;
	            }
	        }
	        return undefined;
	    };
	    return SPModuleLoader;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SPModuleLoader;
	


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var scripts = document.getElementsByTagName('script');
	var regex = new RegExp('sp-module-loader_?[a-zA-Z0-9]*.js', 'i');
	var found = false;
	
	if (scripts && scripts.length) {
	  for (var i = 0; i < scripts.length; i++) {
	    if (!scripts[i]) continue;
	    var path = scripts[i].getAttribute('src');
	    if (path && path.match(regex)) {
	      __webpack_require__.p = path.substring(0, path.lastIndexOf('/') + 1);
	      found = true;
	      break;
	    }
	  }
	}
	
	if (!found) {
	  for (var global in window.__setWebpackPublicPathLoaderSrcRegistry__) {
	    if (global && global.match(regex)) {
	      __webpack_require__.p = global.substring(0, global.lastIndexOf('/') + 1);
	      break;
	    }
	  }
	}

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	module.exports = function (element) {
	  var self = this
	  var Combokeys = self.constructor
	
	  /**
	   * a list of all the callbacks setup via Combokeys.bind()
	   *
	   * @type {Object}
	   */
	  self.callbacks = {}
	
	  /**
	   * direct map of string combinations to callbacks used for trigger()
	   *
	   * @type {Object}
	   */
	  self.directMap = {}
	
	  /**
	   * keeps track of what level each sequence is at since multiple
	   * sequences can start out with the same sequence
	   *
	   * @type {Object}
	   */
	  self.sequenceLevels = {}
	
	  /**
	   * variable to store the setTimeout call
	   *
	   * @type {null|number}
	   */
	  self.resetTimer
	
	  /**
	   * temporary state where we will ignore the next keyup
	   *
	   * @type {boolean|string}
	   */
	  self.ignoreNextKeyup = false
	
	  /**
	   * temporary state where we will ignore the next keypress
	   *
	   * @type {boolean}
	   */
	  self.ignoreNextKeypress = false
	
	  /**
	   * are we currently inside of a sequence?
	   * type of action ("keyup" or "keydown" or "keypress") or false
	   *
	   * @type {boolean|string}
	   */
	  self.nextExpectedAction = false
	
	  self.element = element
	
	  self.addEvents()
	
	  Combokeys.instances.push(self)
	  return self
	}
	
	module.exports.prototype.bind = __webpack_require__(12)
	module.exports.prototype.bindMultiple = __webpack_require__(13)
	module.exports.prototype.unbind = __webpack_require__(14)
	module.exports.prototype.trigger = __webpack_require__(15)
	module.exports.prototype.reset = __webpack_require__(16)
	module.exports.prototype.stopCallback = __webpack_require__(17)
	module.exports.prototype.handleKey = __webpack_require__(18)
	module.exports.prototype.addEvents = __webpack_require__(20)
	module.exports.prototype.bindSingle = __webpack_require__(27)
	module.exports.prototype.getKeyInfo = __webpack_require__(28)
	module.exports.prototype.pickBestAction = __webpack_require__(32)
	module.exports.prototype.getReverseMap = __webpack_require__(33)
	module.exports.prototype.getMatches = __webpack_require__(34)
	module.exports.prototype.resetSequences = __webpack_require__(36)
	module.exports.prototype.fireCallback = __webpack_require__(37)
	module.exports.prototype.bindSequence = __webpack_require__(40)
	module.exports.prototype.resetSequenceTimer = __webpack_require__(41)
	module.exports.prototype.detach = __webpack_require__(42)
	
	module.exports.instances = []
	module.exports.reset = __webpack_require__(43)
	
	/**
	 * variable to store the flipped version of MAP from above
	 * needed to check if we should use keypress or not when no action
	 * is specified
	 *
	 * @type {Object|undefined}
	 */
	module.exports.REVERSE_MAP = null


/***/ },
/* 12 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	/**
	 * binds an event to Combokeys
	 *
	 * can be a single key, a combination of keys separated with +,
	 * an array of keys, or a sequence of keys separated by spaces
	 *
	 * be sure to list the modifier keys first to make sure that the
	 * correct key ends up getting bound (the last key in the pattern)
	 *
	 * @param {string|Array} keys
	 * @param {Function} callback
	 * @param {string=} action - "keypress", "keydown", or "keyup"
	 * @returns void
	 */
	module.exports = function (keys, callback, action) {
	  var self = this
	
	  keys = keys instanceof Array ? keys : [keys]
	  self.bindMultiple(keys, callback, action)
	  return self
	}


/***/ },
/* 13 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * binds multiple combinations to the same callback
	 *
	 * @param {Array} combinations
	 * @param {Function} callback
	 * @param {string|undefined} action
	 * @returns void
	 */
	module.exports = function (combinations, callback, action) {
	  var self = this
	
	  for (var j = 0; j < combinations.length; ++j) {
	    self.bindSingle(combinations[j], callback, action)
	  }
	}


/***/ },
/* 14 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	/**
	 * unbinds an event to Combokeys
	 *
	 * the unbinding sets the callback function of the specified key combo
	 * to an empty function and deletes the corresponding key in the
	 * directMap dict.
	 *
	 * TODO: actually remove this from the callbacks dictionary instead
	 * of binding an empty function
	 *
	 * the keycombo+action has to be exactly the same as
	 * it was defined in the bind method
	 *
	 * @param {string|Array} keys
	 * @param {string} action
	 * @returns void
	 */
	module.exports = function (keys, action) {
	  var self = this
	
	  return self.bind(keys, function () {}, action)
	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	/**
	 * triggers an event that has already been bound
	 *
	 * @param {string} keys
	 * @param {string=} action
	 * @returns void
	 */
	module.exports = function (keys, action) {
	  var self = this
	  if (self.directMap[keys + ':' + action]) {
	    self.directMap[keys + ':' + action]({}, keys)
	  }
	  return this
	}


/***/ },
/* 16 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * resets the library back to its initial state. This is useful
	 * if you want to clear out the current keyboard shortcuts and bind
	 * new ones - for example if you switch to another page
	 *
	 * @returns void
	 */
	module.exports = function () {
	  var self = this
	  self.callbacks = {}
	  self.directMap = {}
	  return this
	}


/***/ },
/* 17 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	* should we stop this event before firing off callbacks
	*
	* @param {Event} e
	* @param {Element} element
	* @return {boolean}
	*/
	module.exports = function (e, element) {
	  // if the element has the class "combokeys" then no need to stop
	  if ((' ' + element.className + ' ').indexOf(' combokeys ') > -1) {
	    return false
	  }
	
	  var tagName = element.tagName.toLowerCase()
	
	  // stop for input, select, and textarea
	  return tagName === 'input' || tagName === 'select' || tagName === 'textarea' || element.isContentEditable
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * handles a character key event
	 *
	 * @param {string} character
	 * @param {Array} modifiers
	 * @param {Event} e
	 * @returns void
	 */
	module.exports = function (character, modifiers, e) {
	  var self = this
	  var callbacks
	  var j
	  var doNotReset = {}
	  var maxLevel = 0
	  var processedSequenceCallback = false
	  var isModifier
	  var ignoreThisKeypress
	
	  callbacks = self.getMatches(character, modifiers, e)
	  // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
	  for (j = 0; j < callbacks.length; ++j) {
	    if (callbacks[j].seq) {
	      maxLevel = Math.max(maxLevel, callbacks[j].level)
	    }
	  }
	
	  // loop through matching callbacks for this key event
	  for (j = 0; j < callbacks.length; ++j) {
	    // fire for all sequence callbacks
	    // this is because if for example you have multiple sequences
	    // bound such as "g i" and "g t" they both need to fire the
	    // callback for matching g cause otherwise you can only ever
	    // match the first one
	    if (callbacks[j].seq) {
	      // only fire callbacks for the maxLevel to prevent
	      // subsequences from also firing
	      //
	      // for example 'a option b' should not cause 'option b' to fire
	      // even though 'option b' is part of the other sequence
	      //
	      // any sequences that do not match here will be discarded
	      // below by the resetSequences call
	      if (callbacks[j].level !== maxLevel) {
	        continue
	      }
	
	      processedSequenceCallback = true
	
	      // keep a list of which sequences were matches for later
	      doNotReset[callbacks[j].seq] = 1
	      self.fireCallback(callbacks[j].callback, e, callbacks[j].combo, callbacks[j].seq)
	      continue
	    }
	
	    // if there were no sequence matches but we are still here
	    // that means this is a regular match so we should fire that
	    if (!processedSequenceCallback) {
	      self.fireCallback(callbacks[j].callback, e, callbacks[j].combo)
	    }
	  }
	
	  // if the key you pressed matches the type of sequence without
	  // being a modifier (ie "keyup" or "keypress") then we should
	  // reset all sequences that were not matched by this event
	  //
	  // this is so, for example, if you have the sequence "h a t" and you
	  // type "h e a r t" it does not match.  in this case the "e" will
	  // cause the sequence to reset
	  //
	  // modifier keys are ignored because you can have a sequence
	  // that contains modifiers such as "enter ctrl+space" and in most
	  // cases the modifier key will be pressed before the next key
	  //
	  // also if you have a sequence such as "ctrl+b a" then pressing the
	  // "b" key will trigger a "keypress" and a "keydown"
	  //
	  // the "keydown" is expected when there is a modifier, but the
	  // "keypress" ends up matching the nextExpectedAction since it occurs
	  // after and that causes the sequence to reset
	  //
	  // we ignore keypresses in a sequence that directly follow a keydown
	  // for the same character
	  ignoreThisKeypress = e.type === 'keypress' && self.ignoreNextKeypress
	  isModifier = __webpack_require__(19)
	  if (e.type === self.nextExpectedAction && !isModifier(character) && !ignoreThisKeypress) {
	    self.resetSequences(doNotReset)
	  }
	
	  self.ignoreNextKeypress = processedSequenceCallback && e.type === 'keydown'
	}


/***/ },
/* 19 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * determines if the keycode specified is a modifier key or not
	 *
	 * @param {string} key
	 * @returns {boolean}
	 */
	module.exports = function (key) {
	  return key === 'shift' || key === 'ctrl' || key === 'alt' || key === 'meta'
	}


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	module.exports = function () {
	  var self = this
	  var on = __webpack_require__(21)
	  var element = self.element
	
	  self.eventHandler = __webpack_require__(22).bind(self)
	
	  on(element, 'keypress', self.eventHandler)
	  on(element, 'keydown', self.eventHandler)
	  on(element, 'keyup', self.eventHandler)
	}


/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = on
	module.exports.on = on
	module.exports.off = off
	
	function on (element, event, callback, capture) {
	  !element.addEventListener && (event = 'on' + event)
	  ;(element.addEventListener || element.attachEvent).call(element, event, callback, capture)
	  return callback
	}
	
	function off (element, event, callback, capture) {
	  !element.removeEventListener && (event = 'on' + event)
	  ;(element.removeEventListener || element.detachEvent).call(element, event, callback, capture)
	  return callback
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * handles a keydown event
	 *
	 * @param {Event} e
	 * @returns void
	 */
	module.exports = function (e) {
	  var self = this
	  var characterFromEvent
	  var eventModifiers
	
	  // normalize e.which for key events
	  // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
	  if (typeof e.which !== 'number') {
	    e.which = e.keyCode
	  }
	  characterFromEvent = __webpack_require__(23)
	  var character = characterFromEvent(e)
	
	  // no character found then stop
	  if (!character) {
	    return
	  }
	
	  // need to use === for the character check because the character can be 0
	  if (e.type === 'keyup' && self.ignoreNextKeyup === character) {
	    self.ignoreNextKeyup = false
	    return
	  }
	
	  eventModifiers = __webpack_require__(26)
	  self.handleKey(character, eventModifiers(e), e)
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * takes the event and returns the key character
	 *
	 * @param {Event} e
	 * @return {string}
	 */
	module.exports = function (e) {
	  var SPECIAL_KEYS_MAP,
	    SPECIAL_CHARACTERS_MAP
	  SPECIAL_KEYS_MAP = __webpack_require__(24)
	  SPECIAL_CHARACTERS_MAP = __webpack_require__(25)
	
	  // for keypress events we should return the character as is
	  if (e.type === 'keypress') {
	    var character = String.fromCharCode(e.which)
	
	    // if the shift key is not pressed then it is safe to assume
	    // that we want the character to be lowercase.  this means if
	    // you accidentally have caps lock on then your key bindings
	    // will continue to work
	    //
	    // the only side effect that might not be desired is if you
	    // bind something like 'A' cause you want to trigger an
	    // event when capital A is pressed caps lock will no longer
	    // trigger the event.  shift+a will though.
	    if (!e.shiftKey) {
	      character = character.toLowerCase()
	    }
	
	    return character
	  }
	
	  // for non keypress events the special maps are needed
	  if (SPECIAL_KEYS_MAP[e.which]) {
	    return SPECIAL_KEYS_MAP[e.which]
	  }
	
	  if (SPECIAL_CHARACTERS_MAP[e.which]) {
	    return SPECIAL_CHARACTERS_MAP[e.which]
	  }
	
	  // if it is not in the special map
	
	  // with keydown and keyup events the character seems to always
	  // come in as an uppercase character whether you are pressing shift
	  // or not.  we should make sure it is always lowercase for comparisons
	  return String.fromCharCode(e.which).toLowerCase()
	}


/***/ },
/* 24 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	/**
	 * mapping of special keycodes to their corresponding keys
	 *
	 * everything in this dictionary cannot use keypress events
	 * so it has to be here to map to the correct keycodes for
	 * keyup/keydown events
	 *
	 * @type {Object}
	 */
	module.exports = {
	  8: 'backspace',
	  9: 'tab',
	  13: 'enter',
	  16: 'shift',
	  17: 'ctrl',
	  18: 'alt',
	  20: 'capslock',
	  27: 'esc',
	  32: 'space',
	  33: 'pageup',
	  34: 'pagedown',
	  35: 'end',
	  36: 'home',
	  37: 'left',
	  38: 'up',
	  39: 'right',
	  40: 'down',
	  45: 'ins',
	  46: 'del',
	  91: 'meta',
	  93: 'meta',
	  187: 'plus',
	  189: 'minus',
	  224: 'meta'
	}
	
	/**
	 * loop through the f keys, f1 to f19 and add them to the map
	 * programatically
	 */
	for (var i = 1; i < 20; ++i) {
	  module.exports[111 + i] = 'f' + i
	}
	
	/**
	 * loop through to map numbers on the numeric keypad
	 */
	for (i = 0; i <= 9; ++i) {
	  module.exports[i + 96] = i
	}


/***/ },
/* 25 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	/**
	 * mapping for special characters so they can support
	 *
	 * this dictionary is only used incase you want to bind a
	 * keyup or keydown event to one of these keys
	 *
	 * @type {Object}
	 */
	module.exports = {
	  106: '*',
	  107: '+',
	  109: '-',
	  110: '.',
	  111: '/',
	  186: ';',
	  187: '=',
	  188: ',',
	  189: '-',
	  190: '.',
	  191: '/',
	  192: '`',
	  219: '[',
	  220: '\\',
	  221: ']',
	  222: "'"
	}


/***/ },
/* 26 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * takes a key event and figures out what the modifiers are
	 *
	 * @param {Event} e
	 * @returns {Array}
	 */
	module.exports = function (e) {
	  var modifiers = []
	
	  if (e.shiftKey) {
	    modifiers.push('shift')
	  }
	
	  if (e.altKey) {
	    modifiers.push('alt')
	  }
	
	  if (e.ctrlKey) {
	    modifiers.push('ctrl')
	  }
	
	  if (e.metaKey) {
	    modifiers.push('meta')
	  }
	
	  return modifiers
	}


/***/ },
/* 27 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * binds a single keyboard combination
	 *
	 * @param {string} combination
	 * @param {Function} callback
	 * @param {string=} action
	 * @param {string=} sequenceName - name of sequence if part of sequence
	 * @param {number=} level - what part of the sequence the command is
	 * @returns void
	 */
	module.exports = function (combination, callback, action, sequenceName, level) {
	  var self = this
	
	  // store a direct mapped reference for use with Combokeys.trigger
	  self.directMap[combination + ':' + action] = callback
	
	  // make sure multiple spaces in a row become a single space
	  combination = combination.replace(/\s+/g, ' ')
	
	  var sequence = combination.split(' ')
	  var info
	
	  // if this pattern is a sequence of keys then run through this method
	  // to reprocess each pattern one key at a time
	  if (sequence.length > 1) {
	    self.bindSequence(combination, sequence, callback, action)
	    return
	  }
	
	  info = self.getKeyInfo(combination, action)
	
	  // make sure to initialize array if this is the first time
	  // a callback is added for this key
	  self.callbacks[info.key] = self.callbacks[info.key] || []
	
	  // remove an existing match if there is one
	  self.getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level)
	
	  // add this call back to the array
	  // if it is a sequence put it at the beginning
	  // if not put it at the end
	  //
	  // this is important because the way these are processed expects
	  // the sequence ones to come first
	  self.callbacks[info.key][sequenceName ? 'unshift' : 'push']({
	    callback: callback,
	    modifiers: info.modifiers,
	    action: info.action,
	    seq: sequenceName,
	    level: level,
	    combo: combination
	  })
	}


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * Gets info for a specific key combination
	 *
	 * @param  {string} combination key combination ("command+s" or "a" or "*")
	 * @param  {string=} action
	 * @returns {Object}
	 */
	module.exports = function (combination, action) {
	  var self = this
	  var keysFromString
	  var keys
	  var key
	  var j
	  var modifiers = []
	  var SPECIAL_ALIASES
	  var SHIFT_MAP
	  var isModifier
	
	  keysFromString = __webpack_require__(29)
	  // take the keys from this pattern and figure out what the actual
	  // pattern is all about
	  keys = keysFromString(combination)
	
	  SPECIAL_ALIASES = __webpack_require__(30)
	  SHIFT_MAP = __webpack_require__(31)
	  isModifier = __webpack_require__(19)
	  for (j = 0; j < keys.length; ++j) {
	    key = keys[j]
	
	    // normalize key names
	    if (SPECIAL_ALIASES[key]) {
	      key = SPECIAL_ALIASES[key]
	    }
	
	    // if this is not a keypress event then we should
	    // be smart about using shift keys
	    // this will only work for US keyboards however
	    if (action && action !== 'keypress' && SHIFT_MAP[key]) {
	      key = SHIFT_MAP[key]
	      modifiers.push('shift')
	    }
	
	    // if this key is a modifier then add it to the list of modifiers
	    if (isModifier(key)) {
	      modifiers.push(key)
	    }
	  }
	
	  // depending on what the key combination is
	  // we will try to pick the best event for it
	  action = self.pickBestAction(key, modifiers, action)
	
	  return {
	    key: key,
	    modifiers: modifiers,
	    action: action
	  }
	}


/***/ },
/* 29 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * Converts from a string key combination to an array
	 *
	 * @param  {string} combination like "command+shift+l"
	 * @return {Array}
	 */
	module.exports = function (combination) {
	  if (combination === '+') {
	    return ['+']
	  }
	
	  return combination.split('+')
	}


/***/ },
/* 30 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	/**
	 * this is a list of special strings you can use to map
	 * to modifier keys when you specify your keyboard shortcuts
	 *
	 * @type {Object}
	 */
	module.exports = {
	  'option': 'alt',
	  'command': 'meta',
	  'return': 'enter',
	  'escape': 'esc',
	  'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
	}


/***/ },
/* 31 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	/**
	 * this is a mapping of keys that require shift on a US keypad
	 * back to the non shift equivelents
	 *
	 * this is so you can use keyup events with these keys
	 *
	 * note that this will only work reliably on US keyboards
	 *
	 * @type {Object}
	 */
	module.exports = {
	  '~': '`',
	  '!': '1',
	  '@': '2',
	  '#': '3',
	  '$': '4',
	  '%': '5',
	  '^': '6',
	  '&': '7',
	  '*': '8',
	  '(': '9',
	  ')': '0',
	  '_': '-',
	  '+': '=',
	  ':': ';',
	  '"': "'",
	  '<': ',',
	  '>': '.',
	  '?': '/',
	  '|': '\\'
	}


/***/ },
/* 32 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * picks the best action based on the key combination
	 *
	 * @param {string} key - character for key
	 * @param {Array} modifiers
	 * @param {string=} action passed in
	 */
	module.exports = function (key, modifiers, action) {
	  var self = this
	
	  // if no action was picked in we should try to pick the one
	  // that we think would work best for this key
	  if (!action) {
	    action = self.getReverseMap()[key] ? 'keydown' : 'keypress'
	  }
	
	  // modifier keys don't work as expected with keypress,
	  // switch to keydown
	  if (action === 'keypress' && modifiers.length) {
	    action = 'keydown'
	  }
	
	  return action
	}


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * reverses the map lookup so that we can look for specific keys
	 * to see what can and can't use keypress
	 *
	 * @return {Object}
	 */
	module.exports = function () {
	  var self = this
	  var constructor = self.constructor
	  var SPECIAL_KEYS_MAP
	
	  if (!constructor.REVERSE_MAP) {
	    constructor.REVERSE_MAP = {}
	    SPECIAL_KEYS_MAP = __webpack_require__(24)
	    for (var key in SPECIAL_KEYS_MAP) {
	      // pull out the numeric keypad from here cause keypress should
	      // be able to detect the keys from the character
	      if (key > 95 && key < 112) {
	        continue
	      }
	
	      if (SPECIAL_KEYS_MAP.hasOwnProperty(key)) {
	        constructor.REVERSE_MAP[SPECIAL_KEYS_MAP[key]] = key
	      }
	    }
	  }
	  return constructor.REVERSE_MAP
	}


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * finds all callbacks that match based on the keycode, modifiers,
	 * and action
	 *
	 * @param {string} character
	 * @param {Array} modifiers
	 * @param {Event|Object} e
	 * @param {string=} sequenceName - name of the sequence we are looking for
	 * @param {string=} combination
	 * @param {number=} level
	 * @returns {Array}
	 */
	module.exports = function (character, modifiers, e, sequenceName, combination, level) {
	  var self = this
	  var j
	  var callback
	  var matches = []
	  var action = e.type
	  var isModifier
	  var modifiersMatch
	
	  if (
	      action === 'keypress' &&
	      // Firefox fires keypress for arrows
	      !(e.code && e.code.slice(0, 5) === 'Arrow')
	  ) {
	    // 'any-character' callbacks are only on `keypress`
	    var anyCharCallbacks = self.callbacks['any-character'] || []
	    anyCharCallbacks.forEach(function (callback) {
	      matches.push(callback)
	    })
	  }
	
	  if (!self.callbacks[character]) { return matches }
	
	  isModifier = __webpack_require__(19)
	  // if a modifier key is coming up on its own we should allow it
	  if (action === 'keyup' && isModifier(character)) {
	    modifiers = [character]
	  }
	
	  // loop through all callbacks for the key that was pressed
	  // and see if any of them match
	  for (j = 0; j < self.callbacks[character].length; ++j) {
	    callback = self.callbacks[character][j]
	
	    // if a sequence name is not specified, but this is a sequence at
	    // the wrong level then move onto the next match
	    if (!sequenceName && callback.seq && self.sequenceLevels[callback.seq] !== callback.level) {
	      continue
	    }
	
	    // if the action we are looking for doesn't match the action we got
	    // then we should keep going
	    if (action !== callback.action) {
	      continue
	    }
	
	    // if this is a keypress event and the meta key and control key
	    // are not pressed that means that we need to only look at the
	    // character, otherwise check the modifiers as well
	    //
	    // chrome will not fire a keypress if meta or control is down
	    // safari will fire a keypress if meta or meta+shift is down
	    // firefox will fire a keypress if meta or control is down
	    modifiersMatch = __webpack_require__(35)
	    if ((action === 'keypress' && !e.metaKey && !e.ctrlKey) || modifiersMatch(modifiers, callback.modifiers)) {
	      // when you bind a combination or sequence a second time it
	      // should overwrite the first one.  if a sequenceName or
	      // combination is specified in this call it does just that
	      //
	      // @todo make deleting its own method?
	      var deleteCombo = !sequenceName && callback.combo === combination
	      var deleteSequence = sequenceName && callback.seq === sequenceName && callback.level === level
	      if (deleteCombo || deleteSequence) {
	        self.callbacks[character].splice(j, 1)
	      }
	
	      matches.push(callback)
	    }
	  }
	
	  return matches
	}


/***/ },
/* 35 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * checks if two arrays are equal
	 *
	 * @param {Array} modifiers1
	 * @param {Array} modifiers2
	 * @returns {boolean}
	 */
	module.exports = function (modifiers1, modifiers2) {
	  return modifiers1.sort().join(',') === modifiers2.sort().join(',')
	}


/***/ },
/* 36 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * resets all sequence counters except for the ones passed in
	 *
	 * @param {Object} doNotReset
	 * @returns void
	 */
	module.exports = function (doNotReset) {
	  var self = this
	
	  doNotReset = doNotReset || {}
	
	  var activeSequences = false
	  var key
	
	  for (key in self.sequenceLevels) {
	    if (doNotReset[key]) {
	      activeSequences = true
	      continue
	    }
	    self.sequenceLevels[key] = 0
	  }
	
	  if (!activeSequences) {
	    self.nextExpectedAction = false
	  }
	}


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * actually calls the callback function
	 *
	 * if your callback function returns false this will use the jquery
	 * convention - prevent default and stop propogation on the event
	 *
	 * @param {Function} callback
	 * @param {Event} e
	 * @returns void
	 */
	module.exports = function (callback, e, combo, sequence) {
	  var self = this
	  var preventDefault
	  var stopPropagation
	
	  // if this event should not happen stop here
	  if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
	    return
	  }
	
	  if (callback(e, combo) === false) {
	    preventDefault = __webpack_require__(38)
	    preventDefault(e)
	    stopPropagation = __webpack_require__(39)
	    stopPropagation(e)
	  }
	}


/***/ },
/* 38 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * prevents default for this event
	 *
	 * @param {Event} e
	 * @returns void
	 */
	module.exports = function (e) {
	  if (e.preventDefault) {
	    e.preventDefault()
	    return
	  }
	
	  e.returnValue = false
	}


/***/ },
/* 39 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * stops propogation for this event
	 *
	 * @param {Event} e
	 * @returns void
	 */
	module.exports = function (e) {
	  if (e.stopPropagation) {
	    e.stopPropagation()
	    return
	  }
	
	  e.cancelBubble = true
	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env node, browser */
	'use strict'
	
	/**
	 * binds a key sequence to an event
	 *
	 * @param {string} combo - combo specified in bind call
	 * @param {Array} keys
	 * @param {Function} callback
	 * @param {string=} action
	 * @returns void
	 */
	module.exports = function (combo, keys, callback, action) {
	  var self = this
	
	  // start off by adding a sequence level record for this combination
	  // and setting the level to 0
	  self.sequenceLevels[combo] = 0
	
	  /**
	   * callback to increase the sequence level for this sequence and reset
	   * all other sequences that were active
	   *
	   * @param {string} nextAction
	   * @returns {Function}
	   */
	  function increaseSequence (nextAction) {
	    return function () {
	      self.nextExpectedAction = nextAction
	      ++self.sequenceLevels[combo]
	      self.resetSequenceTimer()
	    }
	  }
	
	  /**
	   * wraps the specified callback inside of another function in order
	   * to reset all sequence counters as soon as this sequence is done
	   *
	   * @param {Event} e
	   * @returns void
	   */
	  function callbackAndReset (e) {
	    var characterFromEvent
	    self.fireCallback(callback, e, combo)
	
	    // we should ignore the next key up if the action is key down
	    // or keypress.  this is so if you finish a sequence and
	    // release the key the final key will not trigger a keyup
	    if (action !== 'keyup') {
	      characterFromEvent = __webpack_require__(23)
	      self.ignoreNextKeyup = characterFromEvent(e)
	    }
	
	    // weird race condition if a sequence ends with the key
	    // another sequence begins with
	    setTimeout(
	      function () {
	        self.resetSequences()
	      },
	      10
	    )
	  }
	
	  // loop through keys one at a time and bind the appropriate callback
	  // function.  for any key leading up to the final one it should
	  // increase the sequence. after the final, it should reset all sequences
	  //
	  // if an action is specified in the original bind call then that will
	  // be used throughout.  otherwise we will pass the action that the
	  // next key in the sequence should match.  this allows a sequence
	  // to mix and match keypress and keydown events depending on which
	  // ones are better suited to the key provided
	  for (var j = 0; j < keys.length; ++j) {
	    var isFinal = j + 1 === keys.length
	    var wrappedCallback = isFinal ? callbackAndReset : increaseSequence(action || self.getKeyInfo(keys[j + 1]).action)
	    self.bindSingle(keys[j], wrappedCallback, action, combo, j)
	  }
	}


/***/ },
/* 41 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	/**
	 * called to set a 1 second timeout on the specified sequence
	 *
	 * this is so after each key press in the sequence you have 1 second
	 * to press the next key before you have to start over
	 *
	 * @returns void
	 */
	module.exports = function () {
	  var self = this
	
	  clearTimeout(self.resetTimer)
	  self.resetTimer = setTimeout(
	    function () {
	      self.resetSequences()
	    },
	    1000
	  )
	}


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var off = __webpack_require__(21).off
	module.exports = function () {
	  var self = this
	  var element = self.element
	
	  off(element, 'keypress', self.eventHandler)
	  off(element, 'keydown', self.eventHandler)
	  off(element, 'keyup', self.eventHandler)
	}


/***/ },
/* 43 */
/***/ function(module, exports) {

	/* eslint-env node, browser */
	'use strict'
	
	module.exports = function () {
	  var self = this
	
	  self.instances.forEach(function (combokeys) {
	    combokeys.reset()
	  })
	}


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(45));
	


/***/ },
/* 45 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * This is a mapping from standard library module names to their manifest IDs.
	 */
	exports.standardLibraryModules = {
	    '@microsoft/sp-client-preview': {
	        bundleReference: {
	            id: '4d5eb168-6729-49a8-aec7-0e397f486b6e'
	        },
	        preloadId: '4d5eb168-6729-49a8-aec7-0e397f486b6e',
	        dependentIds: [
	            '6aeaab4a-4d96-47fe-a0c2-9e063a2efda4',
	            'a8c07ea7-3ee8-4376-8afa-e0c5098615eb',
	            '02a01e42-69ab-403d-8a16-acd128661f8e'
	        ],
	        aliases: []
	    },
	    'office-ui-fabric-react': {
	        bundleReference: {
	            id: '02a01e42-69ab-403d-8a16-acd128661f8e'
	        },
	        preloadId: '02a01e42-69ab-403d-8a16-acd128661f8e',
	        dependentIds: ['6aeaab4a-4d96-47fe-a0c2-9e063a2efda4'],
	        aliases: []
	    },
	    '@microsoft/sp-lodash-subset': {
	        bundleReference: {
	            id: '73e1dc6c-8441-42cc-ad47-4bd3659f8a3a'
	        },
	        preloadId: 'a8c07ea7-3ee8-4376-8afa-e0c5098615eb',
	        dependentIds: [],
	        aliases: [{
	                id: 'a8c07ea7-3ee8-4376-8afa-e0c5098615eb',
	                entryName: 'spLodash'
	            }]
	    },
	    '@ms/sp-application-base': {
	        bundleReference: {
	            id: '4df9bb86-ab0a-4aab-ab5f-48bf167048fb'
	        },
	        preloadId: '4df9bb86-ab0a-4aab-ab5f-48bf167048fb',
	        dependentIds: [],
	        aliases: []
	    },
	    '@ms/sp-canvas': {
	        bundleReference: {
	            id: '85093aa7-8c12-4683-91aa-47cd5e2654db'
	        },
	        preloadId: '85093aa7-8c12-4683-91aa-47cd5e2654db',
	        dependentIds: [],
	        aliases: []
	    },
	    '@microsoft/sp-client-base': {
	        bundleReference: {
	            id: 'af59c2b3-2da7-41fd-8b72-3939817960af'
	        },
	        preloadId: 'a8c07ea7-3ee8-4376-8afa-e0c5098615eb',
	        dependentIds: [],
	        aliases: [{
	                id: 'a8c07ea7-3ee8-4376-8afa-e0c5098615eb',
	                entryName: 'spClientBase'
	            }]
	    },
	    '@ms/odsp-utilities-bundle': {
	        bundleReference: {
	            id: 'cc2cc925-b5be-41bb-880a-f0f8030c6aff'
	        },
	        preloadId: 'a8c07ea7-3ee8-4376-8afa-e0c5098615eb',
	        dependentIds: [],
	        aliases: [{
	                id: 'a8c07ea7-3ee8-4376-8afa-e0c5098615eb',
	                entryName: 'odspUtilitiesBundle'
	            }]
	    },
	    '@ms/sp-webpart-base': {
	        bundleReference: {
	            id: '974a7777-0990-4136-8fa6-95d80114c2e0'
	        },
	        preloadId: '974a7777-0990-4136-8fa6-95d80114c2e0',
	        dependentIds: [],
	        aliases: []
	    },
	    'react': {
	        bundleReference: {
	            id: '6aeaab4a-4d96-47fe-a0c2-9e063a2efda4',
	            entryName: 'react'
	        },
	        preloadId: '6aeaab4a-4d96-47fe-a0c2-9e063a2efda4',
	        dependentIds: [],
	        aliases: []
	    },
	    'react-dom': {
	        bundleReference: {
	            id: '6aeaab4a-4d96-47fe-a0c2-9e063a2efda4',
	            entryName: 'reactDom'
	        },
	        preloadId: '6aeaab4a-4d96-47fe-a0c2-9e063a2efda4',
	        dependentIds: [],
	        aliases: []
	    },
	    'flux': {
	        bundleReference: {
	            id: '6aeaab4a-4d96-47fe-a0c2-9e063a2efda4',
	            entryName: 'flux'
	        },
	        preloadId: '6aeaab4a-4d96-47fe-a0c2-9e063a2efda4',
	        dependentIds: [],
	        aliases: []
	    },
	    '@ms/i18n-utilities': {
	        bundleReference: {
	            id: 'c83d5509-ccd5-4c67-919f-2440f237927a'
	        },
	        preloadId: 'c83d5509-ccd5-4c67-919f-2440f237927a',
	        dependentIds: [],
	        aliases: []
	    }
	};
	


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @Copyright (c) Microsoft Corporation.  All rights reserved.
	 *
	 * @file SystemJsWrapper.ts
	 */
	"use strict";
	var loadSystemPolyfills = typeof Promise === 'undefined';
	if (loadSystemPolyfills) {
	    __webpack_require__(47);
	}
	var system = __webpack_require__(48);
	var sp_module_interfaces_1 = __webpack_require__(44);
	var SPModuleLoader_1 = __webpack_require__(9);
	/**
	 * Our wrapper around SystemJS for loading our own modules.
	 */
	var SystemJsWrapper = (function () {
	    function SystemJsWrapper() {
	        /**
	         * Map from a serial ID to the associated loader config.
	         */
	        this._manifestMap = new Map();
	        /* tslint:disable:no-any */
	        this._componentCache = new Map();
	        /* tslint:enable:no-any */
	        this._parentMap = new Map();
	    }
	    Object.defineProperty(SystemJsWrapper, "instance", {
	        get: function () {
	            if (!this._instance) {
	                this._instance = new SystemJsWrapper();
	                this._instance._initialize();
	            }
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Given a loader config, load a module.
	     *
	     * @param {manifest} A manifest loader config.
	     * @param {id} The manifest's ID
	     * @returns A promise containing the loaded module.
	     */
	    /* tslint:disable:no-any */
	    SystemJsWrapper.prototype.loadManifestModules = function (id, manifest, entryName, preloadDependencies) {
	        var _this = this;
	        if (preloadDependencies === void 0) { preloadDependencies = true; }
	        if (!this._componentCache.has(id)) {
	            this._componentCache.set(id, new Map());
	        }
	        var componentModuleCache = this._componentCache.get(id);
	        if (!componentModuleCache.has(id)) {
	            this._manifestMap.set(id, manifest);
	            componentModuleCache.set(id, system.import(id));
	        }
	        // The manifest may or may not have been loaded with preloadDependencies
	        var dependencies = Object.keys(manifest.scriptResources).map(function (resource) {
	            if (resource !== manifest.entryModuleId) {
	                // Preload unless shouldNotPreload flag is true
	                if (!componentModuleCache.has(resource) && manifest.scriptResources[resource].shouldNotPreload !== true) {
	                    _this._parentMap.set(resource, id);
	                    var dependency = system.import(resource);
	                    componentModuleCache.set(resource, dependency);
	                    return dependency;
	                }
	            }
	        });
	        return Promise.all([componentModuleCache.get(id)].concat(dependencies)).then(function (entry) {
	            var result = entry[0];
	            if (entryName) {
	                result = result[entryName];
	            }
	            if (manifest.exportedModuleName) {
	                result = result[manifest.exportedModuleName];
	            }
	            return result;
	        });
	    };
	    /* tslint:enable:no-any */
	    /**
	     * Given a URL, load a script.
	     *
	     * @param {scriptSrc} The script URL.
	     * @param {globalExportsName} (optional) If the script isn't an AMD module and loads a global member on the page,
	     *                  specify the global member's name.
	     * @return A promise containing the loaded module.
	     */
	    /* tslint:disable:no-any */
	    SystemJsWrapper.prototype.loadScript = function (scriptSrc, globalExportsName) {
	        /* tslint:enable:no-any */
	        if (globalExportsName) {
	            /* tslint:disable:typedef */
	            var globalMetaConfig = {
	                /* tslint:enable:typedef */
	                meta: {}
	            };
	            globalMetaConfig.meta[scriptSrc] = {
	                format: 'global',
	                exports: globalExportsName
	            };
	            system.config(globalMetaConfig);
	        }
	        return system.import(scriptSrc);
	    };
	    Object.defineProperty(SystemJsWrapper.prototype, "currentLocale", {
	        /**
	         * Set the current locale.
	         *
	         * @param {locale} The user's locale.
	         */
	        set: function (locale) {
	            if (locale) {
	                locale = locale.toLowerCase();
	            }
	            this._currentLocale = locale;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SystemJsWrapper.prototype._initialize = function () {
	        var _this = this;
	        var pluginName = 'sp-module-loader-resolver';
	        var baseUrl = 'https://spoppe-a.akamaihd.net/files/';
	        /**
	         * Resolve a localized module config to a URL.
	         */
	        var resolveLocalizedModuleConfig = function (moduleConfig) {
	            if (moduleConfig.paths && _this._currentLocale) {
	                for (var locale in moduleConfig.paths) {
	                    if (locale && locale.toLowerCase() === _this._currentLocale && moduleConfig.paths[locale]) {
	                        return moduleConfig.paths[locale];
	                    }
	                }
	            }
	            return moduleConfig.defaultPath;
	        };
	        /**
	         * Resolve a IModuleConfig to a URL
	         *
	         * Take a look at the IModuleConfig documentation for more information.
	         */
	        var resolveModuleConfig = function (moduleName, moduleConfig) {
	            if (moduleConfig) {
	                switch (moduleConfig.type) {
	                    case 'framework':
	                        return moduleName;
	                    case 'internal':
	                        return _this._resolvePath(moduleConfig.path);
	                    case 'localized':
	                        return _this._resolvePath(resolveLocalizedModuleConfig(moduleConfig));
	                    /* tslint:disable:no-null-keyword */
	                    case null:
	                    /* tslint:enable:no-null-keyword */
	                    case undefined:
	                    /* tslint:disable:no-switch-case-fall-through */
	                    default:
	                        /* tslint:enable:no-switch-case-fall-through */
	                        return moduleName;
	                }
	            }
	            else {
	                return moduleName;
	            }
	        };
	        /**
	         * We need to keep track of each imported module's parent module so we can resolve its manifest. This
	         * small wrapper around the system normalize function records the parent name of each module because that field
	         * doesn't get passed to the loader.
	         */
	        var self = this;
	        var oldNormalize = system.normalize;
	        system.normalize = function (name, parentName, parentAddress) {
	            // parentName           == "https://spoppe-a.akamaihd.net/files/4d5eb168-6729-49a8-aec7-0e397f486b6e"
	            // normalizedParentName == "4d5eb168-6729-49a8-aec7-0e397f486b6e"
	            var normalizedParentName = (parentName && parentName.length > baseUrl.length && parentName.substr(0, baseUrl.length) === baseUrl)
	                ? parentName.substr(baseUrl.length)
	                : parentName;
	            // @todo VSO #212246: this naive mapping strategy has several issues, replace with more robust solution
	            var parent = self._parentMap.get(name) || normalizedParentName;
	            while (parent && !self._manifestMap.has(parent)) {
	                parent = self._parentMap.get(parent);
	            }
	            self._parentMap.set(name, parent);
	            return oldNormalize.call(this, name, parentName, parentAddress);
	        };
	        var loader = {
	            /**
	             * This step's purpose is to reolve a resource's name to its location. There are three different types of resource
	             * references in our manifest schema, and there are four different types of address resolutions:
	             * - If we pass a URL directly into this function, just return the URL. This means that we aren't loading a
	             *    manifest.
	             * - If we resolve to an internal module, pass the path and fetch will load that
	             * - If we resolve a localized module, pick the current locale (or default) and pass the path to fetch like
	             *    an internal module
	             * - If we resolve an framework module, pass the name to fetch and let fetch find it by name
	             */
	            locate: function (module) {
	                var moduleName = (module.address.indexOf(baseUrl) === 0)
	                    ? module.address.substring(baseUrl.length)
	                    : module.address;
	                // Get the manifest either by the identifier that was passed to SystemJS, or if this is a child dependency,
	                // resolve the parent name and find the manifest based on that.
	                var parentName = _this._parentMap.get(moduleName);
	                var manifest = _this._manifestMap.get(moduleName);
	                var moduleConfig;
	                if (manifest) {
	                    moduleConfig = manifest.scriptResources[manifest.entryModuleId];
	                }
	                else if (parentName) {
	                    manifest = _this._manifestMap.get(parentName);
	                    moduleConfig = manifest.scriptResources[moduleName];
	                }
	                if (!moduleConfig) {
	                    console.log("Unable to resolve config for module: " + moduleName);
	                }
	                // Populate some important properties we need to persist in the SystemJS module object
	                module.name = moduleName;
	                var metadata = module.metadata;
	                metadata.manifest = manifest;
	                metadata.moduleConfig = moduleConfig;
	                // Resolve the path or name.
	                return resolveModuleConfig(moduleName, moduleConfig);
	            },
	            /**
	             * This step's purpose is to go out and get the module that "locate" found. There are three different core
	             * scenarios in this function:
	             * - The simplest is if this function recieves a path or a full URL. If it recieves a path, the
	             *    internalModuleBaseUrls from the manifest is prepended. Now with a full URL, we fall through to the OOB
	             *    SystemJS scriptLoad fetch step.
	             * - If we recieve a module name that we have bundled with the loader (react, flux, etc), we'll have webpack load
	             *    that module and return a promise that resolves to a SystemJS module containing the requested object.
	             *    NOTE: this method will go away when we support bundling multiple modules in a single manifest.
	             * - If we recieve a module name that resolves to one of the standard modules with an associated manifest, we'll
	             *    load that manifest using the same pipeline that we use to load any other manifest.
	             */
	            fetch: function (module) {
	                var metadata = module.metadata;
	                var address = module.address;
	                // Check if we're looking at an framework moduleConfig
	                if (metadata.moduleConfig && metadata.moduleConfig.type === 'framework') {
	                    var moduleConfig = metadata.moduleConfig;
	                    var standardLibraryModule = sp_module_interfaces_1.standardLibraryModules[module.address];
	                    if (standardLibraryModule) {
	                        try {
	                            return SPModuleLoader_1.default.instance.loadStandardLibraryModule(standardLibraryModule, module.address)
	                                .then(function (loadedModule) {
	                                // Wrap the loaded module so it falls through the rest of SystemJS
	                                return { module: loadedModule, match: function () { return undefined; } };
	                            });
	                        }
	                        catch (e) {
	                        }
	                    }
	                    // If we make it here, we weren't able to load the module by its manifest, so let's fall back to the path
	                    //   provided in the manfiest
	                    if (moduleConfig.failoverPath) {
	                        address = _this._resolvePath(moduleConfig.failoverPath);
	                    }
	                    else {
	                        throw new Error("Invalid framework module '" + module.address + "'.");
	                    }
	                }
	                // Fall back to the default systemJS loader if we make it here
	                metadata.scriptLoad = true;
	                metadata.loaderModule = undefined;
	                metadata.loader = undefined;
	                // Prepend the base URL if this isn't a fully-qualified URL.
	                if (module.address.indexOf('http://') !== 0 && module.address.indexOf('https://') !== 0) {
	                    module.address = (metadata.manifest.internalModuleBaseUrls[0] || baseUrl) + address;
	                }
	                // If this is a non-AMD module, inject dependency and globalName information
	                var internalModuleLoaderConfig = metadata.moduleConfig;
	                if (metadata.moduleConfig && internalModuleLoaderConfig.globalName) {
	                    // Load the script via XHR so we can execute in a sandbox
	                    metadata.scriptLoad = false;
	                    // Configure SystemJS to load this module correctly
	                    system.config({
	                        meta: (_a = {},
	                            _a[module.name] = {
	                                scriptLoad: false,
	                                format: 'global',
	                                deps: internalModuleLoaderConfig.globalDependencies,
	                                exports: internalModuleLoaderConfig.globalName
	                            },
	                            _a
	                        )
	                    });
	                }
	                // Call the OOB SystemJS fetch code.
	                return system.fetch(module);
	                var _a;
	            },
	            /**
	             * Not doing anything here - just passing the source module through.
	             */
	            translate: function (module) {
	                return module.source.module;
	            },
	            /**
	             * Not doing anything here - just passing the source module through.
	             */
	            instantiate: function (module) {
	                return module.source.module;
	            }
	        };
	        /**
	         * Create a default SystemJS config that passes everything to our loader.
	         */
	        var systemConfig = {
	            baseURL: baseUrl,
	            meta: {
	                '*': {
	                    loader: pluginName,
	                    scriptLoad: true
	                }
	            }
	        };
	        // Load the loader as a system module and then set the system config. We need to do this is this order, otherwise
	        // SystemJS will try to load our loader with itself, and will throw.
	        system.set(pluginName, system.newModule(loader));
	        system.config(systemConfig);
	    };
	    /**
	     * Resolve a path to the min or debug version of a script. Currently only min versions are supported.
	     */
	    SystemJsWrapper.prototype._resolvePath = function (path) {
	        if (typeof path === 'string') {
	            return path;
	        }
	        else {
	            return path.default;
	        }
	    };
	    return SystemJsWrapper;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SystemJsWrapper;
	


/***/ },
/* 47 */
/***/ function(module, exports) {

	(function (global) {
	  eval('/*\n * SystemJS Polyfills for URL and Promise providing IE8+ Support\n */\n!function(t){!function(e){"object"==typeof exports?module.exports=e():"function"==typeof t&&t.amd?t(e):"undefined"!=typeof window?window.Promise=e():"undefined"!=typeof global?global.Promise=e():"undefined"!=typeof self&&(self.Promise=e())}(function(){var t;return function e(t,n,o){function r(u,c){if(!n[u]){if(!t[u]){var f="function"==typeof require&&require;if(!c&&f)return f(u,!0);if(i)return i(u,!0);throw new Error("Cannot find module \'"+u+"\'")}var s=n[u]={exports:{}};t[u][0].call(s.exports,function(e){var n=t[u][1][e];return r(n?n:e)},s,s.exports,e,t,n,o)}return n[u].exports}for(var i="function"==typeof require&&require,u=0;u<o.length;u++)r(o[u]);return r}({1:[function(t,e,n){var o=t("../lib/decorators/unhandledRejection"),r=o(t("../lib/Promise"));e.exports="undefined"!=typeof global?global.Promise=r:"undefined"!=typeof self?self.Promise=r:r},{"../lib/Promise":2,"../lib/decorators/unhandledRejection":4}],2:[function(e,n,o){!function(t){"use strict";t(function(t){var e=t("./makePromise"),n=t("./Scheduler"),o=t("./env").asap;return e({scheduler:new n(o)})})}("function"==typeof t&&t.amd?t:function(t){n.exports=t(e)})},{"./Scheduler":3,"./env":5,"./makePromise":7}],3:[function(e,n,o){!function(t){"use strict";t(function(){function t(t){this._async=t,this._running=!1,this._queue=this,this._queueLen=0,this._afterQueue={},this._afterQueueLen=0;var e=this;this.drain=function(){e._drain()}}return t.prototype.enqueue=function(t){this._queue[this._queueLen++]=t,this.run()},t.prototype.afterQueue=function(t){this._afterQueue[this._afterQueueLen++]=t,this.run()},t.prototype.run=function(){this._running||(this._running=!0,this._async(this.drain))},t.prototype._drain=function(){for(var t=0;t<this._queueLen;++t)this._queue[t].run(),this._queue[t]=void 0;for(this._queueLen=0,this._running=!1,t=0;t<this._afterQueueLen;++t)this._afterQueue[t].run(),this._afterQueue[t]=void 0;this._afterQueueLen=0},t})}("function"==typeof t&&t.amd?t:function(t){n.exports=t()})},{}],4:[function(e,n,o){!function(t){"use strict";t(function(t){function e(t){throw t}function n(){}var o=t("../env").setTimer,r=t("../format");return function(t){function i(t){t.handled||(l.push(t),a("Potentially unhandled rejection ["+t.id+"] "+r.formatError(t.value)))}function u(t){var e=l.indexOf(t);e>=0&&(l.splice(e,1),h("Handled previous rejection ["+t.id+"] "+r.formatObject(t.value)))}function c(t,e){p.push(t,e),null===d&&(d=o(f,0))}function f(){for(d=null;p.length>0;)p.shift()(p.shift())}var s,a=n,h=n;"undefined"!=typeof console&&(s=console,a="undefined"!=typeof s.error?function(t){s.error(t)}:function(t){s.log(t)},h="undefined"!=typeof s.info?function(t){s.info(t)}:function(t){s.log(t)}),t.onPotentiallyUnhandledRejection=function(t){c(i,t)},t.onPotentiallyUnhandledRejectionHandled=function(t){c(u,t)},t.onFatalRejection=function(t){c(e,t.value)};var p=[],l=[],d=null;return t}})}("function"==typeof t&&t.amd?t:function(t){n.exports=t(e)})},{"../env":5,"../format":6}],5:[function(e,n,o){!function(t){"use strict";t(function(t){function e(){return"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process)}function n(){return"function"==typeof MutationObserver&&MutationObserver||"function"==typeof WebKitMutationObserver&&WebKitMutationObserver}function o(t){function e(){var t=n;n=void 0,t()}var n,o=document.createTextNode(""),r=new t(e);r.observe(o,{characterData:!0});var i=0;return function(t){n=t,o.data=i^=1}}var r,i="undefined"!=typeof setTimeout&&setTimeout,u=function(t,e){return setTimeout(t,e)},c=function(t){return clearTimeout(t)},f=function(t){return i(t,0)};if(e())f=function(t){return process.nextTick(t)};else if(r=n())f=o(r);else if(!i){var s=t,a=s("vertx");u=function(t,e){return a.setTimer(e,t)},c=a.cancelTimer,f=a.runOnLoop||a.runOnContext}return{setTimer:u,clearTimer:c,asap:f}})}("function"==typeof t&&t.amd?t:function(t){n.exports=t(e)})},{}],6:[function(e,n,o){!function(t){"use strict";t(function(){function t(t){var n="object"==typeof t&&null!==t&&(t.stack||t.message)?t.stack||t.message:e(t);return t instanceof Error?n:n+" (WARNING: non-Error used)"}function e(t){var e=String(t);return"[object Object]"===e&&"undefined"!=typeof JSON&&(e=n(t,e)),e}function n(t,e){try{return JSON.stringify(t)}catch(n){return e}}return{formatError:t,formatObject:e,tryStringify:n}})}("function"==typeof t&&t.amd?t:function(t){n.exports=t()})},{}],7:[function(e,n,o){!function(t){"use strict";t(function(){return function(t){function e(t,e){this._handler=t===_?e:n(t)}function n(t){function e(t){r.resolve(t)}function n(t){r.reject(t)}function o(t){r.notify(t)}var r=new b;try{t(e,n,o)}catch(i){n(i)}return r}function o(t){return k(t)?t:new e(_,new x(v(t)))}function r(t){return new e(_,new x(new P(t)))}function i(){return $}function u(){return new e(_,new b)}function c(t,e){var n=new b(t.receiver,t.join().context);return new e(_,n)}function f(t){return a(B,null,t)}function s(t,e){return a(M,t,e)}function a(t,n,o){function r(e,r,u){u.resolved||h(o,i,e,t(n,r,e),u)}function i(t,e,n){a[t]=e,0===--s&&n.become(new q(a))}for(var u,c="function"==typeof n?r:i,f=new b,s=o.length>>>0,a=new Array(s),p=0;p<o.length&&!f.resolved;++p)u=o[p],void 0!==u||p in o?h(o,c,p,u,f):--s;return 0===s&&f.become(new q(a)),new e(_,f)}function h(t,e,n,o,r){if(U(o)){var i=m(o),u=i.state();0===u?i.fold(e,n,void 0,r):u>0?e(n,i.value,r):(r.become(i),p(t,n+1,i))}else e(n,o,r)}function p(t,e,n){for(var o=e;o<t.length;++o)l(v(t[o]),n)}function l(t,e){if(t!==e){var n=t.state();0===n?t.visit(t,void 0,t._unreport):0>n&&t._unreport()}}function d(t){return"object"!=typeof t||null===t?r(new TypeError("non-iterable passed to race()")):0===t.length?i():1===t.length?o(t[0]):y(t)}function y(t){var n,o,r,i=new b;for(n=0;n<t.length;++n)if(o=t[n],void 0!==o||n in t){if(r=v(o),0!==r.state()){i.become(r),p(t,n+1,r);break}r.visit(i,i.resolve,i.reject)}return new e(_,i)}function v(t){return k(t)?t._handler.join():U(t)?j(t):new q(t)}function m(t){return k(t)?t._handler.join():j(t)}function j(t){try{var e=t.then;return"function"==typeof e?new g(e,t):new q(t)}catch(n){return new P(n)}}function _(){}function w(){}function b(t,n){e.createContext(this,n),this.consumers=void 0,this.receiver=t,this.handler=void 0,this.resolved=!1}function x(t){this.handler=t}function g(t,e){b.call(this),G.enqueue(new E(t,e,this))}function q(t){e.createContext(this),this.value=t}function P(t){e.createContext(this),this.id=++Y,this.value=t,this.handled=!1,this.reported=!1,this._report()}function R(t,e){this.rejection=t,this.context=e}function C(t){this.rejection=t}function O(){return new P(new TypeError("Promise cycle"))}function T(t,e){this.continuation=t,this.handler=e}function Q(t,e){this.handler=e,this.value=t}function E(t,e,n){this._then=t,this.thenable=e,this.resolver=n}function L(t,e,n,o,r){try{t.call(e,n,o,r)}catch(i){o(i)}}function S(t,e,n,o){this.f=t,this.z=e,this.c=n,this.to=o,this.resolver=X,this.receiver=this}function k(t){return t instanceof e}function U(t){return("object"==typeof t||"function"==typeof t)&&null!==t}function H(t,n,o,r){return"function"!=typeof t?r.become(n):(e.enterContext(n),F(t,n.value,o,r),void e.exitContext())}function N(t,n,o,r,i){return"function"!=typeof t?i.become(o):(e.enterContext(o),W(t,n,o.value,r,i),void e.exitContext())}function J(t,n,o,r,i){return"function"!=typeof t?i.notify(n):(e.enterContext(o),z(t,n,r,i),void e.exitContext())}function M(t,e,n){try{return t(e,n)}catch(o){return r(o)}}function F(t,e,n,o){try{o.become(v(t.call(n,e)))}catch(r){o.become(new P(r))}}function W(t,e,n,o,r){try{t.call(o,e,n,r)}catch(i){r.become(new P(i))}}function z(t,e,n,o){try{o.notify(t.call(n,e))}catch(r){o.notify(r)}}function A(t,e){e.prototype=V(t.prototype),e.prototype.constructor=e}function B(t,e){return e}function K(){}function D(){return"undefined"!=typeof process&&null!==process&&"function"==typeof process.emit?function(t,e){return"unhandledRejection"===t?process.emit(t,e.value,e):process.emit(t,e)}:"undefined"!=typeof self&&"function"==typeof CustomEvent?function(t,e,n){var o=!1;try{var r=new n("unhandledRejection");o=r instanceof n}catch(i){}return o?function(t,o){var r=new n(t,{detail:{reason:o.value,key:o},bubbles:!1,cancelable:!0});return!e.dispatchEvent(r)}:t}(K,self,CustomEvent):K}var G=t.scheduler,I=D(),V=Object.create||function(t){function e(){}return e.prototype=t,new e};e.resolve=o,e.reject=r,e.never=i,e._defer=u,e._handler=v,e.prototype.then=function(t,e,n){var o=this._handler,r=o.join().state();if("function"!=typeof t&&r>0||"function"!=typeof e&&0>r)return new this.constructor(_,o);var i=this._beget(),u=i._handler;return o.chain(u,o.receiver,t,e,n),i},e.prototype["catch"]=function(t){return this.then(void 0,t)},e.prototype._beget=function(){return c(this._handler,this.constructor)},e.all=f,e.race=d,e._traverse=s,e._visitRemaining=p,_.prototype.when=_.prototype.become=_.prototype.notify=_.prototype.fail=_.prototype._unreport=_.prototype._report=K,_.prototype._state=0,_.prototype.state=function(){return this._state},_.prototype.join=function(){for(var t=this;void 0!==t.handler;)t=t.handler;return t},_.prototype.chain=function(t,e,n,o,r){this.when({resolver:t,receiver:e,fulfilled:n,rejected:o,progress:r})},_.prototype.visit=function(t,e,n,o){this.chain(X,t,e,n,o)},_.prototype.fold=function(t,e,n,o){this.when(new S(t,e,n,o))},A(_,w),w.prototype.become=function(t){t.fail()};var X=new w;A(_,b),b.prototype._state=0,b.prototype.resolve=function(t){this.become(v(t))},b.prototype.reject=function(t){this.resolved||this.become(new P(t))},b.prototype.join=function(){if(!this.resolved)return this;for(var t=this;void 0!==t.handler;)if(t=t.handler,t===this)return this.handler=O();return t},b.prototype.run=function(){var t=this.consumers,e=this.handler;this.handler=this.handler.join(),this.consumers=void 0;for(var n=0;n<t.length;++n)e.when(t[n])},b.prototype.become=function(t){this.resolved||(this.resolved=!0,this.handler=t,void 0!==this.consumers&&G.enqueue(this),void 0!==this.context&&t._report(this.context))},b.prototype.when=function(t){this.resolved?G.enqueue(new T(t,this.handler)):void 0===this.consumers?this.consumers=[t]:this.consumers.push(t)},b.prototype.notify=function(t){this.resolved||G.enqueue(new Q(t,this))},b.prototype.fail=function(t){var e="undefined"==typeof t?this.context:t;this.resolved&&this.handler.join().fail(e)},b.prototype._report=function(t){this.resolved&&this.handler.join()._report(t)},b.prototype._unreport=function(){this.resolved&&this.handler.join()._unreport()},A(_,x),x.prototype.when=function(t){G.enqueue(new T(t,this))},x.prototype._report=function(t){this.join()._report(t)},x.prototype._unreport=function(){this.join()._unreport()},A(b,g),A(_,q),q.prototype._state=1,q.prototype.fold=function(t,e,n,o){N(t,e,this,n,o)},q.prototype.when=function(t){H(t.fulfilled,this,t.receiver,t.resolver)};var Y=0;A(_,P),P.prototype._state=-1,P.prototype.fold=function(t,e,n,o){o.become(this)},P.prototype.when=function(t){"function"==typeof t.rejected&&this._unreport(),H(t.rejected,this,t.receiver,t.resolver)},P.prototype._report=function(t){G.afterQueue(new R(this,t))},P.prototype._unreport=function(){this.handled||(this.handled=!0,G.afterQueue(new C(this)))},P.prototype.fail=function(t){this.reported=!0,I("unhandledRejection",this),e.onFatalRejection(this,void 0===t?this.context:t)},R.prototype.run=function(){this.rejection.handled||this.rejection.reported||(this.rejection.reported=!0,I("unhandledRejection",this.rejection)||e.onPotentiallyUnhandledRejection(this.rejection,this.context))},C.prototype.run=function(){this.rejection.reported&&(I("rejectionHandled",this.rejection)||e.onPotentiallyUnhandledRejectionHandled(this.rejection))},e.createContext=e.enterContext=e.exitContext=e.onPotentiallyUnhandledRejection=e.onPotentiallyUnhandledRejectionHandled=e.onFatalRejection=K;var Z=new _,$=new e(_,Z);return T.prototype.run=function(){this.handler.join().when(this.continuation)},Q.prototype.run=function(){var t=this.handler.consumers;if(void 0!==t)for(var e,n=0;n<t.length;++n)e=t[n],J(e.progress,this.value,this.handler,e.receiver,e.resolver)},E.prototype.run=function(){function t(t){o.resolve(t)}function e(t){o.reject(t)}function n(t){o.notify(t)}var o=this.resolver;L(this._then,this.thenable,t,e,n)},S.prototype.fulfilled=function(t){this.f.call(this.c,this.z,t,this.to)},S.prototype.rejected=function(t){this.to.reject(t)},S.prototype.progress=function(t){this.to.notify(t)},e}})}("function"==typeof t&&t.amd?t:function(t){n.exports=t()})},{}]},{},[1])(1)}),"undefined"!=typeof systemJSBootstrap&&systemJSBootstrap()}();\n');
	}.call(exports, (function() { return this; }())))

/***/ },
/* 48 */
/***/ function(module, exports) {

	(function (global) {
	  eval('/*\n * SystemJS v0.19.25\n */\n!function(){function e(){!function(e){function t(e,r){if("string"!=typeof e)throw new TypeError("URL must be a string");var n=String(e).replace(/^\\s+|\\s+$/g,"").match(/^([^:\\/?#]+:)?(?:\\/\\/(?:([^:@\\/?#]*)(?::([^:@\\/?#]*))?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);if(!n)throw new RangeError("Invalid URL format");var a=n[1]||"",o=n[2]||"",i=n[3]||"",s=n[4]||"",l=n[5]||"",u=n[6]||"",d=n[7]||"",c=n[8]||"",f=n[9]||"";if(void 0!==r){var m=r instanceof t?r:new t(r),p=!a&&!s&&!o;!p||d||c||(c=m.search),p&&"/"!==d[0]&&(d=d?(!m.host&&!m.username||m.pathname?"":"/")+m.pathname.slice(0,m.pathname.lastIndexOf("/")+1)+d:m.pathname);var h=[];d.replace(/^(\\.\\.?(\\/|$))+/,"").replace(/\\/(\\.(\\/|$))+/g,"/").replace(/\\/\\.\\.$/,"/../").replace(/\\/?[^\\/]*/g,function(e){"/.."===e?h.pop():h.push(e)}),d=h.join("").replace(/^\\//,"/"===d[0]?"/":""),p&&(u=m.port,l=m.hostname,s=m.host,i=m.password,o=m.username),a||(a=m.protocol)}"file:"==a&&(d=d.replace(/\\\\/g,"/")),this.origin=s?a+(""!==a||""!==s?"//":"")+s:"",this.href=a+(a&&s||"file:"==a?"//":"")+(""!==o?o+(""!==i?":"+i:"")+"@":"")+s+d+c+f,this.protocol=a,this.username=o,this.password=i,this.host=s,this.hostname=l,this.port=u,this.pathname=d,this.search=c,this.hash=f}e.URLPolyfill=t}("undefined"!=typeof self?self:global),function(e){function t(e,t){if(!e.originalErr)for(var r=(e.stack||e.message||e).split("\\n"),n=[],a=0;a<r.length;a++)("undefined"==typeof $__curScript||-1==r[a].indexOf($__curScript.src))&&n.push(r[a]);var o=(n?n.join("\\n	"):e.message)+"\\n	"+t;L||(o=o.replace(A?/file:\\/\\/\\//g:/file:\\/\\//g,""));var i=new Error(o,e.fileName,e.lineNumber);return L?i.stack=null:i.stack=o,i.originalErr=e.originalErr||e,i}function r(e,r,n){try{new Function(e).call(n)}catch(a){throw t(a,"Evaluating "+r)}}function n(){}function a(t){this._loader={loaderObj:this,loads:[],modules:{},importPromises:{},moduleRecords:{}},F(this,"global",{get:function(){return e}})}function o(){a.call(this),this.paths={}}function i(e,t){var r,n="",a=0;for(var o in e){var i=o.split("*");if(i.length>2)throw new TypeError("Only one wildcard in a path is permitted");if(1==i.length){if(t==o)return e[o];if(t.substr(0,o.length-1)==o.substr(0,o.length-1)&&(t.length<o.length||t[o.length-1]==o[o.length-1])&&"/"==e[o][e[o].length-1])return e[o].substr(0,e[o].length-1)+(t.length>o.length?"/"+t.substr(o.length):"")}else{var s=i[0].length;s>=a&&t.substr(0,i[0].length)==i[0]&&t.substr(t.length-i[1].length)==i[1]&&(a=s,n=o,r=t.substr(i[0].length,t.length-i[1].length-i[0].length))}}var l=e[n];return"string"==typeof r&&(l=l.replace("*",r)),l}function s(){}function l(){o.call(this),Z.call(this)}function u(){}function d(e,t){l.prototype[e]=t(l.prototype[e]||function(){})}function c(e){Z=e(Z||function(){})}function f(e){for(var t=[],r=[],n=0,a=e.length;a>n;n++){var o=D.call(t,e[n]);-1===o?(t.push(e[n]),r.push([n])):r[o].push(n)}return{names:t,indices:r}}function m(e){var t={};if("object"==typeof e||"function"==typeof e)if(G){var r;for(var n in e)(r=Object.getOwnPropertyDescriptor(e,n))&&F(t,n,r)}else{var a=e&&e.hasOwnProperty;for(var n in e)(!a||e.hasOwnProperty(n))&&(t[n]=e[n])}return t["default"]=e,F(t,"__useDefault",{value:!0}),t}function p(e,t,r){for(var n in t)r&&n in e||(e[n]=t[n]);return e}function h(e,t,r){for(var n in t){var a=t[n];n in e?a instanceof Array&&e[n]instanceof Array?e[n]=[].concat(r?a:e[n]).concat(r?e[n]:a):"object"==typeof a&&null!==a&&"object"==typeof e[n]?e[n]=p(p({},e[n]),a,r):r||(e[n]=a):e[n]=a}}function g(e){this.warnings&&"undefined"!=typeof console&&console.warn}function v(e,t){for(var r=e.split(".");r.length;)t=t[r.shift()];return t}function y(){if(Y[this.baseURL])return Y[this.baseURL];"/"!=this.baseURL[this.baseURL.length-1]&&(this.baseURL+="/");var e=new N(this.baseURL,J);return this.baseURL=e.href,Y[this.baseURL]=e}function b(e,t){var r,n=0;for(var a in e)if(t.substr(0,a.length)==a&&(t.length==a.length||"/"==t[a.length])){var o=a.split("/").length;if(n>=o)continue;r=a,n=o}return r}function w(e){this.set("@system-env",this.newModule({browser:L,node:!!this._nodeRequire,production:e,"default":!0}))}function x(e){return("."!=e[0]||!!e[1]&&"/"!=e[1]&&"."!=e[1])&&"/"!=e[0]&&!e.match(K)}function S(e,t){return t&&(t=t.replace(/#/g,"%05")),new N(e,t||Q).href.replace(/%05/g,"#")}function E(e,t){return new N(t,y.call(e)).href}function _(e,t){if(!x(e))return S(e,t);var r=b(this.map,e);if(r&&(e=this.map[r]+e.substr(r.length),!x(e)))return S(e);if(this.has(e))return e;if("@node/"==e.substr(0,6)&&-1!=ee.indexOf(e.substr(6))){if(!this._nodeRequire)throw new TypeError("Error loading "+e+". Can only load node core modules in Node.");return this.set(e,this.newModule(m(this._nodeRequire(e.substr(6))))),e}var n=i(this.paths,e);return n&&!x(n)?S(n):E(this,n||e)}function j(e){var t=e.match(ne);return t&&"System.register"==e.substr(t[0].length,15)}function k(){return{name:null,deps:null,originalIndices:null,declare:null,execute:null,executingRequire:!1,declarative:!1,normalizedDeps:null,groupIndex:null,evaluated:!1,module:null,esModule:null,esmExports:!1}}function P(t){if("string"==typeof t)return v(t,e);if(!(t instanceof Array))throw new Error("Global exports must be a string or array.");for(var r={},n=!0,a=0;a<t.length;a++){var o=v(t[a],e);n&&(r["default"]=o,n=!1),r[t[a].split(".").pop()]=o}return r}function R(e){var t,r,n,n="~"==e[0],a=e.lastIndexOf("|");return-1!=a?(t=e.substr(a+1),r=e.substr(n,a-n)||"@system-env"):(t=null,r=e.substr(n)),{module:r,prop:t,negate:n}}function O(e){return(e.negate?"~":"")+e.module+(e.prop?"|"+e.prop:"")}function M(e,t,r){return this["import"](e.module,t).then(function(t){if(e.prop?t=v(e.prop,t):"object"==typeof t&&t+""=="Module"&&(t=t["default"]),r&&"boolean"!=typeof t)throw new TypeError("Condition "+O(e)+" did not resolve to a boolean.");return e.negate?!t:t})}function z(e,t){var r=e.match(oe);if(!r)return Promise.resolve(e);var n=R(r[0].substr(2,r[0].length-3));return this.builder?this.normalize(n.module,t).then(function(t){return n.module=t,e.replace(oe,"#{"+O(n)+"}")}):M.call(this,n,t,!1).then(function(r){if("string"!=typeof r)throw new TypeError("The condition value for "+e+" doesn\'t resolve to a string.");if(-1!=r.indexOf("/"))throw new TypeError("Unabled to interpolate conditional "+e+(t?" in "+t:"")+"\\n	The condition value "+r+\' cannot contain a "/" separator.\');return e.replace(oe,r)})}function T(e,t){var r=e.lastIndexOf("#?");if(-1==r)return Promise.resolve(e);var n=R(e.substr(r+2));return this.builder?this.normalize(n.module,t).then(function(t){return n.module=t,e.substr(0,r)+"#?"+O(n)}):M.call(this,n,t,!0).then(function(t){return t?e.substr(0,r):"@empty"})}var I="undefined"==typeof window&&"undefined"!=typeof self&&"undefined"!=typeof importScripts,L="undefined"!=typeof window&&"undefined"!=typeof document,A="undefined"!=typeof process&&"undefined"!=typeof process.platform&&!!process.platform.match(/^win/);e.console||(e.console={assert:function(){}});var F,D=Array.prototype.indexOf||function(e){for(var t=0,r=this.length;r>t;t++)if(this[t]===e)return t;return-1};!function(){try{Object.defineProperty({},"a",{})&&(F=Object.defineProperty)}catch(e){F=function(e,t,r){try{e[t]=r.value||r.get.call(e)}catch(n){}}}}();var J;if("undefined"!=typeof document&&document.getElementsByTagName){if(J=document.baseURI,!J){var q=document.getElementsByTagName("base");J=q[0]&&q[0].href||window.location.href}J=J.split("#")[0].split("?")[0],J=J.substr(0,J.lastIndexOf("/")+1)}else if("undefined"!=typeof process&&process.cwd)J="file://"+(A?"/":"")+process.cwd()+"/",A&&(J=J.replace(/\\\\/g,"/"));else{if("undefined"==typeof location)throw new TypeError("No environment baseURI");J=e.location.href}try{var U="test:"==new e.URL("test:///").protocol}catch(C){}var N=U?e.URL:e.URLPolyfill;F(n.prototype,"toString",{value:function(){return"Module"}}),function(){function o(e){return{status:"loading",name:e,linkSets:[],dependencies:[],metadata:{}}}function i(e,t,r){return new Promise(c({step:r.address?"fetch":"locate",loader:e,moduleName:t,moduleMetadata:r&&r.metadata||{},moduleSource:r.source,moduleAddress:r.address}))}function s(e,t,r,n){return new Promise(function(a,o){a(e.loaderObj.normalize(t,r,n))}).then(function(t){var r;if(e.modules[t])return r=o(t),r.status="linked",r.module=e.modules[t],r;for(var n=0,a=e.loads.length;a>n;n++)if(r=e.loads[n],r.name==t)return r;return r=o(t),e.loads.push(r),l(e,r),r})}function l(e,t){u(e,t,Promise.resolve().then(function(){return e.loaderObj.locate({name:t.name,metadata:t.metadata})}))}function u(e,t,r){d(e,t,r.then(function(r){return"loading"==t.status?(t.address=r,e.loaderObj.fetch({name:t.name,metadata:t.metadata,address:r})):void 0}))}function d(t,n,a){a.then(function(a){return"loading"==n.status?Promise.resolve(t.loaderObj.translate({name:n.name,metadata:n.metadata,address:n.address,source:a})).then(function(e){return n.source=e,t.loaderObj.instantiate({name:n.name,metadata:n.metadata,address:n.address,source:e})}).then(function(a){if(void 0===a)return n.address=n.address||"<Anonymous Module "+ ++_+">",n.isDeclarative=!0,E.call(t.loaderObj,n).then(function(t){var a=e.System,o=a.register;a.register=function(e,t,r){"string"!=typeof e&&(r=t,t=e),n.declare=r,n.depsList=t},r(t,n.address,{}),a.register=o});if("object"!=typeof a)throw TypeError("Invalid instantiate return value");n.depsList=a.deps||[],n.execute=a.execute,n.isDeclarative=!1}).then(function(){n.dependencies=[];for(var e=n.depsList,r=[],a=0,o=e.length;o>a;a++)(function(e,a){r.push(s(t,e,n.name,n.address).then(function(t){if(n.dependencies[a]={key:e,value:t.name},"linked"!=t.status)for(var r=n.linkSets.concat([]),o=0,i=r.length;i>o;o++)m(r[o],t)}))})(e[a],a);return Promise.all(r)}).then(function(){n.status="loaded";for(var e=n.linkSets.concat([]),t=0,r=e.length;r>t;t++)h(e[t],n)}):void 0})["catch"](function(e){n.status="failed",n.exception=e;for(var t=n.linkSets.concat([]),r=0,a=t.length;a>r;r++)g(t[r],n,e)})}function c(e){return function(t,r){var n=e.loader,a=e.moduleName,i=e.step;if(n.modules[a])throw new TypeError(\'"\'+a+\'" already exists in the module table\');for(var s,c=0,m=n.loads.length;m>c;c++)if(n.loads[c].name==a&&(s=n.loads[c],"translate"!=i||s.source||(s.address=e.moduleAddress,d(n,s,Promise.resolve(e.moduleSource))),s.linkSets.length&&s.linkSets[0].loads[0].name==s.name))return s.linkSets[0].done.then(function(){t(s)});var p=s||o(a);p.metadata=e.moduleMetadata;var h=f(n,p);n.loads.push(p),t(h.done),"locate"==i?l(n,p):"fetch"==i?u(n,p,Promise.resolve(e.moduleAddress)):(p.address=e.moduleAddress,d(n,p,Promise.resolve(e.moduleSource)))}}function f(e,t){var r={loader:e,loads:[],startingLoad:t,loadingCount:0};return r.done=new Promise(function(e,t){r.resolve=e,r.reject=t}),m(r,t),r}function m(e,t){if("failed"!=t.status){for(var r=0,n=e.loads.length;n>r;r++)if(e.loads[r]==t)return;e.loads.push(t),t.linkSets.push(e),"loaded"!=t.status&&e.loadingCount++;for(var a=e.loader,r=0,n=t.dependencies.length;n>r;r++)if(t.dependencies[r]){var o=t.dependencies[r].value;if(!a.modules[o])for(var i=0,s=a.loads.length;s>i;i++)if(a.loads[i].name==o){m(e,a.loads[i]);break}}}}function p(e){var t=!1;try{w(e,function(r,n){g(e,r,n),t=!0})}catch(r){g(e,null,r),t=!0}return t}function h(e,t){if(e.loadingCount--,!(e.loadingCount>0)){var r=e.startingLoad;if(e.loader.loaderObj.execute===!1){for(var n=[].concat(e.loads),a=0,o=n.length;o>a;a++){var t=n[a];t.module=t.isDeclarative?{name:t.name,module:j({}),evaluated:!0}:{module:j({})},t.status="linked",v(e.loader,t)}return e.resolve(r)}var i=p(e);i||e.resolve(r)}}function g(e,r,n){var a=e.loader;e:if(r)if(e.loads[0].name==r.name)n=t(n,"Error loading "+r.name);else{for(var o=0;o<e.loads.length;o++)for(var i=e.loads[o],s=0;s<i.dependencies.length;s++){var l=i.dependencies[s];if(l.value==r.name){n=t(n,"Error loading "+r.name+\' as "\'+l.key+\'" from \'+i.name);break e}}n=t(n,"Error loading "+r.name+" from "+e.loads[0].name)}else n=t(n,"Error linking "+e.loads[0].name);for(var u=e.loads.concat([]),o=0,d=u.length;d>o;o++){var r=u[o];a.loaderObj.failed=a.loaderObj.failed||[],-1==D.call(a.loaderObj.failed,r)&&a.loaderObj.failed.push(r);var c=D.call(r.linkSets,e);if(r.linkSets.splice(c,1),0==r.linkSets.length){var f=D.call(e.loader.loads,r);-1!=f&&e.loader.loads.splice(f,1)}}e.reject(n)}function v(e,t){if(e.loaderObj.trace){e.loaderObj.loads||(e.loaderObj.loads={});var r={};t.dependencies.forEach(function(e){r[e.key]=e.value}),e.loaderObj.loads[t.name]={name:t.name,deps:t.dependencies.map(function(e){return e.key}),depMap:r,address:t.address,metadata:t.metadata,source:t.source,kind:t.isDeclarative?"declarative":"dynamic"}}t.name&&(e.modules[t.name]=t.module);var n=D.call(e.loads,t);-1!=n&&e.loads.splice(n,1);for(var a=0,o=t.linkSets.length;o>a;a++)n=D.call(t.linkSets[a].loads,t),-1!=n&&t.linkSets[a].loads.splice(n,1);t.linkSets.splice(0,t.linkSets.length)}function y(e,t,r){try{var a=t.execute()}catch(o){return void r(t,o)}return a&&a instanceof n?a:void r(t,new TypeError("Execution must define a Module instance"))}function b(e,t,r){var n=e._loader.importPromises;return n[t]=r.then(function(e){return n[t]=void 0,e},function(e){throw n[t]=void 0,e})}function w(e,t){var r=e.loader;if(e.loads.length)for(var n=e.loads.concat([]),a=0;a<n.length;a++){var o=n[a],i=y(e,o,t);if(!i)return;o.module={name:o.name,module:i},o.status="linked",v(r,o)}}function x(e,t){return t.module.module}function S(){}function E(){throw new TypeError("ES6 transpilation is only provided in the dev module loader build.")}var _=0;a.prototype={constructor:a,define:function(e,t,r){if(this._loader.importPromises[e])throw new TypeError("Module is already loading.");return b(this,e,new Promise(c({step:"translate",loader:this._loader,moduleName:e,moduleMetadata:r&&r.metadata||{},moduleSource:t,moduleAddress:r&&r.address})))},"delete":function(e){var t=this._loader;return delete t.importPromises[e],delete t.moduleRecords[e],t.modules[e]?delete t.modules[e]:!1},get:function(e){return this._loader.modules[e]?(S(this._loader.modules[e],[],this),this._loader.modules[e].module):void 0},has:function(e){return!!this._loader.modules[e]},"import":function(e,t,r){"object"==typeof t&&(t=t.name);var n=this;return Promise.resolve(n.normalize(e,t)).then(function(e){var t=n._loader;return t.modules[e]?(S(t.modules[e],[],t._loader),t.modules[e].module):t.importPromises[e]||b(n,e,i(t,e,{}).then(function(r){return delete t.importPromises[e],x(t,r)}))})},load:function(e){var t=this._loader;return t.modules[e]?Promise.resolve():t.importPromises[e]||b(this,e,new Promise(c({step:"locate",loader:t,moduleName:e,moduleMetadata:{},moduleSource:void 0,moduleAddress:void 0})).then(function(){delete t.importPromises[e]}))},module:function(e,t){var r=o();r.address=t&&t.address;var n=f(this._loader,r),a=Promise.resolve(e),i=this._loader,s=n.done.then(function(){return x(i,r)});return d(i,r,a),s},newModule:function(e){if("object"!=typeof e)throw new TypeError("Expected object");var t=new n,r=[];if(Object.getOwnPropertyNames&&null!=e)r=Object.getOwnPropertyNames(e);else for(var a in e)r.push(a);for(var o=0;o<r.length;o++)(function(r){F(t,r,{configurable:!1,enumerable:!0,get:function(){return e[r]},set:function(){throw new Error("Module exports cannot be changed externally.")}})})(r[o]);return Object.freeze&&Object.freeze(t),t},set:function(e,t){if(!(t instanceof n))throw new TypeError("Loader.set("+e+", module) must be a module");this._loader.modules[e]={module:t}},normalize:function(e,t,r){return e},locate:function(e){return e.name},fetch:function(e){},translate:function(e){return e.source},instantiate:function(e){}};var j=a.prototype.newModule}();var $;s.prototype=a.prototype,o.prototype=new s;var B;if("undefined"!=typeof XMLHttpRequest)B=function(e,t,r,n){function a(){r(i.responseText)}function o(){n(new Error("XHR error"+(i.status?" ("+i.status+(i.statusText?" "+i.statusText:"")+")":"")+" loading "+e))}var i=new XMLHttpRequest,s=!0,l=!1;if(!("withCredentials"in i)){var u=/^(\\w+:)?\\/\\/([^\\/]+)/.exec(e);u&&(s=u[2]===window.location.host,u[1]&&(s&=u[1]===window.location.protocol))}s||"undefined"==typeof XDomainRequest||(i=new XDomainRequest,i.onload=a,i.onerror=o,i.ontimeout=o,i.onprogress=function(){},i.timeout=0,l=!0),i.onreadystatechange=function(){4===i.readyState&&(0==i.status?i.responseText?a():(i.addEventListener("error",o),i.addEventListener("load",a)):200===i.status?a():o())},i.open("GET",e,!0),i.setRequestHeader&&(i.setRequestHeader("Accept","application/x-es-module, */*"),t&&("string"==typeof t&&i.setRequestHeader("Authorization",t),i.withCredentials=!0)),l?setTimeout(function(){i.send()},0):i.send(null)};else if("undefined"!=typeof require&&"undefined"!=typeof process){var H;B=function(e,t,r,n){if("file:///"!=e.substr(0,8))throw new Error(\'Unable to fetch "\'+e+\'". Only file URLs of the form file:/// allowed running in Node.\');return H=H||require("fs"),e=A?e.replace(/\\//g,"\\\\").substr(8):e.substr(7),H.readFile(e,function(e,t){if(e)return n(e);var a=t+"";"\\ufeff"===a[0]&&(a=a.substr(1)),r(a)})}}else{if("undefined"==typeof self||"undefined"==typeof self.fetch)throw new TypeError("No environment fetch API available.");B=function(e,t,r,n){var a={headers:{Accept:"application/x-es-module, */*"}};t&&("string"==typeof t&&(a.headers.Authorization=t),a.credentials="include"),fetch(e,a).then(function(e){if(e.ok)return e.text();throw new Error("Fetch error: "+e.status+" "+e.statusText)}).then(r,n)}}o.prototype.fetch=function(e){return new Promise(function(t,r){B(e.address,void 0,t,r)})};var X=function(){function t(t){var n=this;return Promise.resolve(e["typescript"==n.transpiler?"ts":n.transpiler]||(n.pluginLoader||n)["import"](n.transpiler)).then(function(e){e.__useDefault&&(e=e["default"]);var a;return a=e.Compiler?r:e.createLanguageService?i:o,"(function(__moduleName){"+a.call(n,t,e)+\'\\n})("\'+t.name+\'");\\n//# sourceURL=\'+t.address+"!transpiled"})}function r(e,t){var r=this.traceurOptions||{};r.modules="instantiate",r.script=!1,void 0===r.sourceMaps&&(r.sourceMaps="inline"),r.filename=e.address,r.inputSourceMap=e.metadata.sourceMap,r.moduleName=!1;var a=new t.Compiler(r);return n(e.source,a,r.filename)}function n(e,t,r){try{return t.compile(e,r)}catch(n){if(n.length)throw n[0];throw n}}function o(e,t){var r=this.babelOptions||{};return r.modules="system",void 0===r.sourceMap&&(r.sourceMap="inline"),r.inputSourceMap=e.metadata.sourceMap,r.filename=e.address,r.code=!0,r.ast=!1,t.transform(e.source,r).code}function i(e,t){var r=this.typescriptOptions||{};return r.target=r.target||t.ScriptTarget.ES5,void 0===r.sourceMap&&(r.sourceMap=!0),r.sourceMap&&r.inlineSourceMap!==!1&&(r.inlineSourceMap=!0),r.module=t.ModuleKind.System,t.transpile(e.source,r,e.address)}return a.prototype.transpiler="traceur",t}();u.prototype=o.prototype,l.prototype=new u,l.prototype.constructor=l,l.prototype.instantiate=function(){};var Z,G=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(C){G=!1}var W,V=["main","format","defaultExtension","meta","map","basePath","depCache"];!function(){function r(e){var t=e.source.lastIndexOf("\\n"),r="global"!=e.metadata.format,n=e.metadata.sourceMap;if(n){if("object"!=typeof n)throw new TypeError("load.metadata.sourceMap must be set to an object.");n=JSON.stringify(n)}return(r?"(function(System, SystemJS, require) {":"")+e.source+(r?"\\n})(System, System);":"")+("\\n//# sourceURL="!=e.source.substr(t,15)?"\\n//# sourceURL="+e.address+(n?"!transpiled":""):"")+(n&&s&&"\\n//# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(n)))||"")}function n(t,r){i=r,0==u++&&(l=e.System),e.System=e.SystemJS=t}function a(){0==--u&&(e.System=e.SystemJS=l),i=void 0}function o(e){m||(m=document.head||document.body||document.documentElement);var o=document.createElement("script");o.text=r(e,!1);var i,s=window.onerror;if(window.onerror=function(r){i=t(r,"Evaluating "+e.address)},n(this,e),e.metadata.integrity&&o.setAttribute("integrity",e.metadata.integrity),e.metadata.nonce&&o.setAttribute("nonce",e.metadata.nonce),m.appendChild(o),m.removeChild(o),a(),window.onerror=s,i)throw i}var i,s="undefined"!=typeof btoa;d("pushRegister_",function(){return function(e){return i?(this.reduceRegister_(i,e),!0):!1}});var l,u=0;W=function(e){if((e.metadata.integrity||e.metadata.nonce)&&c)return o.call(this,e);try{n(this,e),i=e,(0,eval)(r(e)),a()}catch(s){throw a(),t(s,"Evaluating "+e.address)}};var c=!1;if(L&&"undefined"!=typeof document&&document.getElementsByTagName){var f=document.getElementsByTagName("script");$__curScript=f[f.length-1],window.chrome&&window.chrome.extension||navigator.userAgent.match(/^Node\\.js/)||(c=!0)}var m}();var K=/^[^\\/]+:\\/\\//,Y={},Q=new N(J);c(function(e){return function(){e.call(this),this.baseURL=J.substr(0,J.lastIndexOf("/")+1),this.map={},this.paths={},this.warnings=!1,this.defaultJSExtensions=!1,this.pluginFirst=!1,this.loaderErrorStack=!1,this.set("@empty",this.newModule({})),w.call(this,!1)}}),"undefined"==typeof require||"undefined"==typeof process||process.browser||(l.prototype._nodeRequire=require);var ee=["assert","buffer","child_process","cluster","console","constants","crypto","dgram","dns","domain","events","fs","http","https","module","net","os","path","process","punycode","querystring","readline","repl","stream","string_decoder","sys","timers","tls","tty","url","util","vm","zlib"];d("normalize",function(e){return function(e,t,r){var n=_.call(this,e,t);return r||!this.defaultJSExtensions||".js"==n.substr(n.length-3,3)||x(n)||(n+=".js"),n}});var te="undefined"!=typeof XMLHttpRequest;d("locate",function(e){return function(t){return Promise.resolve(e.call(this,t)).then(function(e){return te?e.replace(/#/g,"%23"):e})}}),d("fetch",function(){return function(e){return new Promise(function(t,r){B(e.address,e.metadata.authorization,t,r)})}}),d("import",function(e){return function(t,r,n){return r&&r.name&&g.call(this,"SystemJS.import(name, { name: parentName }) is deprecated for SystemJS.import(name, parentName), while importing "+t+" from "+r.name),e.call(this,t,r,n).then(function(e){return e.__useDefault?e["default"]:e})}}),d("translate",function(e){return function(t){return"detect"==t.metadata.format&&(t.metadata.format=void 0),e.call(this,t)}}),d("instantiate",function(e){return function(e){if("json"==e.metadata.format&&!this.builder){var t=e.metadata.entry=k();t.deps=[],t.execute=function(){try{return JSON.parse(e.source)}catch(t){throw new Error("Invalid JSON file "+e.name)}}}}}),l.prototype.env="development";var re;l.prototype.config=function(e){function t(e){for(var t in e)if(hasOwnProperty.call(e,t))return!0}var r=this;if("loaderErrorStack"in e&&(re=$__curScript,e.loaderErrorStack?$__curScript=void 0:$__curScript=re),"warnings"in e&&(r.warnings=e.warnings),e.transpilerRuntime===!1&&(r._loader.loadedTranspilerRuntime=!0),e.baseURL){if(t(r.packages)||t(r.meta)||t(r.depCache)||t(r.bundles)||t(r.packageConfigPaths))throw new TypeError("Incorrect configuration order. The baseURL must be configured with the first SystemJS.config call.");r.baseURL=e.baseURL,y.call(r)}if(e.defaultJSExtensions&&(r.defaultJSExtensions=e.defaultJSExtensions,g.call(r,"The defaultJSExtensions configuration option is deprecated, use packages configuration instead.")),e.pluginFirst&&(r.pluginFirst=e.pluginFirst),e.production&&w.call(r,!0),e.paths)for(var n in e.paths)r.paths[n]=e.paths[n];if(e.map){var a="";for(var n in e.map){var o=e.map[n];if("string"!=typeof o){a+=(a.length?", ":"")+\'"\'+n+\'"\';var i=r.defaultJSExtensions&&".js"!=n.substr(n.length-3,3),s=r.decanonicalize(n);i&&".js"==s.substr(s.length-3,3)&&(s=s.substr(0,s.length-3));var l="";for(var u in r.packages)s.substr(0,u.length)==u&&(!s[u.length]||"/"==s[u.length])&&l.split("/").length<u.split("/").length&&(l=u);l&&r.packages[l].main&&(s=s.substr(0,s.length-r.packages[l].main.length-1));var u=r.packages[s]=r.packages[s]||{};u.map=o}else r.map[n]=o}a&&g.call(r,"The map configuration for "+a+\' uses object submaps, which is deprecated in global map.\\nUpdate this to use package contextual map with configs like SystemJS.config({ packages: { "\'+n+\'": { map: {...} } } }).\')}if(e.packageConfigPaths){for(var d=[],c=0;c<e.packageConfigPaths.length;c++){var f=e.packageConfigPaths[c],m=Math.max(f.lastIndexOf("*")+1,f.lastIndexOf("/")),i=r.defaultJSExtensions&&".js"!=f.substr(m-3,3),p=r.decanonicalize(f.substr(0,m));i&&".js"==p.substr(p.length-3,3)&&(p=p.substr(0,p.length-3)),d[c]=p+f.substr(m)}r.packageConfigPaths=d}if(e.bundles)for(var n in e.bundles){for(var v=[],c=0;c<e.bundles[n].length;c++){var i=r.defaultJSExtensions&&".js"!=e.bundles[n][c].substr(e.bundles[n][c].length-3,3),b=r.decanonicalize(e.bundles[n][c]);i&&".js"==b.substr(b.length-3,3)&&(b=b.substr(0,b.length-3)),v.push(b)}r.bundles[n]=v}if(e.packages)for(var n in e.packages){if(n.match(/^([^\\/]+:)?\\/\\/$/))throw new TypeError(\'"\'+n+\'" is not a valid package name.\');var s=_.call(r,n);"/"==s[s.length-1]&&(s=s.substr(0,s.length-1)),r.packages[s]=r.packages[s]||{};var u=e.packages[n];u.modules&&(g.call(r,"Package "+n+\' is configured with "modules", which is deprecated as it has been renamed to "meta".\'),u.meta=u.modules,delete u.modules),"object"==typeof u.main&&(u.map=u.map||{},u.map["./@main"]=u.main,u.main["default"]=u.main["default"]||"./",u.main="@main");for(var S in u)-1==D.call(V,S)&&g.call(r,\'"\'+S+\'" is not a valid package configuration option in package \'+n);h(r.packages[s],u)}for(var E in e){var o=e[E];if("baseURL"!=E&&"map"!=E&&"packages"!=E&&"bundles"!=E&&"paths"!=E&&"warnings"!=E&&"packageConfigPaths"!=E&&"loaderErrorStack"!=E)if("object"!=typeof o||o instanceof Array)r[E]=o;else{r[E]=r[E]||{};for(var n in o)if("meta"==E&&"*"==n[0])r[E][n]=o[n];else if("meta"==E){var j=_.call(r,n);r.defaultJSExtensions&&".js"!=j.substr(j.length-3,3)&&!x(j)&&(j+=".js"),r[E][j]=o[n]}else if("depCache"==E){var i=r.defaultJSExtensions&&".js"!=n.substr(n.length-3,3),s=r.decanonicalize(n);i&&".js"==s.substr(s.length-3,3)&&(s=s.substr(0,s.length-3)),r[E][s]=o[n]}else r[E][n]=o[n]}}},function(){function e(e,t){var r,n,a=0;for(var o in e.packages)t.substr(0,o.length)!==o||t.length!==o.length&&"/"!==t[o.length]||(n=o.split("/").length,n>a&&(r=o,a=n));return r}function t(e,t,r,n,a){if(!n||"/"==n[n.length-1]||a||t.defaultExtension===!1)return n;if(n.match(oe))return n;var o=!1;if(t.meta&&p(t.meta,n,function(e,t,r){return 0==r||e.lastIndexOf("*")!=e.length-1?o=!0:void 0}),!o&&e.meta&&p(e.meta,r+"/"+n,function(e,t,r){return 0==r||e.lastIndexOf("*")!=e.length-1?o=!0:void 0}),o)return n;var i="."+(t.defaultExtension||"js");return n.substr(n.length-i.length)!=i?n+i:n}function r(e,r,n,o,i){if(!o){if(!r.main)return n+(e.defaultJSExtensions?".js":"");o="./"==r.main.substr(0,2)?r.main.substr(2):r.main}if(r.map){var s="./"+o,l=b(r.map,s);if(l||(s="./"+t(e,r,n,o,i),s!="./"+o&&(l=b(r.map,s))),l)return a(e,r,n,l,s,i)}return n+"/"+t(e,r,n,o,i)}function n(e,t,r){if("."==e)throw new Error("Package "+r+\' has a map entry for "." which is not permitted.\');if(t.substr(0,e.length)==e&&"/"!=e[e.length-1]&&"/"==t[e.length])throw new Error("Package "+r+\' has a recursive map for "\'+e+\'" which is not permitted.\')}function a(e,r,a,o,i,s){var l=r.map[o];if("object"==typeof l)throw new Error("Synchronous conditional normalization not supported sync normalizing "+o+" in "+a);if(n(o,l,a),"string"!=typeof l&&(l=o=i),n(o,l,a),"."==l)l=a;else if("./"==l.substr(0,2))return a+"/"+t(e,r,a,l.substr(2)+i.substr(o.length),s);return e.normalizeSync(l+i.substr(o.length),a+"/")}function o(e,r,n,a,o){if(!a){if(!r.main)return Promise.resolve(n+(e.defaultJSExtensions?".js":""));a="./"==r.main.substr(0,2)?r.main.substr(2):r.main}var i,l;return r.map&&(i="./"+a,l=b(r.map,i),l||(i="./"+t(e,r,n,a,o),i!="./"+a&&(l=b(r.map,i)))),(l?s(e,r,n,l,i,o):Promise.resolve()).then(function(i){return i?Promise.resolve(i):Promise.resolve(n+"/"+t(e,r,n,a,o))})}function i(e,r,n,a,o,i,s){if("."==o)o=n;else if("./"==o.substr(0,2))return Promise.resolve(n+"/"+t(e,r,n,o.substr(2)+i.substr(a.length),s)).then(function(t){return z.call(e,t,n+"/")});return e.normalize(o+i.substr(a.length),n+"/")}function s(e,t,r,a,o,s){var l=t.map[a];return"string"==typeof l?(n(a,l,r),i(e,t,r,a,l,o,s)):e.builder?Promise.resolve(r+"/#:"+o):e["import"](t.map["@env"]||"@system-env",r).then(function(e){for(var t in l){var r="~"==t[0],n=v(r?t.substr(1):t,e);if(!r&&n||r&&!n)return l[t]}}).then(function(l){if(l){if("string"!=typeof l)throw new Error("Unable to map a package conditional to a package conditional.");return n(a,l,r),i(e,t,r,a,l,o,s)}})}function u(e){var t=e.lastIndexOf("*"),r=Math.max(t+1,e.lastIndexOf("/"));return{length:r,regEx:new RegExp("^("+e.substr(0,r).replace(/[.+?^${}()|[\\]\\\\]/g,"\\\\$&").replace(/\\*/g,"[^\\\\/]+")+")(\\\\/|$)"),wildcard:-1!=t}}function f(e,t){for(var r,n,a=!1,o=0;o<e.packageConfigPaths.length;o++){var i=e.packageConfigPaths[o],s=y[i]||(y[i]=u(i));if(!(t.length<s.length)){var l=t.match(s.regEx);!l||r&&(a&&s.wildcard||!(r.length<l[1].length))||(r=l[1],a=!s.wildcard,n=r+i.substr(s.length))}}return r?{packageName:r,configPath:n}:void 0}function m(e,t,r){var n=e.pluginLoader||e;return(n.meta[r]=n.meta[r]||{}).format="json",n.load(r).then(function(){var a=n.get(r)["default"];a.systemjs&&(a=a.systemjs),a.modules&&(a.meta=a.modules,g.call(e,"Package config file "+r+\' is configured with "modules", which is deprecated as it has been renamed to "meta".\'));for(var o in a)-1==D.call(V,o)&&delete a[o];var i=e.packages[t]=e.packages[t]||{};if(h(i,a,!0),a.depCache){for(var s in a.depCache){var l;l="./"==s.substr(0,2)?t+"/"+s.substr(2):_.call(e,s),e.depCache[l]=(e.depCache[l]||[]).concat(a.depCache[s])}delete a.depCache}return"object"==typeof i.main&&(i.map=i.map||{},i.map["./@main"]=i.main,i.main["default"]=i.main["default"]||"./",i.main="@main"),i})}function p(e,t,r){var n;for(var a in e){var o="./"==a.substr(0,2)?"./":"";if(o&&(a=a.substr(2)),n=a.indexOf("*"),-1!==n&&a.substr(0,n)==t.substr(0,n)&&a.substr(n+1)==t.substr(t.length-a.length+n+1)&&r(a,e[o+a],a.split("/").length))return}var i=e[t]&&e.hasOwnProperty&&e.hasOwnProperty(t)?e[t]:e["./"+t];i&&r(i,i,0)}c(function(e){return function(){e.call(this),this.packages={},this.packageConfigPaths=[]}}),l.prototype.normalizeSync=l.prototype.decanonicalize=l.prototype.normalize,d("decanonicalize",function(t){return function(r,n){if(this.builder)return t.call(this,r,n,!0);var a=t.call(this,r,n);if(!this.defaultJSExtensions)return a;var o=e(this,a),i=this.packages[o],s=i&&i.defaultExtension;return void 0==s&&i&&i.meta&&p(i.meta,a.substr(o),function(e,t,r){return 0==r||e.lastIndexOf("*")!=e.length-1?(s=!1,!0):void 0}),(s===!1||s&&".js"!=s)&&".js"!=r.substr(r.length-3,3)&&".js"==a.substr(a.length-3,3)&&(a=a.substr(0,a.length-3)),a}}),d("normalizeSync",function(t){return function(n,o,i){g.call(this,"SystemJS.normalizeSync has been deprecated for SystemJS.decanonicalize.");var s=this;if(i=i===!0,o)var l=e(s,o)||s.defaultJSExtensions&&".js"==o.substr(o.length-3,3)&&e(s,o.substr(0,o.length-3));var u=l&&s.packages[l];if(u&&"."!=n[0]){var d=u.map,c=d&&b(d,n);if(c&&"string"==typeof d[c])return a(s,u,l,c,n,i)}var m=s.defaultJSExtensions&&".js"!=n.substr(n.length-3,3),p=t.call(s,n,o);m&&".js"!=p.substr(p.length-3,3)&&(m=!1),m&&(p=p.substr(0,p.length-3));var h=f(s,p),v=h&&h.packageName||e(s,p);if(!v)return p+(m?".js":"");var y=p.substr(v.length+1);return r(s,s.packages[v]||{},v,y,i)}}),d("normalize",function(t){return function(r,n,a){var i=this;return a=a===!0,Promise.resolve().then(function(){if(n)var t=e(i,n)||i.defaultJSExtensions&&".js"==n.substr(n.length-3,3)&&e(i,n.substr(0,n.length-3));var o=t&&i.packages[t];if(o&&"./"!=r.substr(0,2)){var l=o.map,u=l&&b(l,r);if(u)return s(i,o,t,u,r,a)}return Promise.resolve()}).then(function(s){if(s)return s;var l=i.defaultJSExtensions&&".js"!=r.substr(r.length-3,3),u=t.call(i,r,n);l&&".js"!=u.substr(u.length-3,3)&&(l=!1),l&&(u=u.substr(0,u.length-3));var d=f(i,u),c=d&&d.packageName||e(i,u);if(!c)return Promise.resolve(u+(l?".js":""));var p=i.packages[c],h=p&&(p.configured||!d);return(h?Promise.resolve(p):m(i,c,d.configPath)).then(function(e){\nvar t=u.substr(c.length+1);return o(i,e,c,t,a)})})}});var y={};d("locate",function(t){return function(r){var n=this;return Promise.resolve(t.call(this,r)).then(function(t){var a=e(n,r.name);if(a){var o=n.packages[a],i=r.name.substr(a.length+1);o.format&&(r.metadata.format=r.metadata.format||o.format);var s={};if(o.meta){var l=0;p(o.meta,i,function(e,t,r){r>l&&(l=r),h(s,t,r&&l>r)}),h(r.metadata,s)}}return t})}})}(),function(){function t(){if(i&&"interactive"===i.script.readyState)return i.load;for(var e=0;e<u.length;e++)if("interactive"==u[e].script.readyState)return i=u[e],i.load}function r(e,t){return new Promise(function(e,r){t.metadata.integrity&&r(new Error("Subresource integrity checking is not supported in web workers.")),s=t;try{importScripts(t.address)}catch(n){s=null,r(n)}s=null,t.metadata.entry||r(new Error(t.address+" did not call System.register or AMD define")),e("")})}if("undefined"!=typeof document)var n=document.getElementsByTagName("head")[0];var a,o,i,s=null,l=n&&function(){var e=document.createElement("script"),t="undefined"!=typeof opera&&"[object Opera]"===opera.toString();return e.attachEvent&&!(e.attachEvent.toString&&e.attachEvent.toString().indexOf("[native code")<0)&&!t}(),u=[],c=0,f=[];d("pushRegister_",function(e){return function(r){return e.call(this,r)?!1:(s?this.reduceRegister_(s,r):l?this.reduceRegister_(t(),r):c?f.push(r):this.reduceRegister_(null,r),!0)}}),d("fetch",function(t){return function(s){var d=this;return"json"!=s.metadata.format&&s.metadata.scriptLoad&&(L||I)?I?r(d,s):new Promise(function(t,r){function m(e){if(!g.readyState||"loaded"==g.readyState||"complete"==g.readyState){if(c--,s.metadata.entry||f.length){if(!l){for(var n=0;n<f.length;n++)d.reduceRegister_(s,f[n]);f=[]}}else d.reduceRegister_(s);h(),s.metadata.entry||s.metadata.bundle||r(new Error(s.name+" did not call System.register or AMD define. If loading a global module configure the global name via the meta exports property for script injection support.")),t("")}}function p(e){h(),r(new Error("Unable to load script "+s.address))}function h(){if(e.System=a,e.require=o,g.detachEvent){g.detachEvent("onreadystatechange",m);for(var t=0;t<u.length;t++)u[t].script==g&&(i&&i.script==g&&(i=null),u.splice(t,1))}else g.removeEventListener("load",m,!1),g.removeEventListener("error",p,!1);n.removeChild(g)}var g=document.createElement("script");g.async=!0,s.metadata.crossOrigin&&(g.crossOrigin=s.metadata.crossOrigin),s.metadata.integrity&&g.setAttribute("integrity",s.metadata.integrity),l?(g.attachEvent("onreadystatechange",m),u.push({script:g,load:s})):(g.addEventListener("load",m,!1),g.addEventListener("error",p,!1)),c++,a=e.System,o=e.require,g.src=s.address,n.appendChild(g)}):t.call(this,s)}})}();var ne=/^(\\s*\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*"[^"]+"\\s*;?|\\s*\'[^\']+\'\\s*;?)*\\s*/;!function(){function t(e,r,n){if(n[e.groupIndex]=n[e.groupIndex]||[],-1==D.call(n[e.groupIndex],e)){n[e.groupIndex].push(e);for(var a=0,o=e.normalizedDeps.length;o>a;a++){var i=e.normalizedDeps[a],s=r.defined[i];if(s&&!s.evaluated){var l=e.groupIndex+(s.declarative!=e.declarative);if(null===s.groupIndex||s.groupIndex<l){if(null!==s.groupIndex&&(n[s.groupIndex].splice(D.call(n[s.groupIndex],s),1),0==n[s.groupIndex].length))throw new Error("Mixed dependency cycle detected");s.groupIndex=l}t(s,r,n)}}}}function r(e,r){var n=r.defined[e];if(!n.module){n.groupIndex=0;var a=[];t(n,r,a);for(var o=!!n.declarative==a.length%2,s=a.length-1;s>=0;s--){for(var l=a[s],d=0;d<l.length;d++){var c=l[d];o?i(c,r):u(c,r)}o=!o}}}function a(){}function o(e,t){return t[e]||(t[e]={name:e,dependencies:[],exports:new a,importers:[]})}function i(t,r){if(!t.module){var n=r._loader.moduleRecords,a=t.module=o(t.name,n),s=t.module.exports,l=t.declare.call(e,function(e,t){if(a.locked=!0,"object"==typeof e)for(var r in e)s[r]=e[r];else s[e]=t;for(var n=0,o=a.importers.length;o>n;n++){var i=a.importers[n];if(!i.locked){var l=D.call(i.dependencies,a);i.setters[l](s)}}return a.locked=!1,t},{id:t.name});if(a.setters=l.setters,a.execute=l.execute,!a.setters||!a.execute)throw new TypeError("Invalid System.register form for "+t.name);for(var u=0,d=t.normalizedDeps.length;d>u;u++){var c,f=t.normalizedDeps[u],m=r.defined[f],p=n[f];p?c=p.exports:m&&!m.declarative?c=m.esModule:m?(i(m,r),p=m.module,c=p.exports):c=r.get(f),p&&p.importers?(p.importers.push(a),a.dependencies.push(p)):a.dependencies.push(null);for(var h=t.originalIndices[u],g=0,v=h.length;v>g;++g){var y=h[g];a.setters[y]&&a.setters[y](c)}}}}function s(e,t){var r,n=t.defined[e];if(n)n.declarative?p(e,[],t):n.evaluated||u(n,t),r=n.module.exports;else if(r=t.get(e),!r)throw new Error("Unable to load dependency "+e+".");return(!n||n.declarative)&&r&&r.__useDefault?r["default"]:r}function u(t,r){if(!t.module){var a={},o=t.module={exports:a,id:t.name};if(!t.executingRequire)for(var i=0,l=t.normalizedDeps.length;l>i;i++){var d=t.normalizedDeps[i],c=r.defined[d];c&&u(c,r)}t.evaluated=!0;var f=t.execute.call(e,function(e){for(var n=0,a=t.deps.length;a>n;n++)if(t.deps[n]==e)return s(t.normalizedDeps[n],r);var o=r.normalizeSync(e,t.name);if(-1!=D.call(t.normalizedDeps,o))return s(o,r);throw new Error("Module "+e+" not declared as a dependency of "+t.name)},a,o);f&&(o.exports=f),a=o.exports,a&&(a.__esModule||a instanceof n)?t.esModule=a:t.esmExports&&a!==e?t.esModule=m(a):t.esModule={"default":a}}}function p(t,r,n){var a=n.defined[t];if(a&&!a.evaluated&&a.declarative){r.push(t);for(var o=0,i=a.normalizedDeps.length;i>o;o++){var s=a.normalizedDeps[o];-1==D.call(r,s)&&(n.defined[s]?p(s,r,n):n.get(s))}a.evaluated||(a.evaluated=!0,a.module.execute.call(e))}}l.prototype.register=function(e,t,r){if("string"!=typeof e&&(r=t,t=e,e=null),"boolean"==typeof r)return this.registerDynamic.apply(this,arguments);var n=k();n.name=e&&(this.decanonicalize||this.normalize).call(this,e),n.declarative=!0,n.deps=t,n.declare=r,this.pushRegister_({amd:!1,entry:n})},l.prototype.registerDynamic=function(e,t,r,n){"string"!=typeof e&&(n=r,r=t,t=e,e=null);var a=k();a.name=e&&(this.decanonicalize||this.normalize).call(this,e),a.deps=t,a.execute=n,a.executingRequire=r,this.pushRegister_({amd:!1,entry:a})},d("reduceRegister_",function(){return function(e,t){if(t){var r=t.entry,n=e&&e.metadata;if(r.name&&(r.name in this.defined||(this.defined[r.name]=r),n&&(n.bundle=!0)),!r.name||e&&r.name==e.name){if(!n)throw new TypeError("Invalid System.register call. Anonymous System.register calls can only be made by modules loaded by SystemJS.import and not via script tags.");if(n.entry)throw"register"==n.format?new Error("Multiple anonymous System.register calls in module "+e.name+". If loading a bundle, ensure all the System.register calls are named."):new Error("Module "+e.name+" interpreted as "+n.format+" module format, but called System.register.");n.format||(n.format="register"),n.entry=r}}}}),c(function(e){return function(){e.call(this),this.defined={},this._loader.moduleRecords={}}}),F(a,"toString",{value:function(){return"Module"}}),d("delete",function(e){return function(t){return delete this._loader.moduleRecords[t],delete this.defined[t],e.call(this,t)}}),d("fetch",function(e){return function(t){return this.defined[t.name]?(t.metadata.format="defined",""):(t.metadata.deps=t.metadata.deps||[],e.call(this,t))}}),d("translate",function(e){return function(t){return t.metadata.deps=t.metadata.deps||[],Promise.resolve(e.call(this,t)).then(function(e){return("register"==t.metadata.format||!t.metadata.format&&j(t.source))&&(t.metadata.format="register"),e})}}),d("instantiate",function(e){return function(t){"detect"==t.metadata.format&&(t.metadata.format=void 0),e.call(this,t);var n,a=this;if(a.defined[t.name])n=a.defined[t.name],n.declarative||(n.deps=n.deps.concat(t.metadata.deps));else if(t.metadata.entry)n=t.metadata.entry,n.deps=n.deps.concat(t.metadata.deps);else if(!(a.builder&&t.metadata.bundle||"register"!=t.metadata.format&&"esm"!=t.metadata.format&&"es6"!=t.metadata.format)){if("undefined"!=typeof W&&W.call(a,t),!t.metadata.entry&&!t.metadata.bundle)throw new Error(t.name+" detected as "+t.metadata.format+" but didn\'t execute.");n=t.metadata.entry,n&&t.metadata.deps&&(n.deps=n.deps.concat(t.metadata.deps))}n||(n=k(),n.deps=t.metadata.deps,n.execute=function(){}),a.defined[t.name]=n;var o=f(n.deps);n.deps=o.names,n.originalIndices=o.indices,n.name=t.name,n.esmExports=t.metadata.esmExports!==!1;for(var i=[],s=0,l=n.deps.length;l>s;s++)i.push(Promise.resolve(a.normalize(n.deps[s],t.name)));return Promise.all(i).then(function(e){return n.normalizedDeps=e,{deps:n.deps,execute:function(){return r(t.name,a),p(t.name,[],a),a.defined[t.name]=void 0,a.newModule(n.declarative?n.module.exports:n.esModule)}}})}})}(),function(){var t=/(^\\s*|[}\\);\\n]\\s*)(import\\s*([\'"]|(\\*\\s+as\\s+)?[^"\'\\(\\)\\n;]+\\s*from\\s*[\'"]|\\{)|export\\s+\\*\\s+from\\s+["\']|export\\s*(\\{|default|function|class|var|const|let|async\\s+function))/,r=/\\$traceurRuntime\\s*\\./,n=/babelHelpers\\s*\\./;d("translate",function(a){return function(o){var i=this;return a.call(i,o).then(function(a){if("esm"==o.metadata.format||"es6"==o.metadata.format||!o.metadata.format&&a.match(t)){if("es6"==o.metadata.format&&g.call(i,"Module "+o.name+\' has metadata setting its format to "es6", which is deprecated.\\nThis should be updated to "esm".\'),o.metadata.format="esm",i.transpiler===!1){if(i.builder)return a;throw new TypeError("Unable to dynamically transpile ES module as SystemJS.transpiler set to false.")}return i._loader.loadedTranspiler=i._loader.loadedTranspiler||!1,i.pluginLoader&&(i.pluginLoader._loader.loadedTranspiler=i._loader.loadedTranspiler||!1),(i._loader.transpilerPromise||(i._loader.transpilerPromise=Promise.resolve(e["typescript"==i.transpiler?"ts":i.transpiler]||(i.pluginLoader||i)["import"](i.transpiler)))).then(function(e){return i._loader.loadedTranspilerRuntime=!0,e.translate?e==o.metadata.loaderModule?o.source:("string"==typeof o.metadata.sourceMap&&(o.metadata.sourceMap=JSON.parse(o.metadata.sourceMap)),Promise.resolve(e.translate.call(i,o)).then(function(e){var t=o.metadata.sourceMap;if(t&&"object"==typeof t){var r=o.name.split("!")[0];t.file=r+"!transpiled",(!t.sources||t.sources.length<=1)&&(t.sources=[r])}return"esm"==o.metadata.format&&!i.builder&&j(e)&&(o.metadata.format="register"),e})):(i.builder&&(o.metadata.originalSource=o.source),X.call(i,o).then(function(e){return o.metadata.sourceMap=void 0,e}))})}if(i.transpiler===!1)return a;if(i._loader.loadedTranspiler!==!1||"traceur"!=i.transpiler&&"typescript"!=i.transpiler&&"babel"!=i.transpiler||o.name!=i.normalizeSync(i.transpiler)||(a.length>100&&!o.metadata.format&&(o.metadata.format="global","traceur"===i.transpiler&&(o.metadata.exports="traceur"),"typescript"===i.transpiler&&(o.metadata.exports="ts")),i._loader.loadedTranspiler=!0),i._loader.loadedTranspilerRuntime===!1&&(o.name==i.normalizeSync("traceur-runtime")||o.name==i.normalizeSync("babel/external-helpers*"))&&(a.length>100&&(o.metadata.format=o.metadata.format||"global"),i._loader.loadedTranspilerRuntime=!0),("register"==o.metadata.format||o.metadata.bundle)&&i._loader.loadedTranspilerRuntime!==!0){if(!e.$traceurRuntime&&o.source.match(r))return i._loader.loadedTranspilerRuntime=i._loader.loadedTranspilerRuntime||!1,i["import"]("traceur-runtime").then(function(){return a});if(!e.babelHelpers&&o.source.match(n))return i._loader.loadedTranspilerRuntime=i._loader.loadedTranspilerRuntime||!1,i["import"]("babel/external-helpers").then(function(){return a})}return a})}})}();var ae="undefined"!=typeof self?"self":"global";d("fetch",function(e){return function(t){return t.metadata.exports&&!t.metadata.format&&(t.metadata.format="global"),e.call(this,t)}}),d("instantiate",function(e){return function(t){var r=this;if(t.metadata.format||(t.metadata.format="global"),"global"==t.metadata.format&&!t.metadata.registered){var n=k();t.metadata.entry=n,n.deps=[];for(var a in t.metadata.globals){var o=t.metadata.globals[a];o&&n.deps.push(o)}n.execute=function(e,n,a){var o;if(t.metadata.globals){o={};for(var i in t.metadata.globals)t.metadata.globals[i]&&(o[i]=e(t.metadata.globals[i]))}var s=t.metadata.exports;s&&(t.source+="\\n"+ae+\'["\'+s+\'"] = \'+s+";");var l=r.get("@@global-helpers").prepareGlobal(a.id,s,o);return W.call(r,t),l()}}return e.call(this,t)}}),d("reduceRegister_",function(e){return function(t,r){if(r||!t.metadata.exports)return e.call(this,t,r);t.metadata.format="global";var n=t.metadata.entry=k();n.deps=t.metadata.deps;var a=P(t.metadata.exports);n.execute=function(){return a}}}),c(function(t){return function(){function r(t){if(Object.keys)Object.keys(e).forEach(t);else for(var r in e)i.call(e,r)&&t(r)}function n(t){r(function(r){if(-1==D.call(s,r)){try{var n=e[r]}catch(a){s.push(r)}t(r,n)}})}var a=this;t.call(a);var o,i=Object.prototype.hasOwnProperty,s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];a.set("@@global-helpers",a.newModule({prepareGlobal:function(t,r,a){var i=e.define;e.define=void 0;var s;if(a){s={};for(var l in a)s[l]=e[l],e[l]=a[l]}return r||(o={},n(function(e,t){o[e]=t})),function(){var t;if(r)t=P(r);else{t={};var a,l;n(function(e,r){o[e]!==r&&"undefined"!=typeof r&&(t[e]=r,"undefined"!=typeof a?l||a===r||(l=!0):a=r)}),t=l?t:a}if(s)for(var u in s)e[u]=s[u];return e.define=i,t}}}))}}),function(){function t(e){function t(e,t){for(var r=0;r<e.length;r++)if(e[r][0]<t.index&&e[r][1]>t.index)return!0;return!1}n.lastIndex=a.lastIndex=o.lastIndex=0;var r,i=[],s=[],l=[];if(e.length/e.split("\\n").length<200){for(;r=o.exec(e);)s.push([r.index,r.index+r[0].length]);for(;r=a.exec(e);)t(s,r)||l.push([r.index,r.index+r[0].length])}for(;r=n.exec(e);)if(!t(s,r)&&!t(l,r)){var u=r[1].substr(1,r[1].length-2);if(u.match(/"|\'/))continue;"/"==u[u.length-1]&&(u=u.substr(0,u.length-1)),i.push(u)}return i}var r=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])(exports\\s*(\\[[\'"]|\\.)|module(\\.exports|\\[\'exports\'\\]|\\["exports"\\])\\s*(\\[[\'"]|[=,\\.]))/,n=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF."\'])require\\s*\\(\\s*("[^"\\\\]*(?:\\\\.[^"\\\\]*)*"|\'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\')\\s*\\)/g,a=/(^|[^\\\\])(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/gm,o=/("[^"\\\\\\n\\r]*(\\\\.[^"\\\\\\n\\r]*)*"|\'[^\'\\\\\\n\\r]*(\\\\.[^\'\\\\\\n\\r]*)*\')/g,i=/^\\#\\!.*/;d("instantiate",function(a){return function(o){var s=this;if(o.metadata.format||(r.lastIndex=0,n.lastIndex=0,(n.exec(o.source)||r.exec(o.source))&&(o.metadata.format="cjs")),"cjs"==o.metadata.format){var l=o.metadata.deps,u=o.metadata.cjsRequireDetection===!1?[]:t(o.source);for(var d in o.metadata.globals)o.metadata.globals[d]&&u.push(o.metadata.globals[d]);var c=k();o.metadata.entry=c,c.deps=u,c.executingRequire=!0,c.execute=function(t,r,n){function a(e){return"/"==e[e.length-1]&&(e=e.substr(0,e.length-1)),t.apply(this,arguments)}if(a.resolve=function(e){return s.get("@@cjs-helpers").requireResolve(e,n.id)},!o.metadata.cjsDeferDepsExecute)for(var u=0;u<l.length;u++)a(l[u]);var d=s.get("@@cjs-helpers").getPathVars(n.id),c={exports:r,args:[a,r,n,d.filename,d.dirname,e,e]},f="(function(require, exports, module, __filename, __dirname, global, GLOBAL";if(o.metadata.globals)for(var m in o.metadata.globals)c.args.push(a(o.metadata.globals[m])),f+=", "+m;var p=e.define;e.define=void 0,e.__cjsWrapper=c,o.source=f+") {"+o.source.replace(i,"")+"\\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);",W.call(s,o),e.__cjsWrapper=void 0,e.define=p}}return a.call(s,o)}})}(),c(function(e){return function(){function t(e){return"file:///"==e.substr(0,8)?e.substr(7+!!A):n&&e.substr(0,n.length)==n?e.substr(n.length):e}var r=this;if(e.call(r),"undefined"!=typeof window&&"undefined"!=typeof document&&window.location)var n=location.protocol+"//"+location.hostname+(location.port?":"+location.port:"");r.set("@@cjs-helpers",r.newModule({requireResolve:function(e,n){return t(r.normalizeSync(e,n))},getPathVars:function(e){var r,n=e.lastIndexOf("!");r=-1!=n?e.substr(0,n):e;var a=r.split("/");return a.pop(),a=a.join("/"),{filename:t(r),dirname:t(a)}}}))}}),d("fetch",function(t){return function(r){return r.metadata.scriptLoad&&L&&(e.define=this.amdDefine),t.call(this,r)}}),c(function(t){return function(){function r(e,t){e=e.replace(i,"");var r=e.match(u),n=(r[1].split(",")[t]||"require").replace(c,""),a=f[n]||(f[n]=new RegExp(s+n+l,"g"));a.lastIndex=0;for(var o,d=[];o=a.exec(e);)d.push(o[2]||o[3]);return d}function n(e,t,r,a){if("object"==typeof e&&!(e instanceof Array))return n.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof t&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var i=o.defaultJSExtensions&&".js"!=e.substr(e.length-3,3),s=o.decanonicalize(e,a);i&&".js"==s.substr(s.length-3,3)&&(s=s.substr(0,s.length-3));var l=o.get(s);if(!l)throw new Error(\'Module not already loaded loading "\'+e+\'" as \'+s+(a?\' from "\'+a+\'".\':"."));return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var u=[],d=0;d<e.length;d++)u.push(o["import"](e[d],a));Promise.all(u).then(function(e){t&&t.apply(null,e)},r)}function a(t,a,i){function s(t,r,s){function c(e,r,a){return"string"==typeof e&&"function"!=typeof r?t(e):n.call(o,e,r,a,s.id)}for(var f=[],m=0;m<a.length;m++)f.push(t(a[m]));s.uri=s.id,s.config=function(){},-1!=d&&f.splice(d,0,s),-1!=u&&f.splice(u,0,r),-1!=l&&(c.toUrl=function(e){var t=o.defaultJSExtensions&&".js"!=e.substr(e.length-3,3),r=o.decanonicalize(e,s.id);return t&&".js"==r.substr(r.length-3,3)&&(r=r.substr(0,r.length-3)),r},f.splice(l,0,c));var p=e.require;e.require=n;var h=i.apply(-1==u?e:r,f);return e.require=p,"undefined"==typeof h&&s&&(h=s.exports),"undefined"!=typeof h?h:void 0}"string"!=typeof t&&(i=a,a=t,t=null),a instanceof Array||(i=a,a=["require","exports","module"].splice(0,i.length)),"function"!=typeof i&&(i=function(e){return function(){return e}}(i)),void 0===a[a.length-1]&&a.pop();var l,u,d;-1!=(l=D.call(a,"require"))&&(a.splice(l,1),t||(a=a.concat(r(i.toString(),l)))),-1!=(u=D.call(a,"exports"))&&a.splice(u,1),-1!=(d=D.call(a,"module"))&&a.splice(d,1);var c=k();c.name=t&&(o.decanonicalize||o.normalize).call(o,t),c.deps=a,c.execute=s,o.pushRegister_({amd:!0,entry:c})}var o=this;t.call(this);var i=/(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/gm,s="(?:^|[^$_a-zA-Z\\\\xA0-\\\\uFFFF.])",l="\\\\s*\\\\(\\\\s*(\\"([^\\"]+)\\"|\'([^\']+)\')\\\\s*\\\\)",u=/\\(([^\\)]*)\\)/,c=/^\\s+|\\s+$/g,f={};a.amd={},d("reduceRegister_",function(e){return function(t,r){if(!r||!r.amd)return e.call(this,t,r);var n=t&&t.metadata,a=r.entry;if(n&&(n.format="amd"),a.name)n&&(n.entry||n.bundle?n.entry&&n.entry.name&&(n.entry=void 0):n.entry=a,n.bundle=!0),a.name in this.defined||(this.defined[a.name]=a);else{if(!n)throw new TypeError("Unexpected anonymous AMD define.");if(n.entry&&!n.entry.name)throw new Error("Multiple anonymous defines in module "+t.name);n.entry=a}}}),o.amdDefine=a,o.amdRequire=n}}),function(){var t=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])define\\s*\\(\\s*("[^"]+"\\s*,\\s*|\'[^\']+\'\\s*,\\s*)?\\s*(\\[(\\s*(("[^"]+"|\'[^\']+\')\\s*,|\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*(\\s*("[^"]+"|\'[^\']+\')\\s*,?)?(\\s*(\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*\\s*\\]|function\\s*|{|[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*\\))/;d("instantiate",function(r){return function(n){var a=this;if("amd"==n.metadata.format||!n.metadata.format&&n.source.match(t))if(n.metadata.format="amd",a.builder||a.execute===!1)n.metadata.execute=function(){return n.metadata.builderExecute.apply(this,arguments)};else{var o=e.define;e.define=this.amdDefine;try{W.call(a,n)}finally{e.define=o}if(!n.metadata.entry&&!n.metadata.bundle)throw new TypeError("AMD module "+n.name+" did not define")}return r.call(a,n)}})}(),function(){function e(e,t){if(t){var r;if(e.pluginFirst){if(-1!=(r=t.lastIndexOf("!")))return t.substr(r+1)}else if(-1!=(r=t.indexOf("!")))return t.substr(0,r);return t}}function t(e,t){var r,n,a=t.lastIndexOf("!");return-1!=a?(e.pluginFirst?(r=t.substr(a+1),n=t.substr(0,a)):(r=t.substr(0,a),n=t.substr(a+1)||r.substr(r.lastIndexOf(".")+1)),{argument:r,plugin:n}):void 0}function r(e,t,r,n){return n&&".js"==t.substr(t.length-3,3)&&(t=t.substr(0,t.length-3)),e.pluginFirst?r+"!"+t:t+"!"+r}function n(e,t){return e.defaultJSExtensions&&".js"!=t.substr(t.length-3,3)}function a(a){return function(o,i,s){var l=this;i=e(this,i);var u=t(l,o);if(!u)return a.call(this,o,i,s);var d=l.normalizeSync(u.argument,i,!0),c=l.normalizeSync(u.plugin,i,!0);return r(l,d,c,n(l,u.argument))}}d("decanonicalize",a),d("normalizeSync",a),d("normalize",function(a){return function(o,i,s){var l=this;i=e(this,i);var u=t(l,o);return u?Promise.all([l.normalize(u.argument,i,!0),l.normalize(u.plugin,i)]).then(function(e){return r(l,e[0],e[1],n(l,u.argument))}):a.call(l,o,i,s)}}),d("locate",function(e){return function(t){var r,n=this,a=t.name;return n.pluginFirst?-1!=(r=a.indexOf("!"))&&(t.metadata.loader=a.substr(0,r),t.name=a.substr(r+1)):-1!=(r=a.lastIndexOf("!"))&&(t.metadata.loader=a.substr(r+1),t.name=a.substr(0,r)),e.call(n,t).then(function(e){return-1==r&&t.metadata.loader?n.normalize(t.metadata.loader,t.name).then(function(r){return t.metadata.loader=r,e}):e}).then(function(e){var r=t.metadata.loader;if(!r)return e;if(t.name==r)throw new Error("Plugin "+r+" cannot load itself, make sure it is excluded from any wildcard meta configuration via a custom loader: false rule.");if(n.defined&&n.defined[a])return e;var o=n.pluginLoader||n;return o["import"](r).then(function(r){return t.metadata.loaderModule=r,t.address=e,r.locate?r.locate.call(n,t):e})})}}),d("fetch",function(e){return function(t){var r=this;return t.metadata.loaderModule&&t.metadata.loaderModule.fetch&&"defined"!=t.metadata.format?(t.metadata.scriptLoad=!1,t.metadata.loaderModule.fetch.call(r,t,function(t){return e.call(r,t)})):e.call(r,t)}}),d("translate",function(e){return function(t){var r=this;return t.metadata.loaderModule&&t.metadata.loaderModule.translate&&"defined"!=t.metadata.format?Promise.resolve(t.metadata.loaderModule.translate.call(r,t)).then(function(n){var a=t.metadata.sourceMap;if(a){if("object"!=typeof a)throw new Error("load.metadata.sourceMap must be set to an object.");var o=t.name.split("!")[0];a.file=o+"!transpiled",(!a.sources||a.sources.length<=1)&&(a.sources=[o])}return"string"==typeof n?t.source=n:g.call(this,"Plugin "+t.metadata.loader+" should return the source in translate, instead of setting load.source directly. This support will be deprecated."),e.call(r,t)}):e.call(r,t)}}),d("instantiate",function(e){return function(t){var r=this,n=!1;return t.metadata.loaderModule&&t.metadata.loaderModule.instantiate&&!r.builder&&"defined"!=t.metadata.format?Promise.resolve(t.metadata.loaderModule.instantiate.call(r,t,function(t){if(n)throw new Error("Instantiate must only be called once.");return n=!0,e.call(r,t)})).then(function(a){return n?a:(t.metadata.entry=k(),t.metadata.entry.execute=function(){return a},t.metadata.entry.deps=t.metadata.deps,t.metadata.format="defined",e.call(r,t))}):e.call(r,t)}})}();var oe=/#\\{[^\\}]+\\}/;d("normalize",function(e){return function(t,r,n){var a=this;return T.call(a,t,r).then(function(t){return e.call(a,t,r,n)}).then(function(e){return z.call(a,e,r)})}}),function(){d("fetch",function(e){return function(t){var r=t.metadata.alias,n=t.metadata.deps||[];if(r){t.metadata.format="defined";var a=k();return this.defined[t.name]=a,a.declarative=!0,a.deps=n.concat([r]),a.declare=function(e){return{setters:[function(t){for(var r in t)e(r,t[r]);t.__useDefault&&(a.module.exports.__useDefault=!0)}],execute:function(){}}},""}return e.call(this,t)}})}(),function(){function e(e,t,r){for(var n,a=t.split(".");a.length>1;)n=a.shift(),e=e[n]=e[n]||{};n=a.shift(),n in e||(e[n]=r)}c(function(e){return function(){this.meta={},e.call(this)}}),d("locate",function(e){return function(t){var r,n=this.meta,a=t.name,o=0;for(var i in n)if(r=i.indexOf("*"),-1!==r&&i.substr(0,r)===a.substr(0,r)&&i.substr(r+1)===a.substr(a.length-i.length+r+1)){var s=i.split("/").length;s>o&&(o=s),h(t.metadata,n[i],o!=s)}return n[a]&&h(t.metadata,n[a]),e.call(this,t)}});var t=/^(\\s*\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*"[^"]+"\\s*;?|\\s*\'[^\']+\'\\s*;?)+/,r=/\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\/\\/[^\\n]*|"[^"]+"\\s*;?|\'[^\']+\'\\s*;?/g;d("translate",function(n){return function(a){var o=a.source.match(t);if(o)for(var i=o[0].match(r),s=0;s<i.length;s++){var l=i[s],u=l.length,d=l.substr(0,1);if(";"==l.substr(u-1,1)&&u--,\'"\'==d||"\'"==d){var c=l.substr(1,l.length-3),f=c.substr(0,c.indexOf(" "));if(f){var m=c.substr(f.length+1,c.length-f.length-1);"[]"==f.substr(f.length-2,2)?(f=f.substr(0,f.length-2),a.metadata[f]=a.metadata[f]||[],a.metadata[f].push(m)):a.metadata[f]instanceof Array?(g.call(this,"Module "+a.name+\' contains deprecated "deps \'+m+\'" meta syntax.\\nThis should be updated to "deps[] \'+m+\'" for pushing to array meta.\'),a.metadata[f].push(m)):e(a.metadata,f,m)}else a.metadata[c]=!0}}return n.call(this,a)}})}(),function(){c(function(e){return function(){e.call(this),this.bundles={},this._loader.loadedBundles={}}}),d("locate",function(e){return function(t){var r=this,n=!1;if(!(t.name in r.defined))for(var a in r.bundles){for(var o=0;o<r.bundles[a].length;o++){var i=r.bundles[a][o];if(i==t.name){n=!0;break}if(-1!=i.indexOf("*")){var s=i.split("*");if(2!=s.length){r.bundles[a].splice(o--,1);continue}if(t.name.substring(0,s[0].length)==s[0]&&t.name.substr(t.name.length-s[1].length,s[1].length)==s[1]&&-1==t.name.substr(s[0].length,t.name.length-s[1].length-s[0].length).indexOf("/")){n=!0;break}}}if(n)return r["import"](a).then(function(){return e.call(r,t)})}return e.call(r,t)}})}(),function(){c(function(e){return function(){e.call(this),this.depCache={}}}),d("locate",function(e){return function(t){var r=this,n=r.depCache[t.name];if(n)for(var a=0;a<n.length;a++)r["import"](n[a],t.name);return e.call(r,t)}})}(),$=new l,e.SystemJS=$,$.version="0.19.25 Standard","object"==typeof exports&&(module.exports=a),e.Reflect=e.Reflect||{},e.Reflect.Loader=e.Reflect.Loader||a,e.Reflect.global=e.Reflect.global||e,e.LoaderPolyfill=a,$||($=new o,$.constructor=o),"object"==typeof exports&&(module.exports=$),e.System=$}("undefined"!=typeof self?self:global)}var t="undefined"==typeof Promise;if("undefined"!=typeof document){var r=document.getElementsByTagName("script");if($__curScript=r[r.length-1],t){var n=$__curScript.src,a=n.substr(0,n.lastIndexOf("/")+1);window.systemJSBootstrap=e,document.write(\'<script type="text/javascript" src="\'+a+\'system-polyfills.js"></script>\')}else e()}else if("undefined"!=typeof importScripts){var a="";try{throw new Error("_")}catch(o){o.stack.replace(/(?:at|@).*(http.+):[\\d]+:[\\d]+/,function(e,t){$__curScript={src:t},a=t.replace(/\\/[^\\/]*$/,"/")})}t&&importScripts(a+"system-polyfills.js"),e()}else $__curScript="undefined"!=typeof __filename?{src:__filename}:null,e()}();\n');
	}.call(exports, (function() { return this; }())))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @Copyright (c) Microsoft Corporation.  All rights reserved.
	 *
	 * @file ManifestStore.ts
	 */
	"use strict";
	var SPModuleLoader_1 = __webpack_require__(9);
	/**
	 * This class maintains a cache of the manifests on the current page.
	 */
	var ManifestStore = (function () {
	    function ManifestStore() {
	        this._manifests = new Map();
	    }
	    Object.defineProperty(ManifestStore, "instance", {
	        get: function () {
	            if (!this._instance) {
	                this._instance = new ManifestStore();
	            }
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Populate the manifest store with the preloaded manifests.
	     *
	     * @param {preloadedData} The preloaded data
	     */
	    ManifestStore.prototype.populateManifests = function (preloadedData) {
	        if (preloadedData) {
	            if (preloadedData.clientSideApplicationManifest) {
	                this._addManifest(preloadedData.clientSideApplicationManifest, true);
	            }
	            if (preloadedData.manifests && preloadedData.manifests.length) {
	                this.importManifests(preloadedData.manifests, true);
	            }
	        }
	        /* tslint:disable:no-any */
	        var globalManifests = window.g_webPartManifests;
	        /* tslint:enable:no-any */
	        if (globalManifests && globalManifests.length) {
	            this.importManifests(globalManifests, true);
	        }
	    };
	    /**
	     * Populate the manifest store with debug manifests.
	     *
	     * @param {manifests} A dictionary of debug manifests.
	     */
	    ManifestStore.prototype.populateDebugManifests = function (manifests) {
	        if (manifests) {
	            /* tslint:disable:forin */
	            for (var id in manifests) {
	                /* tslint:enable:forin */
	                if (!this._manifests.get(id)) {
	                    this._manifests.set(id, {
	                        id: id,
	                        manifest: undefined
	                    });
	                }
	                this._manifests.get(id).debugManifest = manifests[id];
	            }
	        }
	    };
	    /**
	     * Return a manifest by its ID. Only return a debug manifest is debug is allowed. If a manifest isn't found by
	     * the provided ID, return undefined.
	     *
	     * @param {id} The ID of the manifest to retrieve.
	     * @param {allowDebug} If true, return a debug manifest if one exists.
	     * @returns The retrieved manifest, or undefined if one could not be found.
	     */
	    ManifestStore.prototype.getManifestById = function (id) {
	        var manifestEntry = this._manifests.get(id);
	        return this._getManifestFromStoreEntry(manifestEntry);
	    };
	    /**
	     * Get all registered manifest objects.
	     *
	     * @returns The registered manifest objects.
	     */
	    ManifestStore.prototype.getAllManifests = function () {
	        var _this = this;
	        var result = [];
	        this._manifests.forEach(function (manifestEntry) {
	            var manifest = _this._getManifestFromStoreEntry(manifestEntry);
	            if (manifest) {
	                result.push(manifest);
	            }
	        });
	        return result;
	    };
	    /**
	     * Returns a map of manifest IDs to manfiests.
	     *
	     * @return {{ [key: string]: IManifestStoreEntry }}: A map of manifest IDs to manfiests.
	     */
	    ManifestStore.prototype.getManifestMap = function () {
	        var result = {};
	        this._manifests.forEach(function (value, key) { return result[key] = value; });
	        return result;
	    };
	    /**
	     * Loads additional manifests into the manifest store, updating existing manifests.
	     *
	     * @param {manifests} The manifests to load into the store.
	     */
	    ManifestStore.prototype.importManifests = function (manifests, overwriteExisting) {
	        var _this = this;
	        manifests.forEach(function (manifest) { return _this._addManifest(manifest, overwriteExisting); });
	    };
	    ManifestStore.prototype._getManifestFromStoreEntry = function (manifestEntry) {
	        var allowDebug = SPModuleLoader_1.ensureDebugAllowed(false);
	        if (manifestEntry) {
	            if (allowDebug && manifestEntry.debugManifest) {
	                return manifestEntry.debugManifest;
	            }
	            else {
	                return manifestEntry.manifest;
	            }
	        }
	        else {
	            return undefined;
	        }
	    };
	    ManifestStore.prototype._addManifest = function (manifest, overwriteExisting) {
	        var v1Manifest = manifest;
	        var v2Manifest = manifest;
	        var manifestEntry = { id: manifest.id, manifest: v2Manifest };
	        if (v1Manifest.properties && v1Manifest.properties.manifest) {
	            // Looks like we're in a v1.5 manifest
	            if (typeof v1Manifest.properties.manifest === 'string') {
	                manifestEntry.manifest = JSON.parse(v1Manifest.properties.manifest);
	            }
	            else {
	                manifestEntry.manifest = v1Manifest.properties.manifest;
	            }
	        }
	        var existingEntry = this._manifests.get(manifest.id);
	        if (existingEntry) {
	            if (overwriteExisting || !existingEntry.manifest) {
	                existingEntry.manifest = manifestEntry.manifest;
	            }
	        }
	        else {
	            this._manifests.set(manifest.id, manifestEntry);
	        }
	    };
	    return ManifestStore;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ManifestStore;
	


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @Copyright (c) Microsoft Corporation.  All rights reserved.
	 *
	 * @file DebugManifestProvider.ts
	 */
	"use strict";
	var SystemJsWrapper_1 = __webpack_require__(46);
	var SPModuleLoader_1 = __webpack_require__(9);
	var debugManifestsQueryParameterName = 'debugManifests';
	var debugManifestsFileQueryParameterName = 'debugManifestsFile';
	var sessionStorageKey = 'sp-module-loader_debugManifests';
	/**
	 * This class assists with parsing debug manifests from the URL fragment or from sessionStorage.
	 *
	 * --- NEW APPROACH ---
	 * We allow developers to specify a set of manifests in the URL to override the manifests we get from the server.
	 * The format is: <url-to-page>.aspx#debugManifestsFile=<path to manfiests init script>
	 *
	 * When a manifest file is specified in the URL, we cache its contents in sessionStorage so the developer doesn't need
	 * to supply it on every request. This class also reads the "reset=1" query parameter to clear the cached debug
	 * manifests from sessionStorage.
	 *
	 * --- OLD APPROACH ---
	 * We allow developers to specify a set of manifests in the URL to override the manifests we get from the server.
	 * The format is: <url-to-page>.aspx#debugManifests=<URL-encoded JSON object>
	 * And the format of the JSON object is:
	 *  {
	 *    "manifest-id-1": { <manifest object> },
	 *    "manifest-id-2": { <manifest object> }
	 *  }
	 *
	 * When a manifest is specified in the URL, we cache it in sessionStorage so the developer doesn't need to
	 * supply it on every request. This class also reads the "reset=1" query parameter to clear the cached debug
	 * manifests from sessionStorage.
	 *
	 * This is a temporary implementation until we update the build tools to support a more developer-friendly approach.
	 * VSO#201640.
	 */
	var DebugManifestProvider = (function () {
	    function DebugManifestProvider() {
	    }
	    Object.defineProperty(DebugManifestProvider, "instance", {
	        get: function () {
	            if (!this._instance) {
	                this._instance = new DebugManifestProvider();
	            }
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DebugManifestProvider.prototype.getDebugManifests = function (noCache, alternativeManifestsFile) {
	        var _this = this;
	        if (noCache === void 0) { noCache = false; }
	        return new Promise(function (resolve) {
	            var localDebugManifests = _this._parseManifestsFromFragementQueryParameter();
	            if (window.location.search.match(/\breset\b/)) {
	                try {
	                    window.sessionStorage.removeItem(sessionStorageKey);
	                }
	                catch (e) {
	                    /* tslint:disable:no-console */
	                    console.debug("Error clearing session storage. Error: " + e);
	                }
	                resolve({});
	            }
	            else {
	                var existingManifests_1 = {};
	                try {
	                    existingManifests_1 = JSON.parse(window.sessionStorage.getItem(sessionStorageKey)) || {};
	                }
	                catch (e) {
	                    /* tslint:disable:no-console */
	                    console.debug("Error querying session storage. Error: " + e);
	                }
	                Object.keys(existingManifests_1).forEach(function (existingManifestKey) {
	                    if (!localDebugManifests[existingManifestKey]) {
	                        localDebugManifests[existingManifestKey] = existingManifests_1[existingManifestKey];
	                    }
	                });
	                var manifestsFile = _this._parseManifestsFileFromFragementQueryParameter(false) ||
	                    alternativeManifestsFile;
	                if (manifestsFile && SPModuleLoader_1.ensureDebugAllowed()) {
	                    SystemJsWrapper_1.default.instance.loadScript(manifestsFile, 'debugManifests')
	                        .then(function (manifestsScript) {
	                        _this._parseManifestsFileFromFragementQueryParameter(true); // Clear the parameter only if file loaded
	                        var manifests = manifestsScript.getManifests();
	                        manifests.forEach(function (manifest) {
	                            localDebugManifests[manifest.id] = manifest;
	                        });
	                        if (!noCache) {
	                            _this._trySetSessionStorageManifests(localDebugManifests);
	                        }
	                        resolve(localDebugManifests);
	                    }, function (error) {
	                        alert(("Error loading debug manifest script. (" + (error.message ? error.message : error) + ") \n\n") +
	                            'Ensure loading unsafe scripts is allowed.');
	                    });
	                }
	                else {
	                    if (!noCache) {
	                        _this._trySetSessionStorageManifests(localDebugManifests);
	                    }
	                    resolve(localDebugManifests);
	                }
	            }
	        });
	    };
	    DebugManifestProvider.prototype._trySetSessionStorageManifests = function (localDebugManifests) {
	        try {
	            window.sessionStorage.setItem(sessionStorageKey, JSON.stringify(localDebugManifests));
	        }
	        catch (e) {
	            /* tslint:disable:no-console */
	            console.debug("Error setting session storage. Error: " + e);
	        }
	    };
	    DebugManifestProvider.prototype._parseManifestsFileFromFragementQueryParameter = function (clearParamter) {
	        return this._getAndClearFragmentQueryParameter(debugManifestsFileQueryParameterName, clearParamter);
	    };
	    DebugManifestProvider.prototype._parseManifestsFromFragementQueryParameter = function () {
	        var debugManifestsString = this._getAndClearFragmentQueryParameter(debugManifestsQueryParameterName);
	        if (debugManifestsString) {
	            try {
	                return JSON.parse(debugManifestsString);
	            }
	            catch (e) {
	                /* tslint:disable:no-console */
	                console.debug("Error parsing manifests query parameter. Error: " + e);
	            }
	        }
	        else {
	            return {};
	        }
	    };
	    DebugManifestProvider.prototype._getAndClearFragmentQueryParameter = function (parameter, clearParamter) {
	        if (clearParamter === void 0) { clearParamter = true; }
	        var result = undefined;
	        if (window.location.hash) {
	            var fragment = window.location.hash.indexOf('#') === 0
	                ? window.location.hash.substr(1)
	                : window.location.hash;
	            var fragmentQueryParameters = this._parseQueryParameters(fragment);
	            if (fragmentQueryParameters &&
	                fragmentQueryParameters[parameter]) {
	                result = decodeURIComponent(fragmentQueryParameters[parameter]);
	                if (clearParamter) {
	                    // Re-generate the fragment without the parameter.
	                    var newFragment = fragment.replace(parameter + "=" + fragmentQueryParameters[parameter], '');
	                    if (newFragment !== '') {
	                        window.history.replaceState('', document.title, "" + window.location.pathname + window.location.search + "#" + newFragment);
	                    }
	                    else {
	                        window.history.replaceState('', document.title, "" + window.location.pathname + window.location.search);
	                    }
	                }
	            }
	        }
	        return result;
	    };
	    /**
	     * Parse a string as querystring parameters. VSO:201753 to replace with standard library.
	     */
	    DebugManifestProvider.prototype._parseQueryParameters = function (queryParameterString) {
	        if (queryParameterString) {
	            if (queryParameterString.indexOf('?') === 0) {
	                queryParameterString = queryParameterString.substr(1);
	            }
	            var queryParameters = queryParameterString.split('&');
	            var result_1 = {};
	            queryParameters.forEach(function (queryParameter) {
	                var equalsIndex = queryParameter.indexOf('=');
	                if (equalsIndex === -1) {
	                    result_1[queryParameter] = '';
	                }
	                else {
	                    result_1[queryParameter.substr(0, equalsIndex)] = queryParameter.substr(equalsIndex + 1);
	                }
	            });
	            return result_1;
	        }
	        else {
	            return undefined;
	        }
	    };
	    return DebugManifestProvider;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DebugManifestProvider;
	


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "wtcy4av_77c45200fc771786.mp3";

/***/ },
/* 52 */
/***/ function(module, exports) {

	// Empty implementation of React 
	


/***/ },
/* 53 */
/***/ function(module, exports) {

	// Empty implementation of Flux 
	


/***/ },
/* 54 */
/***/ function(module, exports) {

	// Empty implementation of React-DOM 
	


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var punycode = __webpack_require__(56);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(57);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	
	function isString(arg) {
	  return typeof arg === "string";
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module), (function() { return this; }())))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(58);
	exports.encode = exports.stringify = __webpack_require__(59);


/***/ },
/* 58 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 59 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ }
/******/ ]);
//# sourceMappingURL=sp-module-loader.js.map
(function(){
if (!window.__setWebpackPublicPathLoaderSrcRegistry__) window.__setWebpackPublicPathLoaderSrcRegistry__={};
var scripts = document.getElementsByTagName('script');
if (scripts && scripts.length) {
  for (var i = 0; i < scripts.length; i++) {
    if (!scripts[i]) continue;
    var path = scripts[i].getAttribute('src');
    if (path) window.__setWebpackPublicPathLoaderSrcRegistry__[path]=true;
  }
}
})();