/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file ManifestStore.ts
 */
"use strict";
var SPModuleLoader_1 = require('./SPModuleLoader');
/**
 * This class maintains a cache of the manifests on the current page.
 */
var ManifestStore = (function () {
    function ManifestStore() {
        this._manifests = new Map();
    }
    Object.defineProperty(ManifestStore, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new ManifestStore();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Populate the manifest store with the preloaded manifests.
     *
     * @param {preloadedData} The preloaded data
     */
    ManifestStore.prototype.populateManifests = function (preloadedData) {
        if (preloadedData) {
            if (preloadedData.clientSideApplicationManifest) {
                this._addManifest(preloadedData.clientSideApplicationManifest, true);
            }
            if (preloadedData.manifests && preloadedData.manifests.length) {
                this.importManifests(preloadedData.manifests, true);
            }
        }
        /* tslint:disable:no-any */
        var globalManifests = window.g_webPartManifests;
        /* tslint:enable:no-any */
        if (globalManifests && globalManifests.length) {
            this.importManifests(globalManifests, true);
        }
    };
    /**
     * Populate the manifest store with debug manifests.
     *
     * @param {manifests} A dictionary of debug manifests.
     */
    ManifestStore.prototype.populateDebugManifests = function (manifests) {
        if (manifests) {
            /* tslint:disable:forin */
            for (var id in manifests) {
                /* tslint:enable:forin */
                if (!this._manifests.get(id)) {
                    this._manifests.set(id, {
                        id: id,
                        manifest: undefined
                    });
                }
                this._manifests.get(id).debugManifest = manifests[id];
            }
        }
    };
    /**
     * Return a manifest by its ID. Only return a debug manifest is debug is allowed. If a manifest isn't found by
     * the provided ID, return undefined.
     *
     * @param {id} The ID of the manifest to retrieve.
     * @param {allowDebug} If true, return a debug manifest if one exists.
     * @returns The retrieved manifest, or undefined if one could not be found.
     */
    ManifestStore.prototype.getManifestById = function (id) {
        var manifestEntry = this._manifests.get(id);
        return this._getManifestFromStoreEntry(manifestEntry);
    };
    /**
     * Get all registered manifest objects.
     *
     * @returns The registered manifest objects.
     */
    ManifestStore.prototype.getAllManifests = function () {
        var _this = this;
        var result = [];
        this._manifests.forEach(function (manifestEntry) {
            var manifest = _this._getManifestFromStoreEntry(manifestEntry);
            if (manifest) {
                result.push(manifest);
            }
        });
        return result;
    };
    /**
     * Returns a map of manifest IDs to manfiests.
     *
     * @return {{ [key: string]: IManifestStoreEntry }}: A map of manifest IDs to manfiests.
     */
    ManifestStore.prototype.getManifestMap = function () {
        var result = {};
        this._manifests.forEach(function (value, key) { return result[key] = value; });
        return result;
    };
    /**
     * Loads additional manifests into the manifest store, updating existing manifests.
     *
     * @param {manifests} The manifests to load into the store.
     */
    ManifestStore.prototype.importManifests = function (manifests, overwriteExisting) {
        var _this = this;
        manifests.forEach(function (manifest) { return _this._addManifest(manifest, overwriteExisting); });
    };
    ManifestStore.prototype._getManifestFromStoreEntry = function (manifestEntry) {
        var allowDebug = SPModuleLoader_1.ensureDebugAllowed(false);
        if (manifestEntry) {
            if (allowDebug && manifestEntry.debugManifest) {
                return manifestEntry.debugManifest;
            }
            else {
                return manifestEntry.manifest;
            }
        }
        else {
            return undefined;
        }
    };
    ManifestStore.prototype._addManifest = function (manifest, overwriteExisting) {
        var v1Manifest = manifest;
        var v2Manifest = manifest;
        var manifestEntry = { id: manifest.id, manifest: v2Manifest };
        if (v1Manifest.properties && v1Manifest.properties.manifest) {
            // Looks like we're in a v1.5 manifest
            if (typeof v1Manifest.properties.manifest === 'string') {
                manifestEntry.manifest = JSON.parse(v1Manifest.properties.manifest);
            }
            else {
                manifestEntry.manifest = v1Manifest.properties.manifest;
            }
        }
        var existingEntry = this._manifests.get(manifest.id);
        if (existingEntry) {
            if (overwriteExisting || !existingEntry.manifest) {
                existingEntry.manifest = manifestEntry.manifest;
            }
        }
        else {
            this._manifests.set(manifest.id, manifestEntry);
        }
    };
    return ManifestStore;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ManifestStore;

//# sourceMappingURL=ManifestStore.js.map
