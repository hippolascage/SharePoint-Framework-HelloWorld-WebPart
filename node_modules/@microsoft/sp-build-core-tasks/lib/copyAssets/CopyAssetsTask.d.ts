import * as gulp from 'gulp';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { IFrameworkModuleConfig, IInternalModuleConfig, ILocalizedInternalModuleConfig } from '@microsoft/sp-module-interfaces';
import OdspGulpTask from './../OdspGulpTask';
import { IBundleEntry } from './../configureWebpack/ConfigureWebpackTask';
export interface ICopyAssetsTaskConfig {
    /**
     * Path to where assets should be staged for deployment to CDN during a production build
     */
    deployCdnPath?: string;
    /**
     * Extensions of webpack-produced assets to ignore
     */
    extsToIgnore?: string[];
}
export interface IDeployEntry {
    manifest: IClientSideComponentManifest;
    bundleEntry: IBundleEntry;
    entryDistPath?: string;
    entryName?: string;
    debugModules?: IDeployModules;
    productionModules?: IDeployModules;
}
export interface IDeployModules {
    entryModuleId?: string;
    localizedModules: Map<string, ILocalizedInternalModuleConfig>;
    internalModules: Map<string, IInternalModuleConfig>;
    frameworkModules: Map<string, IFrameworkModuleConfig>;
}
/**
 * Prepares deployment to CDNs and the manifest server through onedrive-buildtools.
 *
 * Example:
 *  IN:
 *   webpack stats
 *   deployCdnPath - a path where files should be placed for upload to CDNs and the manifest server
 *
 *  OUT:
 *   all assets for the package copied to {deployCdnPath}
 *   all externals for the package copied to {deployCdnPath}
 *   data required to produce manifests in the properties object
 */
export declare class CopyAssetsTask extends OdspGulpTask<ICopyAssetsTaskConfig> {
    name: string;
    taskConfig: ICopyAssetsTaskConfig;
    executeTask(gulp: gulp.Gulp, completeCallback: (error?: string) => void): NodeJS.ReadWriteStream;
    private _copyStrings(stringsCopyCallbackMap, tasks);
    private _processExternals(externalModules, tasks);
    private _processExternalsForEntry(webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap);
    private _renameWithHash(gulpStream, getFilename, filenameCallback);
    private _getRenameTransformFunction(getFilename, filenameCallback);
    /**
     * For webpack entries that are imported using SystemJS, the script is injected into the page, but
     * the element is removed before the entry is initialized. Webpack requires a public path be set,
     * and because we don't have a single host location, we need to set the public path dynamically.
     * The public path is set when the entry is initialized, and in certain cases (like in development),
     * it will look at the script tags on the page to determine what the root path is.
     *
     * We can append a small bit of code to the end of the entry's JS file that will mitigate this issue
     * by maintaining a registry of scripts that have been injected onto the page, so the public path
     * can be correctly set even if the script element that pointed to the entry's JS file has been removed
     * already.
     */
    private _insertGlobalRegisterCodeIfNecessary(self, debug);
}
