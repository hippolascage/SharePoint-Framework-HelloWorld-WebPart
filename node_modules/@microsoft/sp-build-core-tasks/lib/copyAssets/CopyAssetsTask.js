"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path = require('path');
var gulp = require('gulp');
var through2 = require('through2');
var merge = require('merge2');
var gulpReplace = require('gulp-replace');
var setWebpackPublicPath = require('@microsoft/loader-set-webpack-public-path');
var lodash_1 = require('lodash');
var sp_module_interfaces_1 = require('@microsoft/sp-module-interfaces');
var OdspGulpTask_1 = require('./../OdspGulpTask');
var constants_1 = require('../constants');
var IsUrl_1 = require('../utilities/IsUrl');
/**
 * Prepares deployment to CDNs and the manifest server through onedrive-buildtools.
 *
 * Example:
 *  IN:
 *   webpack stats
 *   deployCdnPath - a path where files should be placed for upload to CDNs and the manifest server
 *
 *  OUT:
 *   all assets for the package copied to {deployCdnPath}
 *   all externals for the package copied to {deployCdnPath}
 *   data required to produce manifests in the properties object
 */
var CopyAssetsTask = (function (_super) {
    __extends(CopyAssetsTask, _super);
    function CopyAssetsTask() {
        _super.apply(this, arguments);
        this.name = 'copyAssets';
        this.taskConfig = {
            deployCdnPath: undefined,
            extsToIgnore: ['.map', '.stats.json', '.stats.html']
        };
    }
    CopyAssetsTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        var shouldPrepareProductionDeployment = this.buildConfig.production;
        if (!this.taskConfig.deployCdnPath && this.buildConfig.production) {
            shouldPrepareProductionDeployment = false;
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('No deploy CDN path specified. Unable to prepare production deployment.');
        }
        if (!this.properties.webpackStats) {
            this.logWarning('Missing webpack stats object. Nothing to prepare for deployment.');
            completeCallback();
            return;
        }
        var configEntries = this.properties.entries;
        if (!configEntries || !configEntries.length || configEntries.length === 0) {
            // @TODO: SPPPlat VSO 221536
            // this.logWarning('Missing config entries list. Nothing to prepare for deployment.');
            completeCallback();
            return;
        }
        var distPath = path.join(this.buildConfig.rootPath, this.buildConfig.distFolder);
        var tasks = [];
        var webpackEntryChunks = new Map();
        var externalModules = [];
        var webpackStats = this.properties.webpackStats;
        var webpackStatsJson = webpackStats.toJson();
        var webpackAssets = webpackStatsJson.assets, webpackChunks = webpackStatsJson.chunks, webpackModules = webpackStatsJson.modules;
        webpackChunks.forEach(function (webpackChunk) {
            if (webpackChunk.entry) {
                webpackChunk.names.forEach(function (name) {
                    webpackEntryChunks.set(name, webpackChunk);
                });
            }
        });
        var externalsRegex = /external \"(.+)\"$/;
        var configExternals = this.properties.externals || {};
        webpackModules.forEach(function (webpackModule) {
            var matches = webpackModule.name.match(externalsRegex);
            if (matches) {
                var externalName_1 = matches[1];
                var configExternal = configExternals[externalName_1];
                var configExternalPath = void 0;
                if (configExternal) {
                    if (typeof configExternal === 'string') {
                        // it is an AMD external
                        configExternalPath = configExternal;
                    }
                    else {
                        // it is a non-AMD external
                        configExternalPath = configExternal.path;
                        if (!configExternal.globalName) {
                            _this.logError(("External \"" + externalName_1 + "\" is defined as a Non-AMD script,") +
                                "but is missing a globalName property.");
                            return;
                        }
                        webpackModule.nonAmdConfig = configExternal;
                        (configExternal.globalDependencies || []).forEach(function (nonAMDDependency) {
                            var dependencyConfig = configExternals[nonAMDDependency];
                            if (!dependencyConfig) {
                                _this.logError("External \"" + externalName_1 + "\" is referencing dependency \"" + nonAMDDependency + "\" which is not defined\".");
                                return;
                            }
                            else if (!dependencyConfig.globalName) {
                                _this.logError(("External \"" + externalName_1 + "\" is referencing dependency \"" + nonAMDDependency + "\"") +
                                    ", which is not defined as a global, non-AMD external.");
                                return;
                            }
                        });
                    }
                }
                if (configExternalPath) {
                    // Keep the whole path if it is a full URL
                    webpackModule.isExternalUrl = IsUrl_1.default(configExternalPath);
                    var configExternalFullPath = webpackModule.isExternalUrl
                        ? configExternalPath : path.join(_this.buildConfig.rootPath, configExternalPath);
                    webpackModule.configExternalFullPath = configExternalFullPath;
                }
                else if (!_this.properties.discoveredLocalizedResources[externalName_1]) {
                    _this.logError(("External \"" + externalName_1 + "\" is not correctly referenced in config.json. Deployed ") +
                        'modules will produce unexpected behavior.');
                }
                webpackModule.externalName = externalName_1; // Add the external name as a new property
                webpackModule.renameCallbacks = []; // Create a list of callbacks here
                externalModules.push(webpackModule);
            }
        });
        // Copy non-entry assets to the CDN deploy directory
        if (shouldPrepareProductionDeployment) {
            var assetsToCopy = [];
            var _loop_1 = function(webpackAsset) {
                var notIgnoredExt = !this_1.taskConfig.extsToIgnore ||
                    this_1.taskConfig.extsToIgnore.reduce(function (state, ext) {
                        return state && webpackAsset.name.slice(-ext.length) !== ext;
                    }, true);
                var notEntryChunk = webpackAsset.chunks.reduce(function (state, chunkId) {
                    return state && !webpackChunks[chunkId].entry;
                }, true);
                if (notIgnoredExt && notEntryChunk) {
                    // If we make it here, we aren't ignoring this chunk's extension and it isn't an entrypoint asset
                    // so we should copy it to the CDN deploy directory
                    // Try to ensure the file has a checksum in the filename
                    var checksumFound = false;
                    if (webpackAsset.chunks.length > 0) {
                        // Look through all of the asset's chunks and ensure the asset's name contains one of the chunks' hashes
                        checksumFound = webpackAsset.chunks.reduce(function (state, chunkId) {
                            return state || webpackAsset.name.indexOf(webpackChunks[chunkId].hash) > -1;
                        }, false);
                    }
                    else {
                        // Split the filename by "-" and "_", and test each part to see if it looks like a 5+ character hex digest
                        var name_1 = webpackAsset.name;
                        var filenameParts = path.basename(name_1, path.extname(name_1)).split(/[-_]/);
                        checksumFound = filenameParts.reduce(function (state, filenamePart) {
                            return state || !!filenamePart.match(/[a-fA-F0-9]{5,}/);
                        }, false);
                    }
                    if (!checksumFound) {
                        this_1.logError(("Webpack-produced asset \"" + webpackAsset.name + "\" does not appear to have a checksum ") +
                            'in its filename, meaning that it is not safe to deploy to the CDN.');
                    }
                    var assetPath = path.join(distPath, webpackAsset.name);
                    assetsToCopy.push(assetPath);
                    if (webpackAsset.name.toLowerCase() !== webpackAsset.name) {
                        this_1.logWarning(("Asset \"" + webpackAsset.name + "\"'s name is not all lowercase and will likely not be ") +
                            'accessible after being copied to the CDN. Ensure that its name is all lowercase, ' +
                            'and consider using the "@microsoft/loader-cased-file" loader.');
                    }
                }
            };
            var this_1 = this;
            for (var _i = 0, webpackAssets_1 = webpackAssets; _i < webpackAssets_1.length; _i++) {
                var webpackAsset = webpackAssets_1[_i];
                _loop_1(webpackAsset);
            }
            // Copy the assets we've queued
            tasks.push(gulp.src(assetsToCopy).pipe(gulp.dest(this.taskConfig.deployCdnPath)));
        }
        var deployEntries = [];
        var stringsCopyCallbackMap = new Map();
        configEntries.forEach(function (configEntry) {
            var manifest = _this.getManifest(configEntry.manifest);
            if (!manifest) {
                _this.logWarning(("Missing manifest for entry \"" + configEntry.entry + "\". ") +
                    'Unable to prepare deployment for this entry.');
                return;
            }
            var deployEntry = { bundleEntry: configEntry, manifest: manifest };
            deployEntries.push(deployEntry);
            var debugModules = deployEntry.debugModules = {
                localizedModules: new Map(),
                internalModules: new Map(),
                frameworkModules: new Map()
            };
            var productionModules = deployEntry.productionModules = {
                localizedModules: new Map(),
                internalModules: new Map(),
                frameworkModules: new Map()
            };
            var entryBundlePath = deployEntry.entryDistPath = path.join(_this.buildConfig.rootPath, configEntry.outputPath);
            var entryName = deployEntry.entryName = path.basename(entryBundlePath, path.extname(entryBundlePath));
            var manifestId = manifest.id;
            var stringsModuleId = manifestId + "_strings";
            var entryRegExp = entryName + "_?[a-zA-Z0-9]*.js";
            // If we change the type of bundle we're producing, we need to update this
            var escapedStringsName = lodash_1.escapeRegExp(constants_1.default.stringsExternalBundleName);
            var defaultStringsModuleRegex = new RegExp("^(define\\(.*\\[.*(\\\"|\\'))(?:" + escapedStringsName + ")((?:\\2).*])");
            // Initialize the entry gulp stream and make a few initial transformations
            var entryGulpStream = gulp.src(entryBundlePath)
                .pipe(through2.obj(_this._insertGlobalRegisterCodeIfNecessary(_this, !_this.buildConfig.production)))
                .pipe(gulpReplace(defaultStringsModuleRegex, "$1" + stringsModuleId + "$3"))
                .pipe(gulpReplace(new RegExp(constants_1.default.defaultWebpackPublicPathScriptName, 'g'), entryRegExp));
            // Write entry file back to 'dist'
            entryGulpStream = entryGulpStream.pipe(gulp.dest(distPath));
            // Record the debug entry module
            var debugEntryModule = {
                type: 'internal',
                path: entryBundlePath
            };
            debugModules.internalModules.set(entryName, debugEntryModule);
            debugModules.entryModuleId = entryName;
            if (shouldPrepareProductionDeployment) {
                var productionEntryModule_1 = {
                    type: 'internal',
                    path: undefined
                };
                productionModules.internalModules.set(entryName, productionEntryModule_1);
                productionModules.entryModuleId = entryName;
                // Write production file to the CDN deploy path
                entryGulpStream = _this._renameWithHash(entryGulpStream, function (hash) { return (entryName.toLowerCase() + "_" + hash + ".js"); }, function (filename) { return productionEntryModule_1.path = filename; })
                    .pipe(gulp.dest(_this.taskConfig.deployCdnPath));
            }
            tasks.push(entryGulpStream);
            var entryWebpackChunk = webpackEntryChunks.get(entryName);
            var webpackChunkId = entryWebpackChunk.id;
            _this._processExternalsForEntry(webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap);
        });
        this._copyStrings(stringsCopyCallbackMap, tasks);
        this._processExternals(externalModules, tasks);
        // Save the deploy entries so they can be picked up by the WriteManifests task.
        this.properties.deployEntries = deployEntries;
        return merge(tasks).on('finish', function () { return completeCallback(); });
    };
    CopyAssetsTask.prototype._copyStrings = function (stringsCopyCallbackMap, tasks) {
        var _this = this;
        var moduleBaseName = path.basename(this.buildConfig.rootPath).toLowerCase();
        stringsCopyCallbackMap.forEach(function (callbacks, key) {
            var isStandardStringsModule = key === constants_1.default.stringsExternalBundleName;
            var baseFilename = isStandardStringsModule
                ? moduleBaseName
                : moduleBaseName + "-" + key.toLowerCase().replace(/\//g, '_');
            var localizedFiles = _this.properties.discoveredLocalizedResources[key];
            var _loop_2 = function(locale) {
                if (localizedFiles.hasOwnProperty(locale)) {
                    tasks.push(_this._renameWithHash(gulp.src(localizedFiles[locale]), function (hash) { return (baseFilename + "_" + locale + "_" + hash + ".js"); }, function (filename) {
                        return callbacks.forEach(function (callback) {
                            return callback(locale, filename);
                        });
                    })
                        .pipe(gulp.dest(_this.taskConfig.deployCdnPath)));
                }
            };
            for (var locale in localizedFiles) {
                _loop_2(locale);
            }
        });
    };
    CopyAssetsTask.prototype._processExternals = function (externalModules, tasks) {
        var _this = this;
        externalModules.forEach(function (externalModule) {
            if (externalModule.renameCallbacks.length > 0) {
                // Replace slashes in the filename with dashes so we don't end up with unexpected subfolders
                var baseFilename_1 = externalModule.externalName.replace(/[\/\\]/, '-');
                tasks.push(_this._renameWithHash(gulp.src(externalModule.configExternalFullPath), function (hash) { return (baseFilename_1.toLowerCase() + "_" + hash + ".js"); }, function (filename) {
                    return externalModule.renameCallbacks.forEach(function (renameCallback) {
                        return renameCallback(filename);
                    });
                })
                    .pipe(gulp.dest(_this.taskConfig.deployCdnPath)));
            }
        });
    };
    CopyAssetsTask.prototype._processExternalsForEntry = function (webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap) {
        var _this = this;
        externalModules.forEach(function (externalModule) {
            // Determine if this external is referenced by the entry chunk
            if (externalModule.chunks.reduce(function (state, chunkId) { return state || webpackChunkId === chunkId; }, false)) {
                var externalName = externalModule.externalName;
                var localizedResource = _this.properties.discoveredLocalizedResources[externalName];
                if (localizedResource) {
                    // This is a localized resource
                    var isStandardStringsModule = externalName === constants_1.default.stringsExternalBundleName;
                    var resourceName = isStandardStringsModule ? stringsModuleId : externalName;
                    var debugModule = {
                        defaultPath: undefined,
                        type: 'localized',
                        paths: {}
                    };
                    deployEntry.debugModules.localizedModules.set(resourceName, debugModule);
                    for (var locale in localizedResource) {
                        if (localizedResource.hasOwnProperty(locale)) {
                            var path_1 = localizedResource[locale];
                            if (locale === 'default' || locale === constants_1.default.defaultLocale) {
                                debugModule.defaultPath = path_1;
                            }
                            else {
                                debugModule.paths[locale] = path_1;
                            }
                        }
                    }
                    if (shouldPrepareProductionDeployment) {
                        var productionModule_1 = {
                            defaultPath: undefined,
                            type: 'localized',
                            paths: {}
                        };
                        deployEntry.productionModules.localizedModules.set(resourceName, productionModule_1);
                        if (!stringsCopyCallbackMap.has(externalName)) {
                            stringsCopyCallbackMap.set(externalName, []);
                        }
                        var callbacks = stringsCopyCallbackMap.get(externalName);
                        callbacks.push((function (locale, filename) {
                            if (locale === 'default' || locale === constants_1.default.defaultLocale) {
                                productionModule_1.defaultPath = filename;
                            }
                            else {
                                productionModule_1.paths[locale] = filename;
                            }
                        }));
                    }
                }
                else if (!externalModule.configExternalFullPath) {
                    return;
                }
                else if (sp_module_interfaces_1.standardLibraryModules[externalName]) {
                    // This is a framework module, so we need to record that this entry is using it, but we don't need to
                    // copy it to the CDN directory
                    // We want to discover which version of the package they're building against eventually
                    // @todo VSO#215254
                    var version = 'latest';
                    var debugModule = {
                        type: 'framework',
                        version: version,
                        failoverPath: externalModule.configExternalFullPath
                    };
                    deployEntry.debugModules.frameworkModules.set(externalName, debugModule);
                    if (shouldPrepareProductionDeployment) {
                        var productionModule = {
                            type: 'framework',
                            version: version
                        };
                        deployEntry.productionModules.frameworkModules.set(externalName, productionModule);
                    }
                }
                else {
                    // This is a plain internal module, so we do need to copy it to the CDN directory if we're in production
                    // mode and it is not a fully qualified URL
                    deployEntry.debugModules.internalModules.set(externalName, externalModule.nonAmdConfig ?
                        {
                            type: 'internal',
                            path: externalModule.configExternalFullPath,
                            globalDependencies: externalModule.nonAmdConfig.globalDependencies,
                            globalName: externalModule.nonAmdConfig.globalName
                        } : {
                        type: 'internal',
                        path: externalModule.configExternalFullPath
                    });
                    if (shouldPrepareProductionDeployment) {
                        var productionModule_2 = externalModule.nonAmdConfig ?
                            {
                                type: 'internal',
                                path: undefined,
                                globalDependencies: externalModule.nonAmdConfig.globalDependencies,
                                globalName: externalModule.nonAmdConfig.globalName
                            } : {
                            type: 'internal',
                            path: undefined
                        };
                        deployEntry.productionModules.internalModules.set(externalName, productionModule_2);
                        if (externalModule.isExternalUrl) {
                            // There won't be a rename since this is not on the local filesystem
                            productionModule_2.path = externalModule.configExternalFullPath;
                        }
                        else {
                            externalModule.renameCallbacks.push(function (filename) { return productionModule_2.path = filename; });
                        }
                    }
                }
            }
        });
    };
    CopyAssetsTask.prototype._renameWithHash = function (gulpStream, getFilename, filenameCallback) {
        return gulpStream.pipe(through2.obj(this._getRenameTransformFunction(getFilename, filenameCallback)));
    };
    CopyAssetsTask.prototype._getRenameTransformFunction = function (getFilename, filenameCallback) {
        var self = this;
        return function (file, enc, callback) {
            var checksum = self.getChecksum(file.contents.toString(enc));
            var filename = getFilename(checksum);
            file.path = path.join(path.dirname(file.path), filename);
            filenameCallback(filename);
            this.push(file);
            callback();
        };
    };
    /**
     * For webpack entries that are imported using SystemJS, the script is injected into the page, but
     * the element is removed before the entry is initialized. Webpack requires a public path be set,
     * and because we don't have a single host location, we need to set the public path dynamically.
     * The public path is set when the entry is initialized, and in certain cases (like in development),
     * it will look at the script tags on the page to determine what the root path is.
     *
     * We can append a small bit of code to the end of the entry's JS file that will mitigate this issue
     * by maintaining a registry of scripts that have been injected onto the page, so the public path
     * can be correctly set even if the script element that pointed to the entry's JS file has been removed
     * already.
     */
    CopyAssetsTask.prototype._insertGlobalRegisterCodeIfNecessary = function (self, debug) {
        return function (file, enc, callback) {
            if (!file.isNull() && file.contents) {
                var contents = file.contents.toString(enc);
                if (contents.match(new RegExp(setWebpackPublicPath.registryVarName, 'g'))) {
                    var registerCode = setWebpackPublicPath.getGlobalRegisterCode(debug);
                    file.contents = new Buffer("" + contents + registerCode);
                }
                this.push(file);
            }
            callback();
        };
    };
    return CopyAssetsTask;
}(OdspGulpTask_1.default));
exports.CopyAssetsTask = CopyAssetsTask;

//# sourceMappingURL=CopyAssetsTask.js.map
