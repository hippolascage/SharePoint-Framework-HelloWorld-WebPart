{"version":3,"sources":["packageSolution/packageSolution/utils/normalizeSolutionDefinition.ts"],"names":[],"mappings":"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","file":"packageSolution/packageSolution/utils/normalizeSolutionDefinition.js","sourcesContent":["/**\r\n * @file normalizeSolutionDefinition.ts\r\n * @Copyright (c) Microsoft Corporation.  All rights reserved.\r\n *\r\n * Using a manifest map, creates component definitions and updates a package definition's element guids with\r\n * actual objects\r\n */\r\n\r\nimport ISolution from '../models/packageDefinition/ISolution';\r\nimport IFeature from '../models/packageDefinition/IFeature';\r\nimport IComponent, { IWebPartDefinition } from '../models/packageDefinition/IComponent';\r\nimport componentType from '../models/ComponentType';\r\n\r\nimport {\r\n  IClientSideComponentManifest,\r\n  IClientSideWebPartManifest,\r\n  IClientSideApplicationManifest\r\n} from '@microsoft/sp-module-interfaces';\r\n\r\nfunction createComponent(manifest: IClientSideComponentManifest): IComponent {\r\n  if (!manifest.id || !manifest || !manifest.componentType) {\r\n    return undefined;\r\n  }\r\n\r\n  // Extract the component name from the manifest\r\n  let name: string;\r\n  if (manifest.componentType === 'Application') {\r\n    name = (manifest as IClientSideApplicationManifest).title.default;\r\n  } else if (manifest.componentType === 'WebPart') {\r\n    // WebParts have multiple entries, extract the first from the list\r\n    const webpartManifest: IClientSideWebPartManifest<{}> = (manifest as IClientSideWebPartManifest<{}>);\r\n    if (webpartManifest.preconfiguredEntries && webpartManifest.preconfiguredEntries.length) {\r\n      name = webpartManifest.preconfiguredEntries[0].title.default;\r\n    } else {\r\n      console.log(`No preconfiguredEntries list found for WebPart manifest '${manifest.id}'`);\r\n    }\r\n  } else {\r\n    console.log(`Component type '${manifest.componentType}' not recognized. Skipping manifest.`);\r\n    return undefined;\r\n  }\r\n\r\n  return {\r\n    name: name,\r\n    id: manifest.id,\r\n    manifest: JSON.stringify(manifest),\r\n    type: componentType[manifest.componentType],\r\n    componentDefinition: {} as IWebPartDefinition\r\n  };\r\n}\r\n\r\nfunction createComponentMapFromManifests(manifests: Map<string, IClientSideComponentManifest>):\r\n  Map<string, IComponent> {\r\n  console.log(`Attempting creating component definitions for {${manifests.size}} manifests`);\r\n  const components: Map<string, IComponent> = new Map<string, IComponent>();\r\n  manifests.forEach((manifest, key: string) => {\r\n    const component: IComponent = createComponent(manifest);\r\n    if (component) {\r\n      components.set(key, component);\r\n    }\r\n  });\r\n\r\n  console.log(`Created component definitions for {${components.size}} manifests`);\r\n  return components;\r\n}\r\n\r\nfunction createFeatureFromComponent(component: IComponent): IFeature {\r\n  const componentTypeStr: string = (component.type === componentType.WebPart ? 'WebPart' : 'Application');\r\n\r\n  return {\r\n    title: `${component.name} Feature`,\r\n    description: `A feature which activates the Client-Side ${componentTypeStr} named ${component.name}`,\r\n    id: component.id, // @todo - this is a hack, we need a better way of doing this\r\n    components: [component]\r\n  };\r\n}\r\n\r\n/**\r\n * Normalizes the passed in solution definition by cross referencing componentIds with the collected list\r\n * of manifests in the repo. If, for any feature, the componentId list is missing or empty, we add all the\r\n * components to that feature. Similarly, if the list of features in the solution is empty or missing, a\r\n * feature is automatically created for all solutions.\r\n */\r\nexport default\r\n  function normalizeSolutionDefinition(solution: ISolution, manifests: Map<string, IClientSideComponentManifest>):\r\n  void {\r\n  const componentMap: Map<string, IComponent> = createComponentMapFromManifests(manifests);\r\n  const numManifests: number = componentMap.size;\r\n\r\n  if (numManifests === 0) {\r\n    throw 'Could not find any valid manifests. Please double check paths.manifestsMatch in the task config.';\r\n  }\r\n\r\n  // Then, replace the guids in the solution definition with the component definition\r\n  if (solution.features) {\r\n    for (const feature of solution.features) {\r\n      if (feature.componentIds && feature.componentIds.length > 0) {\r\n        feature.components = feature.componentIds.map((componentId: string): IComponent => {\r\n          const manifest: IComponent = componentMap.get(componentId);\r\n          if (!manifest) {\r\n            throw new Error(\r\n              `Component {${componentId as string}} does not exist in feature '${feature.title}'. `\r\n              + 'Please update your configuration.');\r\n          }\r\n          return manifest;\r\n        });\r\n      } else {\r\n        console.log('feature.componentIds not set! ' +\r\n                    `Adding all [${numManifests}] components to feature { ${feature.title } }.`);\r\n        feature.components = [];\r\n        componentMap.forEach((component: IComponent) => {\r\n          feature.components.push(component);\r\n        });\r\n      }\r\n    }\r\n  } else {\r\n    console.log('config.solution.features not set! Instead generating a feature for each component.');\r\n    solution.features = [];\r\n    componentMap.forEach((component: IComponent) => {\r\n      console.log(`Creating feature for ${component.name}...`);\r\n      solution.features.push(createFeatureFromComponent(component));\r\n    });\r\n  }\r\n}\r\n"],"sourceRoot":"/source/"}