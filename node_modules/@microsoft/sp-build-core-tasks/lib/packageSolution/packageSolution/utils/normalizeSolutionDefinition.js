/**
 * @file normalizeSolutionDefinition.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Using a manifest map, creates component definitions and updates a package definition's element guids with
 * actual objects
 */
"use strict";
var ComponentType_1 = require('../models/ComponentType');
function createComponent(manifest) {
    if (!manifest.id || !manifest || !manifest.componentType) {
        return undefined;
    }
    // Extract the component name from the manifest
    var name;
    if (manifest.componentType === 'Application') {
        name = manifest.title.default;
    }
    else if (manifest.componentType === 'WebPart') {
        // WebParts have multiple entries, extract the first from the list
        var webpartManifest = manifest;
        if (webpartManifest.preconfiguredEntries && webpartManifest.preconfiguredEntries.length) {
            name = webpartManifest.preconfiguredEntries[0].title.default;
        }
        else {
            console.log("No preconfiguredEntries list found for WebPart manifest '" + manifest.id + "'");
        }
    }
    else {
        console.log("Component type '" + manifest.componentType + "' not recognized. Skipping manifest.");
        return undefined;
    }
    return {
        name: name,
        id: manifest.id,
        manifest: JSON.stringify(manifest),
        type: ComponentType_1.default[manifest.componentType],
        componentDefinition: {}
    };
}
function createComponentMapFromManifests(manifests) {
    console.log("Attempting creating component definitions for {" + manifests.size + "} manifests");
    var components = new Map();
    manifests.forEach(function (manifest, key) {
        var component = createComponent(manifest);
        if (component) {
            components.set(key, component);
        }
    });
    console.log("Created component definitions for {" + components.size + "} manifests");
    return components;
}
function createFeatureFromComponent(component) {
    var componentTypeStr = (component.type === ComponentType_1.default.WebPart ? 'WebPart' : 'Application');
    return {
        title: component.name + " Feature",
        description: "A feature which activates the Client-Side " + componentTypeStr + " named " + component.name,
        id: component.id,
        components: [component]
    };
}
/**
 * Normalizes the passed in solution definition by cross referencing componentIds with the collected list
 * of manifests in the repo. If, for any feature, the componentId list is missing or empty, we add all the
 * components to that feature. Similarly, if the list of features in the solution is empty or missing, a
 * feature is automatically created for all solutions.
 */
function normalizeSolutionDefinition(solution, manifests) {
    var componentMap = createComponentMapFromManifests(manifests);
    var numManifests = componentMap.size;
    if (numManifests === 0) {
        throw 'Could not find any valid manifests. Please double check paths.manifestsMatch in the task config.';
    }
    // Then, replace the guids in the solution definition with the component definition
    if (solution.features) {
        var _loop_1 = function(feature) {
            if (feature.componentIds && feature.componentIds.length > 0) {
                feature.components = feature.componentIds.map(function (componentId) {
                    var manifest = componentMap.get(componentId);
                    if (!manifest) {
                        throw new Error(("Component {" + componentId + "} does not exist in feature '" + feature.title + "'. ")
                            + 'Please update your configuration.');
                    }
                    return manifest;
                });
            }
            else {
                console.log('feature.componentIds not set! ' +
                    ("Adding all [" + numManifests + "] components to feature { " + feature.title + " }."));
                feature.components = [];
                componentMap.forEach(function (component) {
                    feature.components.push(component);
                });
            }
        };
        for (var _i = 0, _a = solution.features; _i < _a.length; _i++) {
            var feature = _a[_i];
            _loop_1(feature);
        }
    }
    else {
        console.log('config.solution.features not set! Instead generating a feature for each component.');
        solution.features = [];
        componentMap.forEach(function (component) {
            console.log("Creating feature for " + component.name + "...");
            solution.features.push(createFeatureFromComponent(component));
        });
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = normalizeSolutionDefinition;

//# sourceMappingURL=normalizeSolutionDefinition.js.map
