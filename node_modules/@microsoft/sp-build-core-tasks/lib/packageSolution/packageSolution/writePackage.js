/**
 * @file writePackage.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Writes a package xml object to disk, in both raw and zipped format
 */
"use strict";
/* tslint:disable:no-any */
/// <reference path='./node-zip.d.ts' />
require('es6-promise');
var mkdirp = require('mkdirp');
var path = require('path');
var rmdir = require('rimraf');
var fs = require('fs');
var JSZip = require('node-zip');
var utilities_1 = require('../utilities');
/**
 * Writes the ISolutionXml object containing the solution package xml to the disk using provided config
 */
function writePackage(solution, config) {
    var zip = new JSZip();
    return cleanRawPackageDirectory(config)
        .then(function () { return Promise.all([
        writeODCFile(solution.manifest, config, zip),
        writeXmlFile(solution.relationships, config, zip),
        writeXmlFile(solution.contentTypesXml, config, zip)
    ]
        .concat(solution.customFiles.map(function (customFile) { return writeXmlFile(customFile, config, zip); }))
        .concat(solution.features.map(function (feature) { return writeFeature(feature, config, zip); }))); })
        .then(function () {
        return writeFile(config.paths.zippedPackage, zip.generate({ base64: false, compression: 'DEFLATE' }), 'binary');
    });
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = writePackage;
/**
 * Ensures that the contents of config.paths.debugDir have been deleted
 */
function cleanRawPackageDirectory(config) {
    return new Promise(function (complete, reject) {
        rmdir(config.paths.debugDir, function (error) {
            if (error) {
                reject(error);
                return;
            }
            console.log("Cleaned " + config.paths.debugDir);
            complete();
        });
    });
}
exports.cleanRawPackageDirectory = cleanRawPackageDirectory;
function writeFeature(feature, config, zip) {
    return Promise.all([
        writeODCFile(feature, config, zip),
        writeXmlFile(feature.config, config, zip)]
        .concat(feature.components.map(function (component) { return writeXmlFile(component, config, zip); })));
}
exports.writeFeature = writeFeature;
function writeXmlFile(file, config, zip) {
    return writeFileToPath(file.filename, file.xml, config, zip);
}
exports.writeXmlFile = writeXmlFile;
function writeODCFile(file, config, zip) {
    return Promise.all([
        writeFileToPath(file.filename, file.xml, config, zip),
        writeXmlFile(file.relationships, config, zip)]);
}
exports.writeODCFile = writeODCFile;
/**
 * Physically writes a file to disk, and adds to an in-memory zip package
 */
function writeFileToPath(filename, contents, config, zip) {
    var filepath = path.join(config.paths.debugDir, filename);
    return utilities_1.serial([
        function () { return ensureDirectory(filepath); },
        function () { return writeFile(filepath, contents); },
        function () { return addFileToZip(filename, contents, zip); }]);
}
/**
 * Returns a promise which ensures a directory on disk exists using mkdirp
 */
function ensureDirectory(filepath) {
    return new Promise(function (complete, reject) {
        var directories = filepath.split(path.sep);
        directories.pop();
        var pathToFile = directories.join(path.sep);
        mkdirp(pathToFile, function (err) {
            if (err) {
                reject(err);
                return;
            }
            complete();
        });
    });
}
/**
 * Wraps fs.writeFile in a promise
 */
function writeFile(filename, contents, flag) {
    return new Promise(function (complete, reject) {
        fs.writeFile(filename, contents, flag, function (error) {
            if (error) {
                reject(error);
                return;
            }
            console.log("Created file: " + filename);
            complete();
        });
    });
}
/**
 * Adds a file to a zip package
 */
function addFileToZip(filepath, content, zip) {
    return new Promise(function (complete, reject) {
        var directories = filepath.split(path.sep);
        var file = directories.pop();
        for (var _i = 0, directories_1 = directories; _i < directories_1.length; _i++) {
            var dir = directories_1[_i];
            zip = zip.folder(dir);
        }
        zip.file(file, content);
        complete();
    });
}

//# sourceMappingURL=writePackage.js.map
