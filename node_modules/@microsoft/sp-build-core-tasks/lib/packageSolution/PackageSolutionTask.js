'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path = require('path');
var through2 = require('through2');
var gulp_core_build_1 = require('gulp-core-build');
var createPackage_1 = require('./packageSolution/createPackage');
var manifestSchemaValidator_1 = require('@microsoft/sp-module-interfaces/lib/manifestSchemaValidator');
/* tslint:enable:max-line-length */
var PackageSolutionTask = (function (_super) {
    __extends(PackageSolutionTask, _super);
    function PackageSolutionTask() {
        var _this = this;
        _super.apply(this, arguments);
        this.name = 'package-solution';
        this.taskConfig = {
            paths: {
                packageDir: 'sharepoint',
                debugDir: path.join('solution', 'debug'),
                zippedPackage: path.join('solution', 'ClientSolution.spapp'),
                featureXmlDir: 'feature_xml',
                manifestsMatch: '*.json',
                manifestDir: function () { return _this.buildConfig.distFolder; }
            },
            solution: {
                'name': 'A Sample Solution',
                'id': '00000000-0000-0000-0000-000000000000'
            }
        };
        this._hasPrependedPaths = false;
    }
    PackageSolutionTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        this._prependBaseToConfigPaths();
        var manifestMap = new Map();
        var foundAnyManifests = false;
        gulp.src(this.taskConfig.paths.manifestsMatch)
            .pipe(through2.obj(function (file, enc, callback) {
            foundAnyManifests = true;
            var manifest = JSON.parse(file.contents.toString(enc));
            var validationResult = manifestSchemaValidator_1.default.validateManifest(manifest);
            if (!validationResult.result) {
                _this.logWarning("Ignoring manifest due to validation error (" + file.path + ")");
                _this.logVerbose(manifestSchemaValidator_1.default.getFormattedErrorMessage(validationResult.errors));
                callback();
                return;
            }
            _this.log("Found manifest: " + file.path + " ");
            manifestMap.set(manifest.id, manifest);
            callback();
        }, function (callback) {
            if (!manifestMap.size) {
                if (foundAnyManifests) {
                    callback(new Error(("Some manifests were found in '" + _this.taskConfig.paths.manifestsMatch + "' ") +
                        ', but were not valid. Ensure paths.manifestsMatch is correct'));
                }
                else {
                    callback(new Error(("No manifests were found in '" + _this.taskConfig.paths.manifestsMatch + "'. ") +
                        'Ensure a build has completed successfully and that paths.manifestsMatch is correct'));
                }
            }
            createPackage_1.default(_this.taskConfig, manifestMap).then(callback);
        }))
            .on('finish', function () { return completeCallback(); });
    };
    PackageSolutionTask.prototype.getNukeMatch = function (buildConfig) {
        this.buildConfig = buildConfig;
        this._prependBaseToConfigPaths();
        return [
            this.taskConfig.paths.debugDir,
            this.taskConfig.paths.zippedPackage
        ];
    };
    PackageSolutionTask.prototype._prependBaseToConfigPaths = function () {
        if (!this._hasPrependedPaths) {
            this.taskConfig.paths.manifestsMatch =
                path.join(this.taskConfig.paths.manifestDir(), this.taskConfig.paths.manifestsMatch);
            this.taskConfig.paths.debugDir =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.debugDir);
            this.taskConfig.paths.zippedPackage =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.zippedPackage);
            this.taskConfig.paths.featureXmlDir =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.featureXmlDir);
            this._hasPrependedPaths = true;
        }
    };
    return PackageSolutionTask;
}(gulp_core_build_1.GulpTask));
exports.PackageSolutionTask = PackageSolutionTask;

//# sourceMappingURL=PackageSolutionTask.js.map
