"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lodash = require('lodash');
var path = require('path');
var webpack = require('webpack');
var OdspGulpTask_1 = require('./../OdspGulpTask');
var constants_1 = require('./../constants');
var supportedWebpackLibraryTargets = ['var', 'this', 'commonjs', 'commonjs2', 'amd', 'umd'];
exports.fileLoaderExts = ['jpg', 'png', 'woff', 'eot', 'ttf', 'svg', 'gif'];
var isRunningInNpmMode = process.argv.indexOf('--npm') !== -1;
/**
 * Configures the gulp-core-build-webpack task with some smart defaults based on the package configuration.
 *
 * Example:
 *  IN:
 *    setConfig({
 *      webpack: <reference to webpack task>,
 *      webpackPublicPathOptions: <options for @microsoft/loader-set-webpack-public-path>,
 *      libraryName: <optional library name - set this if the library should be a global on the window>
 *    })
 *    buildConfig.properties.entries = [{
 *      "entry": "./lib/App.js",
 *      "manifest": "./src/app.manifest.json",
 *      "outputPath": "dist/app.bundle.js"
 *    }]
 *    buildConfig.properties.externals = {
 *      "react-dom": "node_modules/react-dom/dist/react-dom.js",
 *      "react": "node_modules/react/dist/react.js",
 *      "flux": "node_modules/flux/dist/flux.js",
 *    }
 *
 *  OUT:
 *    set webpack config to:
 *    {
 *        context: ... root path ...,
 *        entry: { ... mapping of names to entries ... },
 *        resolveLoader: {
 *          alias: undefined,
 *          root: ... node_modules ...
 *        },
 *        resolve: {
 *          extensions: ['', '.tsx', '.ts', '.jsx', '.js', '.less', '.css', '.html'],
 *          modulesDirectories: [ ... root path + /node_modules ],
 *          alias: { }
 *        },
 *        output: {
 *          library: <library name, if provided>,
 *          libraryTarget: 'umd',
 *          path: ... dist folder ...,
 *          publicPath: this.taskConfig.publicPath,
 *          filename: PRODUCTION ? '[name]_[chunkhash].js' : '[name].js'
 *        },
 *        externals: [ ... externals names ... ],
 *        module: {
 *          preLoaders: [],
 *          noParse: [ /\.map$/ ],
 *          loaders: [
 *            {
 *              test: /\.module.scss$/,
 *              loader:
 *                'load-themed-styles!css-loader?&modules&localIdentName=[name]__[local]___[hash:base64:5]'
 *            },
 *            {
 *              test: /\.scss$/, exclude: /\.module.scss$/,
 *              loader: 'load-themed-styles!css-loader'
 *            },
 *            {
 *              test: /\.(jpg|png|woff|eot|ttf|svg|gif)$/,
 *              loader: '@microsoft/loader-cased-file?name=[name]_[hash].[ext]'
 *            }
 *          ]
 *        },
 *        plugins: []
 *      }
 */
var ConfigureWebpackTask = (function (_super) {
    __extends(ConfigureWebpackTask, _super);
    function ConfigureWebpackTask() {
        _super.call(this);
        this.name = 'configureWebpack';
        this.taskConfig = {
            libraryName: undefined,
            webpack: undefined,
            webpackPublicPathOptions: undefined,
            additionalConfiguration: undefined
        };
        this._baseConfig = {
            module: {
                loaders: [
                    {
                        loader: '@microsoft/loader-load-themed-styles!css-loader',
                        test: /\.css$/
                    },
                    {
                        loader: '@microsoft/loader-cased-file?name=[name:lower]_[hash].[ext]',
                        test: new RegExp(".(" + exports.fileLoaderExts.map(function (ext) { return lodash.escapeRegExp(ext); }).join('|') + ")$")
                    },
                    {
                        loader: 'json-loader',
                        test: /\.json$/
                    }
                ],
                noParse: [/\.map$/],
                postLoaders: [],
                preLoaders: [
                    {
                        test: /\.js$/,
                        loader: 'source-map-loader'
                    }
                ]
            },
            resolve: {
                alias: {},
                modulesDirectories: [
                    '',
                    'node_modules',
                    'lib'
                ]
            },
            resolveLoader: {
                alias: undefined,
                root: path.join(__dirname, '..', '..', 'node_modules'),
                moduleTemplates: ['@microsoft/loader-*']
            }
        };
        // Get the webpack default configuration
        var defaultConfig = {};
        /* tslint:disable:no-any */
        (new webpack.WebpackOptionsDefaulter()).process(defaultConfig);
        /* tslint:enable:no-any */
        // Include the default moduleTemplates, if there are any defaults
        if (defaultConfig.resolveLoader &&
            defaultConfig.resolveLoader.moduleTemplates &&
            !!defaultConfig.resolveLoader.moduleTemplates.length) {
            (_a = this._baseConfig.resolveLoader.moduleTemplates).push.apply(_a, defaultConfig.resolveLoader.moduleTemplates);
        }
        var _a;
    }
    ConfigureWebpackTask.prototype.setConfig = function (config) {
        if (config.webpack && config.webpack.name !== 'webpack') {
            this.logWarning('Setting webpack property to non-"gulp-core-build-webpack"-type will ' +
                'prevent configuration');
        }
        _super.prototype.setConfig.call(this, config);
    };
    ConfigureWebpackTask.prototype.getKarmaConfig = function (postLoaders, externals) {
        var testAddons = {
            externals: externals,
            module: {
                loaders: [{
                        loader: 'imports?define=>false',
                        test: /sinon\.js$/
                    }],
                postLoaders: postLoaders
            },
            plugins: [new webpack.DefinePlugin({
                    UNIT_TEST: true
                })],
            resolve: {
                alias: {}
            }
        };
        return this._appendToBaseConfig(testAddons);
    };
    ConfigureWebpackTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.taskConfig.webpack) {
            this.logWarning('"webpack" is not defined in the task configuration. Nothing to configure.');
            completeCallback();
            return;
        }
        if (!this.buildConfig.properties) {
            this._logNoEntriesWarning();
            this._setWebpackConfig({});
            completeCallback();
            return;
        }
        // If the library target is explicitly set, ensure that it's set to one of the valid webpack library targets.
        if (this.taskConfig.libraryTarget && supportedWebpackLibraryTargets.indexOf(this.taskConfig.libraryTarget) === -1) {
            this.logError("\"" + this.taskConfig.libraryTarget + "\" is not a valid library target type.");
            completeCallback();
            return;
        }
        /* tslint:disable:typedef variable-name */
        var StatsPlugin = require('webpack-stats-plugin');
        var VisualizerPlugin = require('webpack-visualizer-plugin');
        /* tslint:enable:typedef variable-name */
        var entries = this.properties.entries || [];
        var externals = this.properties.externals || {};
        var externalsKeys = Object.keys(externals);
        var localizedResources = this.properties.localizedResources || {};
        var localizedResourcesKeys = Object.keys(localizedResources);
        if (entries.length === 0) {
            this._logNoEntriesWarning();
        }
        this.logVerbose(entries.length + " entries specified.");
        this.logVerbose(externalsKeys.length + " externals specified.");
        this.logVerbose(localizedResourcesKeys.length + " localized resources specified.");
        localizedResourcesKeys.forEach(function (key) {
            if (externalsKeys.indexOf(key) !== -1) {
                _this.logError("Invalid Configuration: Key \"" + key + "\" is specified in both externals and localizedResources.");
            }
        });
        var webpackPublicPathOptions = lodash.clone(this.taskConfig.webpackPublicPathOptions) || {};
        if (!webpackPublicPathOptions.systemJs) {
            lodash.merge(webpackPublicPathOptions, {
                scriptPath: constants_1.default.defaultWebpackPublicPathScriptName
            });
        }
        /* tslint:disable:typedef */
        var setWebpackPublicPath = require('@microsoft/loader-set-webpack-public-path');
        /* tslint:enable:typedef */
        setWebpackPublicPath.setOptions(webpackPublicPathOptions);
        // When we loop through the config entries, record the component IDs so we can use them later if we need to
        var componentIds = [];
        var webpackEntries = {};
        entries.forEach(function (entry) {
            var entryName = path.basename(entry.outputPath, '.js');
            webpackEntries[entryName] = path.join(_this.buildConfig.rootPath, entry.entry);
            var manifest = _this.getManifest(entry.manifest);
            if (manifest) {
                componentIds.push(manifest.id);
            }
        });
        var libraryName = this.taskConfig.libraryName || (function () {
            if (componentIds.length === 0) {
                // If there are no component IDs, it doesn't appear as though we're generating a bundle that will be
                //  loaded on the page, because the module loader requires an ID, so we shouldn't need to worry about
                //  collisions in the webpackJsonp function.
                return undefined;
            }
            else if (componentIds.length === 1) {
                return componentIds[0];
            }
            else {
                // If there are multiple component IDs, this is a project that is producing multiple components. For now,
                //  we'll just concatenate them and then hash them so we end up with something unique (becuase that's all we
                //  really care about). When we update this task to support multiple webpack configurations, we can seperate
                //  each bundle to have its own library name.
                return _this.getChecksum(componentIds.join(''));
            }
        })();
        var pathDirNames = this.buildConfig.rootPath.split(path.sep);
        var lastDirName = pathDirNames[pathDirNames.length - 1] === ''
            ? pathDirNames[pathDirNames.length - 2] : pathDirNames[pathDirNames.length - 1];
        var configAddons = {
            context: this.buildConfig.rootPath,
            devtool: this.buildConfig.production ? undefined : 'source-map',
            entry: webpackEntries,
            externals: externalsKeys.concat(localizedResourcesKeys),
            output: {
                chunkFilename: '[id].[name]_[chunkhash].js',
                filename: '[name].js',
                library: libraryName,
                libraryTarget: this.taskConfig.libraryTarget || 'amd',
                path: path.join(this.buildConfig.rootPath, this.buildConfig.distFolder),
                devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
                devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[hash]'
            },
            plugins: [
                new StatsPlugin.StatsWriterPlugin({
                    /* tslint:disable:no-null-keyword */
                    fields: null,
                    /* tslint:enable:no-null-keyword */
                    filename: lastDirName + ".stats.json"
                }),
                new VisualizerPlugin({
                    filename: lastDirName + ".stats.html"
                })
            ]
        };
        if (this.buildConfig.production) {
            configAddons.plugins.push(new webpack.optimize.UglifyJsPlugin({
                compress: {
                    dead_code: true,
                    warnings: false
                },
                mangle: true
            }));
        }
        configAddons.plugins.push(new webpack.DefinePlugin({
            DEBUG: !this.buildConfig.production,
            UNIT_TEST: false,
            NPM_BUILD: isRunningInNpmMode
        }));
        var config = this._appendToBaseConfig(configAddons);
        if (this.taskConfig.additionalConfiguration) {
            config = this.taskConfig.additionalConfiguration(config);
        }
        this._setWebpackConfig(config);
        completeCallback();
        return;
    };
    ConfigureWebpackTask.prototype._appendToBaseConfig = function (config) {
        /* tslint:disable:no-any */
        return lodash.mergeWith({}, this._baseConfig, config, function (value1, value2) {
            /* tslint:enable:no-any */
            if (lodash.isArray(value1) && lodash.isArray(value2)) {
                return lodash.concat(value1, value2);
            }
            else {
                return undefined;
            }
        });
    };
    ConfigureWebpackTask.prototype._logNoEntriesWarning = function () {
        // @TODO: SPPPlat VSO 221536
        // this.logWarning('No entries are defined, so no bundles will be produced.');
    };
    ConfigureWebpackTask.prototype._setWebpackConfig = function (config) {
        var webpackTask = this.taskConfig.webpack;
        if (webpackTask) {
            webpackTask.setConfig({
                config: config,
                configPath: webpackTask.taskConfig.configPath
            });
        }
    };
    return ConfigureWebpackTask;
}(OdspGulpTask_1.default));
exports.ConfigureWebpackTask = ConfigureWebpackTask;

//# sourceMappingURL=ConfigureWebpackTask.js.map
