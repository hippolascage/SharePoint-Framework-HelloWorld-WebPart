"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
// Remove when V2 is 100% on
var shouldProduceV2Manifest = true;
var lodash_1 = require('lodash');
var fs = require('fs');
var merge = require('merge2');
var path = require('path');
var constants_1 = require('./../constants');
var FileUtils_1 = require('./../utilities/FileUtils');
var url = require('url');
var os_1 = require('os');
var Resolve_1 = require('./../utilities/Resolve');
var sp_module_interfaces_1 = require('@microsoft/sp-module-interfaces');
var manifestSchemaValidator_1 = require('@microsoft/sp-module-interfaces/lib/manifestSchemaValidator');
var OdspGulpTask_1 = require('./../OdspGulpTask');
var IsUrl_1 = require('./../utilities/IsUrl');
var cumulativeManifestProcessor_1 = require('./cumulativeManifest/cumulativeManifestProcessor');
var schemaPropertyName = '$schema';
/**
 * Writes a manifest for each entry in the project.
 *
 * Example:
 *  IN:
 *   the result of the prepareDeploy step enumerating each entry, each entry's dependencies, and a developer-generated
 *    base manifest for each entry.
 *
 *  OUT:
 *   a debug and, optionally, a production manifest for each entry.
 */
var WriteManifestsTask = (function (_super) {
    __extends(WriteManifestsTask, _super);
    function WriteManifestsTask() {
        _super.apply(this, arguments);
        this.name = 'writemanifests';
        this.taskConfig = {
            deployCdnPath: undefined,
            debugLocale: constants_1.default.defaultLocale,
            cdnUrlPrefix: undefined,
            cdnBasePath: undefined,
            shouldWrapProductionManifestForManifestServer: false,
            cumulativeManifestOptions: {
                ignoreOutputManifestIds: undefined
            }
        };
    }
    WriteManifestsTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.properties.deployEntries || this.properties.deployEntries.length === 0) {
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('No deploy entries specified. No manifests to write.');
            completeCallback();
            return;
        }
        var debugBasePath = this.taskConfig.debugBasePath ? this.taskConfig.debugBasePath() : undefined;
        var shouldProduceDebugManifests = !!debugBasePath;
        if (!debugBasePath) {
            this.logWarning('Debug base path not specified. Unable to produce debug manifests.');
        }
        var shouldProduceProductionManifests = this.buildConfig.production && !!this.taskConfig.cdnBasePath;
        if (this.buildConfig.production && !this.taskConfig.cdnBasePath) {
            this.logWarning('CDN base path not specified. Unable to produce production manifests.');
        }
        if (this.buildConfig.production && (!this.taskConfig.deployCdnPath || !this.taskConfig.deployCdnPath())) {
            shouldProduceProductionManifests = false;
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('CDN deploy path not specified. Unable to produce production manifests.');
        }
        var debugManifests = [];
        var manifestIds = {};
        var tasks = [];
        this.properties.deployEntries.forEach(function (deployEntry) {
            if (!deployEntry.manifest) {
                _this.logWarning("Manifest not defined for entry \"" + deployEntry.entryName + "\".");
                return;
            }
            var validationResult = manifestSchemaValidator_1.default.validateManifest(JSON.stringify(deployEntry.manifest));
            if (!validationResult.result) {
                var errorText = manifestSchemaValidator_1.default.getFormattedErrorMessage(validationResult.errors);
                _this.logError("Manifest validation error (" + deployEntry.bundleEntry.manifest + "): " + os_1.EOL + errorText);
                return;
            }
            // Ensure we don't have a duplicate ID
            var lowercaseId = deployEntry.manifest.id.toLowerCase();
            if (lowercaseId in manifestIds) {
                /* tslint:disable:max-line-length */
                _this.logError("Duplicate manifest ID \"" + lowercaseId + "\". Exists in \"" + manifestIds[lowercaseId].bundleEntry.manifest + "\" and \"" + deployEntry.bundleEntry.manifest + "\".");
            }
            else {
                manifestIds[lowercaseId] = deployEntry;
            }
            if (shouldProduceDebugManifests) {
                var loaderConfig = _this._generateLoaderConfig(deployEntry.debugModules, [debugBasePath], _this._resolveDebugPath.bind(_this), _this.taskConfig.debugLocale);
                var debugManifest = _this._generateManifest(deployEntry, loaderConfig);
                var isApplication = debugManifest.componentType === 'Application';
                if (isApplication) {
                    var preloadModules = _this._gatherPreloadManifestIds(deployEntry.debugModules);
                    _this._includePreloadManifestIds(preloadModules, debugManifest);
                }
                debugManifests.push(debugManifest);
                var finalDebugManifest = debugManifest;
                if (!shouldProduceV2Manifest) {
                    var moduleLoaderPath = void 0;
                    if (isApplication) {
                        try {
                            moduleLoaderPath = Resolve_1.resolvePackage('@microsoft/sp-module-loader', _this.buildConfig.rootPath);
                            moduleLoaderPath = path.join(moduleLoaderPath, 'dist', 'sp-module-loader.js');
                            moduleLoaderPath = path.relative(_this.buildConfig.rootPath, moduleLoaderPath);
                            var baseUrl = debugBasePath || 'http://localhost:4321';
                            moduleLoaderPath = "" + baseUrl + moduleLoaderPath.replace(/\\/g, '/');
                        }
                        catch (e) {
                            _this.log(("Unable to find module loader. SPAPPs created for application \"" + debugManifest.id + "\" ") +
                                'will not be loadable. Ensure your project depends on @microsoft/sp-module-loader');
                        }
                    }
                    finalDebugManifest = _this._wrapV2Manifest(debugManifest, moduleLoaderPath);
                }
                tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(debugManifest, undefined, 2), debugManifest.id + ".manifest.json")
                    .pipe(gulp.dest(_this.buildConfig.distFolder)));
            }
            if (shouldProduceProductionManifests) {
                var loaderConfig = _this._generateLoaderConfig(deployEntry.productionModules, [_this.taskConfig.cdnBasePath], _this._resolveProductionPath.bind(_this));
                var productionManifest = _this._generateManifest(deployEntry, loaderConfig);
                var loaderModulePath = _this._findModuleLoader();
                if (!loaderModulePath) {
                    if (deployEntry.manifest.componentType === 'Application') {
                        _this.logWarning('Unable to find the loader in the deploy CDN location. If this is an application, it ' +
                            'will not be loadable.');
                    }
                }
                else {
                    // @todo improve URL processing logic. VSO#215443
                    loaderModulePath = _this._resolveProductionPath(loaderModulePath);
                    var cdnBasePathUrl = url.parse(_this.taskConfig.cdnBasePath);
                    loaderModulePath = path.posix.join(cdnBasePathUrl.host || '', cdnBasePathUrl.path, loaderModulePath);
                    if (cdnBasePathUrl.protocol) {
                        loaderModulePath = cdnBasePathUrl.protocol + "//" + loaderModulePath;
                    }
                    else if (loaderModulePath.match(/^\/[^\/]/) && _this.taskConfig.cdnBasePath.match(/^\/\//)) {
                        loaderModulePath = "/" + loaderModulePath;
                    }
                }
                if (productionManifest.componentType === 'Application') {
                    var preloadModules = _this._gatherPreloadManifestIds(deployEntry.productionModules);
                    _this._includePreloadManifestIds(preloadModules, productionManifest);
                }
                var finalProductionManifest = shouldProduceV2Manifest
                    ? productionManifest
                    : _this._wrapV2Manifest(productionManifest, loaderModulePath);
                var cdnManifest = void 0;
                if (_this.taskConfig.shouldWrapProductionManifestForManifestServer) {
                    cdnManifest = {
                        ComponentType: finalProductionManifest.componentType,
                        Id: finalProductionManifest.id,
                        Manifest: JSON.stringify(finalProductionManifest),
                        Name: finalProductionManifest.id,
                        resources: {}
                    };
                }
                else {
                    cdnManifest = finalProductionManifest;
                }
                tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(cdnManifest), productionManifest.id + ".json")
                    .pipe(gulp.dest(_this.taskConfig.deployCdnPath())));
            }
        });
        if (shouldProduceDebugManifests) {
            var cumulativeManifestOptions = this.taskConfig.cumulativeManifestOptions;
            cumulativeManifestOptions.baseUrl = debugBasePath;
            var cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(cumulativeManifestOptions, this);
            tasks.push.apply(tasks, cumulativeManifestProcessor.generateCumulativeManifest(gulp, debugManifests));
        }
        return merge(tasks).on('finish', function () { return completeCallback(); });
    };
    /**
     * Temporary - until serverside changes go in
     */
    WriteManifestsTask.prototype._findModuleLoader = function () {
        var moduleLoaderRegex = /sp-module-loader_?[^_]*.js/i;
        var deployCdnFiles = fs.readdirSync(this.taskConfig.deployCdnPath());
        for (var _i = 0, deployCdnFiles_1 = deployCdnFiles; _i < deployCdnFiles_1.length; _i++) {
            var deployCdnFile = deployCdnFiles_1[_i];
            if (deployCdnFile.match(moduleLoaderRegex)) {
                return path.basename(deployCdnFile);
            }
        }
    };
    /**
     * Temporary - until serverside changes go in
     */
    WriteManifestsTask.prototype._wrapV2Manifest = function (v2Manifest, moduleLoaderPath) {
        var wrappedComponentType;
        switch (v2Manifest.componentType.toLowerCase()) {
            case 'library':
            case 'webpart':
                wrappedComponentType = 'WebPart';
                break;
            case 'application':
                wrappedComponentType = 'Application';
                break;
        }
        var v1Manifest = {
            id: v2Manifest.id,
            displayName: v2Manifest.id,
            version: v2Manifest.version,
            manifestVersion: 2,
            bootstrapModule: moduleLoaderPath,
            componentType: wrappedComponentType,
            properties: {
                manifest: JSON.stringify(v2Manifest)
            }
        };
        if (v2Manifest.componentType === 'Application') {
            var applicationManifest = v2Manifest;
            v1Manifest.preloadClientSideComponents = applicationManifest.preloadComponents;
            v1Manifest.preloadCommands = applicationManifest.preloadOptions;
        }
        return v1Manifest;
    };
    WriteManifestsTask.prototype._gatherPreloadManifestIds = function (deployModules) {
        var preloadIds = [];
        if (deployModules.frameworkModules) {
            deployModules.frameworkModules.forEach(function (_, id) {
                var standardLibraryModule = sp_module_interfaces_1.standardLibraryModules[id];
                if (standardLibraryModule && standardLibraryModule.preloadId) {
                    preloadIds.push(standardLibraryModule.preloadId);
                    if (standardLibraryModule.dependentIds && standardLibraryModule.dependentIds.length) {
                        preloadIds.push.apply(preloadIds, standardLibraryModule.dependentIds);
                    }
                }
            });
        }
        return preloadIds;
    };
    WriteManifestsTask.prototype._includePreloadManifestIds = function (preloadIds, manifest) {
        // This is V1 manifest wrapping a V2 manifest because a server change hasn't gone in yet, so we need to
        // add these to the wrapper's preload components. This implementation will change when V2 goes into the server.
        if (!manifest.preloadComponents) {
            manifest.preloadComponents = [];
        }
        for (var _i = 0, preloadIds_1 = preloadIds; _i < preloadIds_1.length; _i++) {
            var preloadId = preloadIds_1[_i];
            if (manifest.preloadComponents.indexOf(preloadId) === -1) {
                manifest.preloadComponents.push(preloadId);
            }
        }
    };
    WriteManifestsTask.prototype._generateManifest = function (deployEntry, loaderConfig) {
        var manifest = lodash_1.cloneDeep(deployEntry.manifest);
        delete manifest[schemaPropertyName];
        manifest.loaderConfig = loaderConfig;
        return manifest;
    };
    WriteManifestsTask.prototype._generateLoaderConfig = function (deployModules, internalModuleBaseUrls, resolvePath, defaultLocaleOverride) {
        // Ensure all internalModuleBaseUrls have a trailing slash
        for (var i = 0; i < internalModuleBaseUrls.length; i++) {
            var internalModuleBaseUrl = internalModuleBaseUrls[i];
            if (!internalModuleBaseUrl.match(/\/$/)) {
                internalModuleBaseUrls[i] = internalModuleBaseUrl + "/";
            }
        }
        var scriptResources = {};
        if (deployModules.internalModules) {
            deployModules.internalModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'internal';
                scriptResources[id] = module;
                module.path = resolvePath(module.path);
            });
        }
        if (deployModules.localizedModules) {
            deployModules.localizedModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'localized';
                scriptResources[id] = module;
                for (var locale in module.paths) {
                    module.paths[locale] = resolvePath(module.paths[locale]);
                }
                if (defaultLocaleOverride && defaultLocaleOverride in module.paths) {
                    module.defaultPath = module.paths[defaultLocaleOverride];
                    delete module.paths;
                }
                else {
                    module.defaultPath = resolvePath(module.defaultPath);
                }
            });
        }
        if (deployModules.frameworkModules) {
            deployModules.frameworkModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'framework';
                scriptResources[id] = module;
                if (module.failoverPath) {
                    module.failoverPath = resolvePath(module.failoverPath);
                }
            });
        }
        if (!(deployModules.entryModuleId in scriptResources)) {
            this.logError(("Entry module \"" + deployModules.entryModuleId + "\" is missing a definition. The manifest will not ") +
                'load');
        }
        var result = {
            entryModuleId: deployModules.entryModuleId,
            internalModuleBaseUrls: internalModuleBaseUrls,
            scriptResources: scriptResources
        };
        return result;
    };
    WriteManifestsTask.prototype._resolveDebugPath = function (assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            // If this is a full URL, don't change it
            if (IsUrl_1.default(assetPath)) {
                return assetPath;
            }
            else {
                return path.relative(this.buildConfig.rootPath, assetPath).replace(/\\/g, '/');
            }
        }
        else {
            return {
                default: this._resolveDebugPath(assetPath.default),
                debug: this._resolveDebugPath(assetPath.debug)
            };
        }
    };
    WriteManifestsTask.prototype._resolveProductionPath = function (assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            var assetPathStr = assetPath;
            if (assetPathStr.charAt(0) === '/') {
                assetPathStr = assetPathStr.substr(1);
            }
            // If this is a full URL, don't change it
            if (IsUrl_1.default(assetPathStr)) {
                return assetPathStr;
            }
            else if (this.taskConfig.cdnUrlPrefix) {
                return path.posix.join(this.taskConfig.cdnUrlPrefix, assetPathStr);
            }
            else {
                return assetPathStr;
            }
        }
        else {
            return {
                default: this._resolveProductionPath(assetPath.default),
                debug: this._resolveProductionPath(assetPath.debug)
            };
        }
    };
    return WriteManifestsTask;
}(OdspGulpTask_1.default));
exports.WriteManifestsTask = WriteManifestsTask;

//# sourceMappingURL=WriteManifestsTask.js.map
