"use strict";
var Url = require('url');
var path = require('path');
var fs = require('fs');
var lodash_1 = require('lodash');
var FileUtils_1 = require('./../../utilities/FileUtils');
var Resolve_1 = require('./../../utilities/Resolve');
var Webpack = require('webpack');
var webpackStream = require('webpack-stream');
var manifestsLoader = require('./manifests-loader');
var cumulativeManifestFileName = 'manifests';
var CumulativeManifestProcessor = (function () {
    function CumulativeManifestProcessor(options, parentTask) {
        this._options = options;
        this._parentTask = parentTask;
    }
    /**
     * Ths function:
     *  1. discovers all packages referenced in package.json
     *  2a. looks for a file in each discovered project's temp folder called manifests.json
     *  2b. looks for <id>.manifest.json files in the dist folder
     *  3. keeps a record of all of the manifests discovered in thereferenced projects, and resolves duplicates by
     *      taking the newest file
     *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
     *      is run from this current project's directory
     *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
     *      manifests
     *  6. filters this array by the ignoreOutputManifestIds options
     *  7. drops a JSON file in the temp directory called manifests.json containing this array
     *  9. drops an initialization script in the temp directory called manifests.js that
     *      exports two functions. One that retruns the array with the manifests' base URLs as fully-qualified, and the
     *      other with manifests' base URLs as relative to the page root.
     */
    CumulativeManifestProcessor.prototype.generateCumulativeManifest = function (gulp, debugManifests) {
        var _this = this;
        if (!this._options) {
            this._parentTask.logVerbose('No cumulative manifest options specified. Skipping cumulative manifest generation.');
            return;
        }
        var referencedProjectManifests = this._discoverManifestsForPackage(this._parentTask.buildConfig.rootPath, true);
        var result = [];
        var baseUrl = this._options.baseUrl || 'http://localhost:4321'; // Default if one isn't already defined
        var manifests = {};
        for (var id in referencedProjectManifests) {
            if (!this._options.ignoreOutputManifestIds || this._options.ignoreOutputManifestIds.indexOf(id) === -1) {
                manifests[id] = referencedProjectManifests[id].manifestData(baseUrl);
            }
        }
        debugManifests.forEach(function (manifest) {
            if (!_this._options.ignoreOutputManifestIds || _this._options.ignoreOutputManifestIds.indexOf(manifest.id) === -1) {
                manifests[manifest.id] = manifest;
            }
        });
        var manifestsArray = Object.keys(manifests).map(function (id) { return manifests[id]; });
        // Write the manifests.json file
        result.push(FileUtils_1.writeStringToFile(JSON.stringify(manifestsArray, undefined, 2), cumulativeManifestFileName + ".json")
            .pipe(gulp.dest(this._parentTask.buildConfig.tempFolder)));
        // Write the manifests.js file
        manifestsLoader.manifestObject = manifestsArray;
        result.push(gulp.src(path.join(__dirname, 'manifestsFile.js'))
            .pipe(webpackStream({
            output: {
                library: 'debugManifests',
                path: path.join(this._parentTask.buildConfig.rootPath, this._parentTask.buildConfig.tempFolder),
                filename: cumulativeManifestFileName + ".js"
            },
            resolveLoader: {
                root: __dirname,
                alias: undefined
            },
            plugins: [
                new Webpack.optimize.UglifyJsPlugin({
                    compress: {
                        dead_code: true,
                        warnings: false
                    },
                    mangle: true
                })
            ]
        }, undefined, function (error, stats) {
            if (error) {
                _this._parentTask.logError("Error generating cumulative manifest: " + error.toString());
            }
        }))
            .pipe(gulp.dest(this._parentTask.buildConfig.tempFolder)));
        return result;
    };
    CumulativeManifestProcessor.prototype._discoverManifestsForPackage = function (packagePath, forceSearch) {
        var _this = this;
        if (forceSearch === void 0) { forceSearch = false; }
        var referencedProjectManifests = {};
        var tempPath = path.join(packagePath, 'temp');
        var distPath = path.join(packagePath, 'dist');
        // We want to make sure if we have multiple files with the same component's manifest, we pick the one that
        //  was generated most recently.
        var fileModifiedtime = 0;
        var linkedProjectManifests = undefined;
        var foundCumulativeManifestsFile = false;
        if (!forceSearch) {
            try {
                var manifestMapPath = path.join(tempPath, cumulativeManifestFileName + ".json");
                var fileStats = fs.statSync(manifestMapPath);
                fileModifiedtime = fileStats.mtime.getTime();
                linkedProjectManifests = lodash_1.cloneDeep(require(manifestMapPath));
                foundCumulativeManifestsFile = true;
            }
            catch (e) {
                this._parentTask.logVerbose(("Unable to get \"manifests.json\" file for project in \"" + packagePath + "\". We'll ") +
                    'try to get each manifest seperately');
            }
            // If we didn't find a manifests.json file, we should look for individual <id>.manifest.json files.
            if (!linkedProjectManifests) {
                linkedProjectManifests = [];
                // Look for files called something like "abc123.manifest.json" without any leading slashes or extra periods
                var manifestFileRegExp_1 = /^[^\.\\\/]+\.manifest\.json$/;
                try {
                    fs.readdirSync(distPath).forEach(function (distFilename) {
                        if (distFilename.match(manifestFileRegExp_1)) {
                            try {
                                var distFilePath = path.join(distPath, distFilename);
                                var fileStats = fs.statSync(distFilePath);
                                var manifestData = lodash_1.cloneDeep(require(distFilePath));
                                linkedProjectManifests.push(manifestData);
                                fileModifiedtime = Math.max(fileModifiedtime, fileStats.mtime.getTime());
                            }
                            catch (e) {
                            }
                        }
                    });
                }
                catch (e) {
                }
            }
        }
        if (!foundCumulativeManifestsFile && (forceSearch || linkedProjectManifests.length > 0)) {
            // If this project has manifests, or we're forcing search, let's look in its references in other projects
            var packages_1 = new Map();
            try {
                var packageJson = require(path.join(packagePath, 'package.json'));
                var getPackages = function (refs, optional) {
                    if (refs) {
                        for (var packageName in refs) {
                            if (refs.hasOwnProperty(packageName)) {
                                packages_1.set(packageName, optional);
                            }
                        }
                    }
                };
                getPackages(packageJson.dependencies, false);
                getPackages(packageJson.devDependencies, true);
                getPackages(packageJson.optionalDependencies, true);
            }
            catch (e) {
            }
            // Search each referenced project for manifests
            packages_1.forEach(function (optional, packageName) {
                var referencedPackagePath;
                try {
                    referencedPackagePath = Resolve_1.resolvePackage(packageName, packagePath);
                }
                catch (e) { }
                if (referencedPackagePath) {
                    var manifests = _this._discoverManifestsForPackage(referencedPackagePath);
                    for (var manifestId in manifests) {
                        if (manifests.hasOwnProperty(manifestId)) {
                            referencedProjectManifests[manifestId] = manifests[manifestId];
                        }
                    }
                }
                else if (!optional) {
                    // Only warn if this isn't an optional package
                    _this._parentTask.logWarning(("Unable to resolve project \"" + packageName + "\". ") +
                        'Ensure it has been linked.');
                }
            });
        }
        // If we found any manifests directly linked to this project, merge them into the manifests discovered in other
        // projects
        if (linkedProjectManifests) {
            var _loop_1 = function(manifest) {
                var id = manifest.id;
                var existingManifest = referencedProjectManifests[id];
                if (!existingManifest || fileModifiedtime > existingManifest.manifestCreationTime) {
                    // Only update if this manifest is newer.
                    referencedProjectManifests[id] = {
                        manifestCreationTime: fileModifiedtime,
                        manifestData: function (baseUrl) {
                            var relativePath = path.relative(_this._parentTask.buildConfig.rootPath, packagePath);
                            var baseUrls = manifest.loaderConfig.internalModuleBaseUrls
                                ? manifest.loaderConfig.internalModuleBaseUrls
                                : (manifest.loaderConfig.internalModuleBaseUrls = []);
                            var url = baseUrl + "/" + encodeURI(relativePath.replace(/\\/g, '/')) + "/";
                            if (baseUrls.length > 0) {
                                var existingUrl = Url.parse(baseUrls[0]);
                                baseUrls[0] = "" + url + existingUrl.pathname;
                            }
                            else {
                                baseUrls[0] = url;
                            }
                            var baseUrlObject = Url.parse(baseUrls[0]);
                            baseUrlObject.pathname = baseUrlObject.pathname.replace(/\/\//g, '/');
                            baseUrls[0] = Url.format(baseUrlObject);
                            return manifest;
                        }
                    };
                }
            };
            for (var _i = 0, linkedProjectManifests_1 = linkedProjectManifests; _i < linkedProjectManifests_1.length; _i++) {
                var manifest = linkedProjectManifests_1[_i];
                _loop_1(manifest);
            }
        }
        return referencedProjectManifests;
    };
    return CumulativeManifestProcessor;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CumulativeManifestProcessor;

//# sourceMappingURL=cumulativeManifestProcessor.js.map
