{"version":3,"sources":["writeManifests/cumulativeManifest/cumulativeManifestProcessor.ts"],"names":[],"mappings":"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","file":"writeManifests/cumulativeManifest/cumulativeManifestProcessor.js","sourcesContent":["import * as Url from 'url';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nimport * as gulp from 'gulp';\r\nimport { cloneDeep } from 'lodash';\r\nimport { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';\r\nimport { GulpTask } from 'gulp-core-build';\r\nimport { writeStringToFile } from './../../utilities/FileUtils';\r\nimport { resolvePackage } from './../../utilities/Resolve';\r\nimport * as Webpack from 'webpack';\r\nimport webpackStream = require('webpack-stream');\r\n\r\nimport manifestsLoader = require('./manifests-loader');\r\n\r\nconst cumulativeManifestFileName: string = 'manifests';\r\n\r\nexport interface ICumulativeManifestOptions {\r\n  /**\r\n   * IDs of manifests to exclude from the manifest map file.\r\n   */\r\n  ignoreOutputManifestIds?: string[];\r\n\r\n  /**\r\n   * The base path for debug manifests. Expected to match the result of the \"debugBasePath\" function passed to the\r\n   *  WriteManifestsTask task.\r\n   */\r\n  baseUrl?: string;\r\n}\r\n\r\ninterface IReferencedProjectManifest {\r\n  /**\r\n   * The creation time of the newest version of this manifest we've found\r\n   */\r\n  manifestCreationTime: number;\r\n\r\n  /**\r\n   * A function that will return a manifest with the appropriately transformed base URL. The function takes\r\n   *  the current base URL.\r\n   */\r\n  manifestData: (baseUrl: string) => IClientSideComponentManifest;\r\n}\r\n\r\ninterface IReferenceContainer {\r\n  [packageName: string]: string;\r\n}\r\n\r\nexport default class CumulativeManifestProcessor {\r\n  private _options: ICumulativeManifestOptions;\r\n  private _parentTask: GulpTask<{}>;\r\n\r\n  constructor(options: ICumulativeManifestOptions, parentTask: GulpTask<{}>) {\r\n    this._options = options;\r\n    this._parentTask = parentTask;\r\n  }\r\n\r\n  /**\r\n   * Ths function:\r\n   *  1. discovers all packages referenced in package.json\r\n   *  2a. looks for a file in each discovered project's temp folder called manifests.json\r\n   *  2b. looks for <id>.manifest.json files in the dist folder\r\n   *  3. keeps a record of all of the manifests discovered in thereferenced projects, and resolves duplicates by\r\n   *      taking the newest file\r\n   *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when \"gulp serve\"\r\n   *      is run from this current project's directory\r\n   *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all\r\n   *      manifests\r\n   *  6. filters this array by the ignoreOutputManifestIds options\r\n   *  7. drops a JSON file in the temp directory called manifests.json containing this array\r\n   *  9. drops an initialization script in the temp directory called manifests.js that\r\n   *      exports two functions. One that retruns the array with the manifests' base URLs as fully-qualified, and the\r\n   *      other with manifests' base URLs as relative to the page root.\r\n   */\r\n  public generateCumulativeManifest(gulp: gulp.Gulp,\r\n                                    debugManifests: IClientSideComponentManifest[]): NodeJS.ReadWriteStream[] {\r\n    if (!this._options) {\r\n      this._parentTask.logVerbose('No cumulative manifest options specified. Skipping cumulative manifest generation.');\r\n      return;\r\n    }\r\n\r\n    const referencedProjectManifests: { [id: string]: IReferencedProjectManifest } =\r\n      this._discoverManifestsForPackage(this._parentTask.buildConfig.rootPath, true);\r\n\r\n    const result: NodeJS.ReadWriteStream[] = [];\r\n\r\n    const baseUrl: string = this._options.baseUrl || 'http://localhost:4321'; // Default if one isn't already defined\r\n\r\n    const manifests: { [id: string]: IClientSideComponentManifest } = {};\r\n    for (const id in referencedProjectManifests) {\r\n      if (!this._options.ignoreOutputManifestIds || this._options.ignoreOutputManifestIds.indexOf(id) === -1) {\r\n        manifests[id] = referencedProjectManifests[id].manifestData(baseUrl);\r\n      }\r\n    }\r\n\r\n    debugManifests.forEach((manifest: IClientSideComponentManifest) => {\r\n      if (!this._options.ignoreOutputManifestIds || this._options.ignoreOutputManifestIds.indexOf(manifest.id) === -1) {\r\n        manifests[manifest.id] = manifest;\r\n      }\r\n    });\r\n\r\n    const manifestsArray: IClientSideComponentManifest[] = Object.keys(manifests).map((id: string) => manifests[id]);\r\n\r\n    // Write the manifests.json file\r\n    result.push(writeStringToFile(JSON.stringify(manifestsArray, undefined, 2),\r\n                                  `${cumulativeManifestFileName}.json`)\r\n                  .pipe(gulp.dest(this._parentTask.buildConfig.tempFolder)));\r\n\r\n    // Write the manifests.js file\r\n    manifestsLoader.manifestObject = manifestsArray;\r\n    result.push(gulp.src(path.join(__dirname, 'manifestsFile.js'))\r\n                    .pipe(webpackStream({\r\n                      output: {\r\n                        library: 'debugManifests',\r\n                        path: path.join(this._parentTask.buildConfig.rootPath, this._parentTask.buildConfig.tempFolder),\r\n                        filename: `${cumulativeManifestFileName}.js`\r\n                      },\r\n                      resolveLoader: {\r\n                        root: __dirname,\r\n                        alias: undefined\r\n                      },\r\n                      plugins: [\r\n                        new Webpack.optimize.UglifyJsPlugin({\r\n                          compress: {\r\n                            dead_code: true,\r\n                            warnings: false\r\n                          },\r\n                          mangle: true\r\n                        })\r\n                      ]\r\n                    },\r\n                    undefined,\r\n                    (error: Error, stats: Webpack.compiler.Stats) => {\r\n                      if (error) {\r\n                        this._parentTask.logError(`Error generating cumulative manifest: ${error.toString()}`);\r\n                      }\r\n                    }))\r\n                    .pipe(gulp.dest(this._parentTask.buildConfig.tempFolder)));\r\n\r\n    return result;\r\n  }\r\n\r\n  private _discoverManifestsForPackage(packagePath: string, forceSearch: boolean = false):\r\n      { [id: string]: IReferencedProjectManifest } {\r\n    const referencedProjectManifests: { [id: string]: IReferencedProjectManifest } = {};\r\n\r\n    const tempPath: string = path.join(packagePath, 'temp');\r\n    const distPath: string = path.join(packagePath, 'dist');\r\n\r\n    // We want to make sure if we have multiple files with the same component's manifest, we pick the one that\r\n    //  was generated most recently.\r\n    let fileModifiedtime: number = 0;\r\n    let linkedProjectManifests: IClientSideComponentManifest[] = undefined;\r\n    let foundCumulativeManifestsFile: boolean = false;\r\n    if (!forceSearch) {\r\n      try {\r\n        const manifestMapPath: string = path.join(tempPath, `${cumulativeManifestFileName}.json`);\r\n        const fileStats: fs.Stats = fs.statSync(manifestMapPath);\r\n        fileModifiedtime = fileStats.mtime.getTime();\r\n        linkedProjectManifests = cloneDeep(require(manifestMapPath));\r\n        foundCumulativeManifestsFile = true;\r\n      } catch (e) {\r\n        this._parentTask.logVerbose(`Unable to get \"manifests.json\" file for project in \"${packagePath}\". We'll ` +\r\n                                    'try to get each manifest seperately');\r\n      }\r\n\r\n      // If we didn't find a manifests.json file, we should look for individual <id>.manifest.json files.\r\n      if (!linkedProjectManifests) {\r\n        linkedProjectManifests = [];\r\n        // Look for files called something like \"abc123.manifest.json\" without any leading slashes or extra periods\r\n        const manifestFileRegExp: RegExp = /^[^\\.\\\\\\/]+\\.manifest\\.json$/;\r\n        try {\r\n          fs.readdirSync(distPath).forEach((distFilename: string) => {\r\n            if (distFilename.match(manifestFileRegExp)) {\r\n              try {\r\n                const distFilePath: string = path.join(distPath, distFilename);\r\n                const fileStats: fs.Stats = fs.statSync(distFilePath);\r\n                const manifestData: IClientSideComponentManifest = cloneDeep(require(distFilePath));\r\n                linkedProjectManifests.push(manifestData);\r\n                fileModifiedtime = Math.max(fileModifiedtime, fileStats.mtime.getTime());\r\n              } catch (e) {\r\n                /* empty */\r\n              }\r\n            }\r\n          });\r\n        } catch (e) {\r\n          /* Error getting manifest file data */\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!foundCumulativeManifestsFile && (forceSearch || linkedProjectManifests.length > 0)) {\r\n      // If this project has manifests, or we're forcing search, let's look in its references in other projects\r\n      const packages: Map<string, boolean> = new Map<string, boolean>();\r\n      try {\r\n        const packageJson: PackageJson = require(path.join(packagePath, 'package.json'));\r\n\r\n        const getPackages: (refs: IReferenceContainer, optional: boolean) => void =\r\n                           (refs: IReferenceContainer, optional: boolean) => {\r\n          if (refs) {\r\n            for (const packageName in refs) {\r\n              if (refs.hasOwnProperty(packageName)) {\r\n                packages.set(packageName, optional);\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        getPackages(packageJson.dependencies, false);\r\n        getPackages(packageJson.devDependencies, true);\r\n        getPackages(packageJson.optionalDependencies, true);\r\n      } catch (e) {\r\n        /* empty */\r\n      }\r\n\r\n      // Search each referenced project for manifests\r\n      packages.forEach((optional: boolean, packageName: string) => {\r\n        let referencedPackagePath: string;\r\n        try {\r\n          referencedPackagePath = resolvePackage(packageName, packagePath);\r\n        } catch (e) { /* empty */ }\r\n\r\n        if (referencedPackagePath) {\r\n          const manifests: { [id: string]: IReferencedProjectManifest } =\r\n            this._discoverManifestsForPackage(referencedPackagePath);\r\n\r\n          for (const manifestId in manifests) {\r\n            if (manifests.hasOwnProperty(manifestId)) {\r\n              referencedProjectManifests[manifestId] = manifests[manifestId];\r\n            }\r\n          }\r\n        } else if (!optional) {\r\n          // Only warn if this isn't an optional package\r\n          this._parentTask.logWarning(`Unable to resolve project \"${packageName}\". ` +\r\n                                      'Ensure it has been linked.');\r\n        }\r\n      });\r\n    }\r\n\r\n    // If we found any manifests directly linked to this project, merge them into the manifests discovered in other\r\n    // projects\r\n    if (linkedProjectManifests) {\r\n      for (const manifest of linkedProjectManifests) {\r\n        const id: string = manifest.id;\r\n        const existingManifest: IReferencedProjectManifest = referencedProjectManifests[id];\r\n        if (!existingManifest || fileModifiedtime > existingManifest.manifestCreationTime) {\r\n          // Only update if this manifest is newer.\r\n          referencedProjectManifests[id] = {\r\n            manifestCreationTime: fileModifiedtime,\r\n            manifestData: (baseUrl: string): IClientSideComponentManifest => {\r\n              const relativePath: string = path.relative(this._parentTask.buildConfig.rootPath, packagePath);\r\n\r\n              const baseUrls: string[] = manifest.loaderConfig.internalModuleBaseUrls\r\n                  ? manifest.loaderConfig.internalModuleBaseUrls\r\n                  : (manifest.loaderConfig.internalModuleBaseUrls = []);\r\n\r\n              const url: string = `${baseUrl}/${encodeURI(relativePath.replace(/\\\\/g, '/'))}/`;\r\n              if (baseUrls.length > 0) {\r\n                const existingUrl: Url.Url = Url.parse(baseUrls[0]);\r\n                baseUrls[0] = `${url}${existingUrl.pathname}`;\r\n              } else {\r\n                baseUrls[0] = url;\r\n              }\r\n\r\n              const baseUrlObject: Url.Url = Url.parse(baseUrls[0]);\r\n              baseUrlObject.pathname = baseUrlObject.pathname.replace(/\\/\\//g, '/');\r\n              baseUrls[0] = Url.format(baseUrlObject);\r\n\r\n              return manifest;\r\n            }\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return referencedProjectManifests;\r\n  }\r\n}"],"sourceRoot":"/source/"}