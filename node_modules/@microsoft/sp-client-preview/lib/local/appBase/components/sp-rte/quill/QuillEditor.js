/**
 * @copyright Microsoft Corporation. All rights reserved.
 */
"use strict";
var QuillLoader_1 = require('./QuillLoader');
var CanvasStrings_resx_1 = require('../../sp-canvas/loc/CanvasStrings.resx');
/**
 * Implmentation of ISPRteQuillIntegration for Quill 0.20.1
 */
var QuillEditor = (function () {
    /**
     * Use createNewEditor instead of constructor to ensure using the editor after it's loaded
     * Note: TypeScript doesn't allow private constructors
     */
    function QuillEditor(config, currentHTML, editorElement, selectionChangeCallback, textChangeCallback) {
        this._config = config;
        this._editorElement = editorElement;
        this._findWrappingElementByTagName = this._findWrappingElementByTagName.bind(this);
        this._handleSelectionChange = selectionChangeCallback;
        this._handleTextChange = textChangeCallback;
        this.focus = this.focus.bind(this);
        this.format = this.format.bind(this);
        this.getSelection = this.getSelection.bind(this);
        this._initialize(currentHTML);
    }
    /**
     * @return Promise of the instance that resolves once the editor is loaded on the element
     *
     * Static wrapper for constructing an instance
     */
    QuillEditor.createNewEditor = function (config, currentHTML, editorElement, selectionChangeCallback, textChangeCallback) {
        return new Promise(function (resolve) {
            QuillEditor.moduleLoader.loadModule().then(function () {
                var editor = new QuillEditor(config, currentHTML, editorElement, selectionChangeCallback, textChangeCallback);
                resolve(editor);
            });
        });
    };
    QuillEditor.prototype.destroy = function () {
        if (this._quill) {
            var previousHTML = this._quill.destroy();
            this._quill = undefined;
            return previousHTML;
        }
        return undefined;
    };
    /**
     * @param start - Start position of selection
     * @param end - End position of selection
     * @param formats - Map of key:value pairs for formats to apply
     * @param applyAllFormatsToLine - Forces all formats to be applied to the whole line(s). If not provided,
     * formats are divided into two buckets (line vs non-line) based on their isLine field
     *
     * A unified method for applying Quill formats to any selection
     */
    QuillEditor.prototype.format = function (start, end, formats, applyAllFormatsToLine) {
        var lineFormats = applyAllFormatsToLine ? formats : {};
        var nonLineFormats = {};
        if (!applyAllFormatsToLine) {
            // Divide formats into two buckets: Line and Non-Line
            /* tslint:disable */
            var _loop_1 = function(formateditorKey) {
                /* tslint:enable */
                var format = this_1._config.supportedFormatsArray
                    .filter(function (format) { return format.editorKey === formateditorKey; })[0];
                if (format.isLine) {
                    lineFormats[format.editorKey] = formats[format.editorKey];
                }
                else {
                    nonLineFormats[format.editorKey] = formats[format.editorKey];
                }
            };
            var this_1 = this;
            for (var formateditorKey in formats) {
                _loop_1(formateditorKey);
            }
        }
        /* Apply line formats: If there is a newline character at the end of the selection, Quill.formatLine
        formats an extra line. We don't want the extra line by design so we remove the last character if
        it's a newline character */
        var firstLineOffset = this._quill.editor.doc.findLineAt(start)[1];
        var _a = this._quill.editor.doc.findLineAt(end), lastLine = _a[0], lastLineOffset = _a[1];
        var startOfFirstLine = start - firstLineOffset;
        var endOfLastLine = (start !== end && lastLineOffset === 0) ? end - 1 : end + lastLine.length - lastLineOffset - 1;
        this._quill.formatLine(startOfFirstLine, endOfLastLine, lineFormats);
        if (!applyAllFormatsToLine) {
            // Apply Non-Line formats
            /* tslint:disable */
            if (nonLineFormats.hasOwnProperty('link') &&
                this.isFormatAppliedToRange(start, end, this._config.formats.get('link'))) {
                // There is already a link on the selection, remove or edit it
                if (start === end) {
                    var linkElement = this._findWrappingElementByTagName(start, 'A');
                    if (linkElement) {
                        if (nonLineFormats['link']) {
                            linkElement.setAttribute('href', nonLineFormats['link']);
                            linkElement.setAttribute('target', '_blank');
                        }
                        else {
                            var container = linkElement.parentElement;
                            if (container) {
                                var textNode = document.createTextNode(linkElement.textContent);
                                container.insertBefore(textNode, linkElement);
                                container.removeChild(linkElement);
                            }
                        }
                        nonLineFormats['link'] = undefined;
                    }
                }
                else if (nonLineFormats['link']) {
                    // Edit link on non-collapsed selection
                    var linkElement = void 0;
                    var linkAtEnd = this._findWrappingElementByTagName(end, 'A');
                    // If the selection size is larger than 1, make sure the whole selection is on the same link
                    if (end - start > 1) {
                        var linkAtStart = this._findWrappingElementByTagName(start + 1, 'A');
                        linkElement = linkAtStart && linkAtEnd && linkAtStart.isEqualNode(linkAtEnd) ? linkAtEnd : undefined;
                    }
                    else {
                        linkElement = linkAtEnd;
                    }
                    if (linkElement) {
                        linkElement.setAttribute('href', nonLineFormats['link']);
                        linkElement.setAttribute('target', '_blank');
                        nonLineFormats['link'] = undefined;
                    }
                }
            }
            if (start === end) {
                for (var format in nonLineFormats) {
                    if (format === 'bold' || format === 'italic' || format === 'underline') {
                        this._quill.prepareFormat(format, nonLineFormats[format]);
                    }
                }
            }
            else {
                this._quill.formatText(start, end, nonLineFormats);
                if (nonLineFormats.hasOwnProperty('link') && nonLineFormats['link']) {
                    var linkElement = this._findWrappingElementByTagName(end, 'A');
                    if (linkElement) {
                        linkElement.setAttribute('target', '_blank');
                    }
                }
            }
        }
        /* tslint:enable */
    };
    QuillEditor.prototype.getBounds = function (position) {
        return this._quill.getBounds(position);
    };
    QuillEditor.prototype.getSelection = function () {
        return this._quill.getSelection();
    };
    QuillEditor.prototype.getText = function (range) {
        return range ?
            this._quill.getText(range.start, range.end) :
            this._quill.getText();
    };
    QuillEditor.prototype.getHTML = function () {
        return this._quill.getHTML();
    };
    QuillEditor.prototype.getFormatValue = function (start, end, format) {
        if (format.key === 'link') {
            var linkElement = void 0;
            var linkAtEnd = this._findWrappingElementByTagName(end, 'A');
            // If the selection size is larger than 1, make sure the whole selection is on the same link
            if (end - start > 1) {
                var linkAtStart = this._findWrappingElementByTagName(start + 1, 'A');
                linkElement = linkAtStart && linkAtEnd && linkAtStart.isEqualNode(linkAtEnd) ? linkAtEnd : undefined;
            }
            else {
                linkElement = linkAtEnd;
            }
            return linkElement ? linkAtEnd.getAttribute('href') : undefined;
        }
        else {
            return this.isFormatAppliedToRange(start, end, format);
        }
    };
    /**
     * @param format - Name of the format to apply from QUILL_FORMATS or SPRTE_FORMATS
     * @param start - Start value of range
     * @param end - End value of range
     *
     * @return A dictionary of string=>boolean indicating if the format is applied to the given range
     */
    QuillEditor.prototype.isFormatAppliedToRange = function (start, end, format) {
        var canBrowserHandle = !!format.browserKey;
        /* Chrome has a bug that returns true for bold, italic, underline if an empty line is selected
        We temporarily add this block to use Quill for those formats until the issue is fixed.
        Issue filed at: https://bugs.chromium.org/p/chromium/issues/detail?id=606047 */
        if (start !== end && ['bold', 'italic', 'underline'].indexOf(format.key) !== -1) {
            canBrowserHandle = false;
        }
        // IE and FF don't support justification commands, use Quill API instead
        if (['alignCenter', 'alignLeft', 'alignRight'].indexOf(format.key) !== -1) {
            var line = this._quill.editor.doc.findLineAt(end)[0];
            if (line.delta.ops.length > 0) {
                /* tslint:disable */
                // The align attribute is always set in last delta attributes because it contains the newline character
                var attributes = line.delta.ops[line.delta.ops.length - 1].attributes;
                // @todo #188988: default alignment should match locale (LTR vs RTL)
                var textAlign = attributes && attributes.align ? attributes.align : 'left';
                /* tslint:disable */
                if (format.key === 'alignCenter') {
                    return textAlign === 'center';
                }
                else if (format.key === 'alignLeft') {
                    return textAlign === 'left';
                }
                else if (format.key === 'alignRight') {
                    return textAlign === 'right';
                }
            }
        }
        // If the format can't be handled by browser use Quill to find active formats
        if (!canBrowserHandle) {
            // If the selection is collapsed, check the last character
            start = start === end ? Math.max(0, end - 1) : start;
            var activeFormats = this._getActiveFormatsInRange(start, end, format.isLine);
            return (format.isLine || start === 0) ?
                !!activeFormats.get(format.key) :
                activeFormats.get('count') === activeFormats.get(format.key);
        }
        else {
            return document.queryCommandState(format.browserKey);
        }
    };
    QuillEditor.prototype.setSelection = function (range) {
        this._quill.setSelection(range.start, range.end);
    };
    QuillEditor.prototype.focus = function () {
        // Use setActive() instead of focus() if available, because focus() scrolls to view in IE
        if (this._quillEditorElement && this._quillEditorElement.setActive) {
            this._quillEditorElement.setActive();
        }
        else {
            this._quill.focus();
        }
    };
    QuillEditor.prototype._findWrappingElementByTagName = function (position, tagName) {
        var leafNode = this._quill.editor.doc.findLeafAt(Math.max(0, position - 1))[0].node;
        /* Move up the dom tree until find the first node with the given tag name or reach the editor element
        Note: Use .parentNode instead of .parentElement, because IE doesn't have .parentElement on text nodes */
        var parentNode = leafNode.parentNode;
        while (parentNode && parentNode.tagName !== tagName && !parentNode.isEqualNode(this._editorElement)) {
            parentNode = parentNode.parentNode;
        }
        return parentNode.tagName === tagName ? parentNode : undefined;
    };
    /**
     * @param start - start value of a selection
     * @param end - end value of a selection
     *
     * Find and calculate all the non-sequential formattings in a selection.
     *
     * @return A dictionary mapping of format to non-sequential occurrences in the range of start to end
     */
    QuillEditor.prototype._getActiveFormatsInRange = function (start, end, isLine) {
        if (isLine === void 0) { isLine = false; }
        start = start === end ? Math.max(0, end - 1) : start;
        /* tslint:disable:no-any */
        var contentAttributes;
        /* tslint:enable:no-any */
        if (isLine) {
            var line = this._quill.editor.doc.findLineAt(end)[0];
            contentAttributes = line ? line.delta.ops : [];
        }
        else {
            contentAttributes = this._quill.getContents(start, end).ops;
        }
        /* The length of contentAttributes is the number of non-sequential formatting parts in the selection.
           Keeping track of count for the special case of formatting an entire selection where only a portion
           of the selection is formatted with a given format. */
        var attrDict = new Map([['count', contentAttributes.length]]);
        var formats = this._config.supportedFormatsArray.map(function (format) { return format.key; });
        for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {
            var format = formats_1[_i];
            attrDict.set(format, 0);
        }
        for (var _a = 0, contentAttributes_1 = contentAttributes; _a < contentAttributes_1.length; _a++) {
            var op = contentAttributes_1[_a];
            // op.attributes can be undefined if the chunk is unformatted
            if (op.attributes) {
                for (var attr in op.attributes) {
                    // Verify the attribute is a recognized format
                    if (attrDict.has(attr)) {
                        attrDict.set(attr, attrDict.get(attr) + 1);
                    }
                }
            }
        }
        return attrDict;
    };
    /**
     * Initialize Quill with whitelist of formats, prevent default css,
     * add custom formats, and registering event handlers.
     */
    QuillEditor.prototype._initialize = function (currentHTML) {
        var _this = this;
        QuillEditor.moduleLoader.loadModule().then(function (quillModule) {
            if (!QuillEditor.quillDelta) {
                QuillEditor.quillDelta = quillModule.require('delta');
            }
            if (!QuillEditor.quillDocument) {
                QuillEditor.quillDocument = quillModule.require('document');
            }
            var quillFormatKeys = _this._config.supportedFormatsArray
                .filter(function (format) { return format.isEditorNative; })
                .map(function (format) { return format.editorKey; })
                .filter(function (formatKey, index, self) { return self.indexOf(formatKey) === index; }); // Distinct keys
            var quill = new quillModule(_this._editorElement, {
                formats: quillFormatKeys,
                readOnly: false,
                styles: false,
                modules: {
                    'paste-manager': {
                        onConvert: function (container) {
                            // Remove images
                            var wordImages = container.querySelectorAll('img, .MsoNormal [src]:not([src=\'\']');
                            for (var i = 0; i < wordImages.length; i++) {
                                wordImages[i].parentElement.removeChild(wordImages[i]);
                            }
                            var doc = new QuillEditor.quillDocument(container, {
                                formats: quillFormatKeys,
                                readOnly: false,
                                styles: false
                            });
                            // Clean up children with no text content
                            var line = doc.lines.first;
                            while (line) {
                                var next = line.next;
                                if (!line.data.textContent.length) {
                                    doc.removeLine(line);
                                }
                                line = next;
                            }
                            var delta = doc.toDelta();
                            // Remove added newline if applicable
                            var lengthAdded = delta.length();
                            if (lengthAdded === 0) {
                                return delta;
                            }
                            return delta.compose(new QuillEditor.quillDelta().retain(lengthAdded - 1)['delete'](1));
                        }
                    }
                }
            });
            _this._quillEditorElement = _this._editorElement.querySelector('.ql-editor');
            // @todo 181437, get placeholder text via props later
            _this._quillEditorElement.setAttribute('data-placeholder', CanvasStrings_resx_1.default.TextWebPartPlaceholder);
            // Add custom non-Quill formats to Quill
            // @todo 198188: Do this using _supportedFormatsArray after upgrading to Quill 1.0
            quill.addFormat('blockquote', {
                class: 'quote-',
                type: 'line'
            });
            quill.addFormat('h2', {
                tag: 'H2',
                type: 'line'
            });
            quill.addFormat('h3', {
                tag: 'H3',
                type: 'line'
            });
            quill.addFormat('h4', {
                tag: 'H4',
                type: 'line'
            });
            quill.on('text-change', _this._handleTextChange);
            quill.on('selection-change', _this._handleSelectionChange);
            quill.setHTML(currentHTML);
            _this._quill = quill;
        });
    };
    QuillEditor.moduleLoader = new QuillLoader_1.default();
    return QuillEditor;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = QuillEditor;

//# sourceMappingURL=QuillEditor.js.map
