/**
 * @copyright Microsoft Corporation. All rights reserved.
 */
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var React = require('react');
var ReactDom = require('react-dom');
var sp_client_base_1 = require('@microsoft/sp-client-base');
var odsp_utilities_bundle_1 = require('@ms/odsp-utilities-bundle');
var SPRteConfiguration_1 = require('./SPRteConfiguration');
var SPRteFormattingBar_1 = require('../formattingbar/SPRteFormattingBar');
var SPRteLinkDialog_1 = require('../formattingbar/SPRteLinkDialog');
var QuillEditor_1 = require('../quill/QuillEditor');
var ToolbarButton_1 = require('../../canvas/canvas/ToolbarButton');
var ToolbarSubmenu_1 = require('../../canvas/canvas/ToolbarSubmenu');
var CanvasA11y_1 = require('../../sp-canvas/a11y/CanvasA11y');
require('./SPRte.scss');
var CanvasStrings_resx_1 = require('../../sp-canvas/loc/CanvasStrings.resx');
/**
 * @class Rich Text Editor class. This component wraps around all the RTE logic including the text editor
 * and the formatting bar and is used as a canvas control.
 */
var SPRte = (function (_super) {
    __extends(SPRte, _super);
    function SPRte(props) {
        _super.call(this, props);
        this._checkSelectionChange = this._checkSelectionChange.bind(this);
        this._getFormatButtonProps = this._getFormatButtonProps.bind(this);
        this._handleAlignCenter = this._handleAlignCenter.bind(this);
        this._handleAlignLeft = this._handleAlignLeft.bind(this);
        this._handleAlignRight = this._handleAlignRight.bind(this);
        this._handleBold = this._handleBold.bind(this);
        this._handleClearFormatting = this._handleClearFormatting.bind(this);
        this._handleEditorFocus = this._handleEditorFocus.bind(this);
        this._handleHeading2 = this._handleHeading2.bind(this);
        this._handleHeading3 = this._handleHeading3.bind(this);
        this._handleHeading4 = this._handleHeading4.bind(this);
        this._handleItalic = this._handleItalic.bind(this);
        this._handleLink = this._handleLink.bind(this);
        this._handleListBullets = this._handleListBullets.bind(this);
        this._handleListNumbered = this._handleListNumbered.bind(this);
        this._handlePlainText = this._handlePlainText.bind(this);
        this._handleQuote = this._handleQuote.bind(this);
        this._handleSelectionChange = this._handleSelectionChange.bind(this);
        this._handleTextChange = this._handleTextChange.bind(this);
        this._handleUnderline = this._handleUnderline.bind(this);
        this._handleUnlink = this._handleUnlink.bind(this);
        this._handleFormattingBarKeyDown = this._handleFormattingBarKeyDown.bind(this);
        this._handleKeyDown = this._handleKeyDown.bind(this);
        this._handleKeyUp = this._handleKeyUp.bind(this);
        this._handleScroll = this._handleScroll.bind(this);
        this._restoreOnFocus = this._restoreOnFocus.bind(this);
        this._onLinkDialogSaved = this._onLinkDialogSaved.bind(this);
        this._openLinkDialog = this._openLinkDialog.bind(this);
        this._closeLinkDialog = this._closeLinkDialog.bind(this);
        this.state = {
            displayMode: this.props.displayMode,
            formattingBarPosition: undefined,
            isFormattingBarHidden: true,
            isLinkDialogOpen: false
        };
        this._config = new SPRteConfiguration_1.default();
        this._restoreScrollTopOnNextFocus = false;
        this._restoreSelectionOnNextFocus = false;
        this._buttonStates = new Map();
        this._selectionInitiated = false;
        this._selectionShouldEnd = false;
        if (this.state.displayMode === sp_client_base_1.DisplayMode.Edit && !this._editor) {
            QuillEditor_1.default.moduleLoader.loadModule();
        }
    }
    SPRte.prototype.render = function () {
        var _this = this;
        var formattingBar;
        var html;
        var className;
        if (this.state.displayMode === sp_client_base_1.DisplayMode.Read) {
            className = 'ql-container';
            html = this._previousHTML || this.props.innerHTML;
        }
        // Do not render a formatting bar if the control is not in edit mode and the
        // formatting bar is hidden
        var isEditMode = this.state.displayMode === sp_client_base_1.DisplayMode.Edit;
        if (isEditMode && !this.state.isFormattingBarHidden) {
            formattingBar = React.createElement(SPRteFormattingBar_1.default, {buttons: this._formattingBarButtons, position: this.state.formattingBarPosition, onKeyDown: this._handleFormattingBarKeyDown, ref: function (c) { return _this._formattingbar = c; }});
        }
        return (React.createElement("div", {ref: function (c) { return _this._domElement = c; }}, React.createElement("div", {"aria-role": isEditMode ? 'textbox' : undefined, "aria-multiline": isEditMode || undefined, dangerouslySetInnerHTML: { __html: html }, className: className, onKeyUp: this._handleKeyUp, ref: function (c) { return _this._editorElement = c; }}), formattingBar, React.createElement(SPRteLinkDialog_1.default, {editorElement: this._editableDiv, isOpen: this.state.isLinkDialogOpen, onCancelClicked: this._closeLinkDialog, onDismiss: this._closeLinkDialog, onSaveClicked: this._onLinkDialogSaved, ref: function (c) { return _this._linkDialog = c; }, textFieldValue: this._linkAddress || '', validationRegex: SPRte._URL_VALIDATION_REGEX})));
    };
    SPRte.prototype.componentDidMount = function () {
        var _this = this;
        if (this.state.displayMode === sp_client_base_1.DisplayMode.Edit) {
            this._createNewEditor(this.props.innerHTML || '').then(function (editor) {
                _this._afterEditorCreated(editor);
                _this.context.store.webPartManager.configureStart(undefined);
                _this.focus();
            });
        }
    };
    SPRte.prototype.componentDidUpdate = function (prevProps, prevState) {
        if (this._formattingbar) {
            this._formattingbarElement = ReactDom.findDOMNode(this._formattingbar);
            this._formattingbarWidth = this._formattingbarElement.offsetWidth || this._formattingbarWidth;
            if (this.context.store.scrollableParent) {
                this.context.store.scrollableParent.addEventListener('scroll', this._handleScroll);
            }
            /* If formattingbar exists and editable div doesn't have focus, make the editable div un-tabbable
              This is because we want tab to switch between the toolbars and only ESC can set the focus back to editor */
            var tabIndex = (this._editableDiv && this._editableDiv.isEqualNode(document.activeElement)) ? '0' : '-1';
            this._editableDiv.setAttribute('tabindex', tabIndex);
        }
        else {
            this._formattingbarElement = undefined;
            if (this.context.store.scrollableParent) {
                this.context.store.scrollableParent.removeEventListener('scroll', this._handleScroll);
            }
            if (this._editableDiv) {
                this._editableDiv.setAttribute('tabindex', '0');
            }
        }
    };
    SPRte.prototype.componentWillUnmount = function () {
        if (this._editor) {
            this._previousHTML = this._editor.destroy();
            this._editor = undefined;
        }
    };
    SPRte.prototype.componentWillUpdate = function (nextProps, nextState) {
        var _this = this;
        if (this.state.displayMode !== nextState.displayMode) {
            if (nextState.displayMode === sp_client_base_1.DisplayMode.Edit) {
                /**
                 * Switching from Read mode to Edit mode. Create a new editor
                 * If SPRte has previously been in edit mode during the same session we want to use the saved HTML.
                 * The props value is used if the editor is switching to edit mode for the first time since
                 * _previousHTML will be null.
                 */
                this._createNewEditor(this._previousHTML || this.props.innerHTML || '').then(function (editor) {
                    _this._afterEditorCreated(editor);
                    _this._setButtonStates();
                });
            }
            else if (nextState.displayMode === sp_client_base_1.DisplayMode.Read) {
                // Switching from Edit mode to Read mode. Remove the editor instance
                this.componentWillUnmount();
            }
        }
        else if (nextState.displayMode === sp_client_base_1.DisplayMode.Edit && this._editor) {
            /* Re-evaluate button activeness map before every render
            We assume that we only need to change activeness if the focus is inside the editor
            IMPORTANT: this._quill.focus() should not be called during state-transition, because it will trigger
            selection-change and cause another state-transition which is forbidden by React */
            this._setButtonStates();
        }
    };
    SPRte.prototype.focus = function () {
        if (this._editableDiv) {
            // If focus() is explicitly called on the React component, force the editor to be tabbable
            this._editableDiv.setAttribute('tabindex', '0');
        }
        this._editor.focus();
    };
    SPRte.prototype.setDisplayMode = function (newMode) {
        if (this.state.displayMode !== newMode) {
            this.setState({
                displayMode: newMode,
                formattingBarPosition: undefined,
                isFormattingBarHidden: true,
                isLinkDialogOpen: false
            });
        }
    };
    /**
     * Return the serialized instance of this control
     */
    SPRte.prototype.serialize = function () {
        var serialization = JSON.parse(JSON.stringify(this.props));
        serialization.innerHTML = this._editor ? this._editor.getHTML() : this.props.innerHTML;
        return serialization;
    };
    SPRte.prototype._afterEditorCreated = function (editor) {
        this._editor = editor;
        this._handleTextChange();
        this._editorElement.addEventListener('keydown', this._handleKeyDown);
        document.addEventListener('mouseup', this._checkSelectionChange);
        this._editableDiv = this._editorElement.querySelector('.ql-editor');
        if (this._editableDiv) {
            this._editableDiv.setAttribute('aria-label', CanvasStrings_resx_1.default.RichTextEditorAriaLabel);
            this._editableDiv.addEventListener('focus', this._handleEditorFocus);
        }
    };
    SPRte.prototype._ariaConfirmAction = function (formatKeyOrName) {
        var format = this._config.formats.get(formatKeyOrName);
        var name = format ? format.button.title : formatKeyOrName;
        var message = odsp_utilities_bundle_1.StringHelper.format(CanvasStrings_resx_1.default.FormattingBarConfirmAction, name);
        if (this._currentSelection && this._currentSelection.start !== this._currentSelection.end &&
            !(format && format.isLine)) {
            var text = this._editor.getText(this._currentSelection);
            message = odsp_utilities_bundle_1.StringHelper.format(CanvasStrings_resx_1.default.FormattingBarConfirmActionOnSelection, name, text);
        }
        this.context.store.a11yManager.ariaAlert(message);
    };
    /**
     * Note: keyup and mouseup can happen before or after selection-change depending on the user input
     * That's why we need to mark these events in separate flags (_selectionInitiated and _selectionShouldEnd)
     * Whenever one of them happens, we check if the other one has happened so we could complete the action
     *
     * Checks if a selection change should complete, then:
     * - If the selection was already initiated, completes it
     * - Otherwise, markes the selection to be completed after initiation
     */
    SPRte.prototype._checkSelectionChange = function () {
        if (this._editor) {
            this._selectionShouldEnd = true;
            if (this._selectionInitiated) {
                var range = this._editor.getSelection();
                this._currentSelection = range;
                this._updateFormattingBar();
                // Reset completion flag because selection change is already handled
                this._selectionShouldEnd = false;
            }
            // Reset initiation flag for future events
            this._selectionInitiated = false;
        }
    };
    SPRte.prototype._closeLinkDialog = function () {
        this._restoreSelectionOnNextFocus = true;
        this._restoreScrollTopOnNextFocus = true;
        this._currentScrollTop = this.context.store.scrollableParent.scrollTop;
        this._linkAddress = '';
        this.setState({
            isLinkDialogOpen: false
        });
    };
    SPRte.prototype._createNewEditor = function (innerHTML) {
        return QuillEditor_1.default.createNewEditor(this._config, innerHTML, this._editorElement, this._handleSelectionChange, this._handleTextChange);
    };
    SPRte.prototype._shouldFormattingBarStick = function () {
        var editorRelativeTop = this._editorElement.getBoundingClientRect().top - this.context.store.canvasElement.getBoundingClientRect().top;
        return this.context.store.scrollableParent.scrollTop >
            this.context.store.scrollThreshold + SPRte._BASE_SCROLL_THRESHOLD +
                editorRelativeTop + SPRte._TOOLBAR_DEFAULT_POSITION.top;
    };
    SPRte.prototype._getFormattingBarPosition = function () {
        var left = SPRte._TOOLBAR_DEFAULT_POSITION.left;
        var top = SPRte._TOOLBAR_DEFAULT_POSITION.top;
        var position = 'absolute';
        var isFloating = false;
        if (this._formattingbarElement) {
            if (this._currentSelection && this._currentSelection.start !== this._currentSelection.end) {
                // Use range.end - 1, because getBounds returns left:0 when the selection ends at the end of line
                var startBounds = this._editor.getBounds(this._currentSelection.start);
                var endBounds = this._editor.getBounds(Math.max(0, this._currentSelection.end - 1));
                if (startBounds.top === endBounds.top) {
                    isFloating = true;
                    // Fix the problem where Quill returns faulty endBounds.left when the selection ends close to end of line
                    endBounds.left = startBounds.left <= endBounds.left ? endBounds.left : this._editorElement.offsetWidth;
                    var toolbarLeft = (startBounds.left + endBounds.left) / 2 - this._formattingbarWidth / 2;
                    var canvasZoneWidth = this._editorElement.offsetWidth + SPRte._CANVASZONE_PADDING_HORIZONTAL * 2;
                    left = toolbarLeft + this._formattingbarWidth <= canvasZoneWidth ?
                        Math.max(toolbarLeft, SPRte._TOOLBAR_DEFAULT_POSITION.left) :
                        canvasZoneWidth - this._formattingbarWidth;
                    // If the floating top is too close to the fixed top (<line-height), use the fixed top to avoid funkiness
                    top = startBounds.top < 23 ?
                        SPRte._TOOLBAR_DEFAULT_POSITION.top :
                        startBounds.top + SPRte._TOOLBAR_DEFAULT_POSITION.top;
                    position = 'absolute';
                }
            }
        }
        // Even if the formatting bar element doesn't exist, we can still calculate the sticky bar position
        if (!isFloating && this._shouldFormattingBarStick()) {
            left = SPRte._TOOLBAR_DEFAULT_POSITION.left +
                this._editorElement.getBoundingClientRect().left - SPRte._CANVASZONE_PADDING_HORIZONTAL;
            top = this.context.store.canvasElement.getBoundingClientRect().top +
                this.context.store.scrollableParent.scrollTop - this.context.store.scrollThreshold;
            position = 'fixed';
        }
        return { left: left, top: top, position: position };
    };
    SPRte.prototype._getFormatButtonProps = function (formatKey, onClick) {
        var format = this._config.formats.get(formatKey);
        return {
            key: format.key,
            fabricIconKey: format.button.fabricIconKey,
            iconClassName: format.button.iconClassName,
            onClick: onClick,
            canBeActive: format.button.canBeActive,
            isActive: this._buttonStates.get(format.key) === ToolbarButton_1.ButtonState.Active,
            disabled: this._buttonStates.get(format.key) === ToolbarButton_1.ButtonState.Disabled,
            title: format.button.title + (format.button.shortcut ? " (" + format.button.shortcut + ")" : ''),
            label: format.button.label,
            className: format.button.className
        };
    };
    Object.defineProperty(SPRte.prototype, "_formattingBarButtons", {
        get: function () {
            var _this = this;
            var formatSubmenuButtons = [
                {
                    canBeActive: true,
                    title: CanvasStrings_resx_1.default.FormattingBarNormalTextButtonTitle,
                    label: CanvasStrings_resx_1.default.FormattingBarNormalTextButtonTitle,
                    onClick: this._handlePlainText
                },
                this._getFormatButtonProps('h2', this._handleHeading2),
                this._getFormatButtonProps('h3', this._handleHeading3),
                this._getFormatButtonProps('h4', this._handleHeading4),
                this._getFormatButtonProps('blockquote', this._handleQuote)
            ];
            var alignmentSubmenuButtons = [
                this._getFormatButtonProps('alignLeft', this._handleAlignLeft),
                this._getFormatButtonProps('alignCenter', this._handleAlignCenter),
                this._getFormatButtonProps('alignRight', this._handleAlignRight)
            ];
            var listSubmenuButtons = [
                this._getFormatButtonProps('bullet', this._handleListBullets),
                this._getFormatButtonProps('list', this._handleListNumbered)
            ];
            var buttons = [
                React.createElement(ToolbarSubmenu_1.default, {key: 'format', buttons: formatSubmenuButtons, isOpen: this.state.currentSubmenuOpen === 'format', isWide: true, onOpen: function () { return _this.setState({ currentSubmenuOpen: 'format' }); }}),
                React.createElement(ToolbarButton_1.default, React.__spread({}, this._getFormatButtonProps('bold', this._handleBold))),
                React.createElement(ToolbarButton_1.default, React.__spread({}, this._getFormatButtonProps('italic', this._handleItalic))),
                React.createElement(ToolbarButton_1.default, React.__spread({}, this._getFormatButtonProps('underline', this._handleUnderline))),
                React.createElement(ToolbarSubmenu_1.default, {key: 'alignment', buttons: alignmentSubmenuButtons, isOpen: this.state.currentSubmenuOpen === 'alignment', onOpen: function () { return _this.setState({ currentSubmenuOpen: 'alignment' }); }}),
                React.createElement(ToolbarSubmenu_1.default, {key: 'list', buttons: listSubmenuButtons, isOpen: this.state.currentSubmenuOpen === 'list', onOpen: function () { return _this.setState({ currentSubmenuOpen: 'list' }); }}),
                React.createElement(ToolbarButton_1.default, React.__spread({}, this._getFormatButtonProps('link', this._handleLink))),
                React.createElement(ToolbarButton_1.default, {key: 'unlink', canBeActive: false, className: 'button_linkRemove_temp', fabricIconKey: 'Link', onClick: this._handleUnlink, title: CanvasStrings_resx_1.default.FormattingBarUnlinkButtonTitle, disabled: this._buttonStates.get('link') !== ToolbarButton_1.ButtonState.Active}),
                React.createElement(ToolbarButton_1.default, {key: 'clearFormatting', canBeActive: false, fabricIconKey: 'ClearFormatting', onClick: this._handleClearFormatting, title: CanvasStrings_resx_1.default.FormattingBarClearFormattingButtonTitle})
            ];
            return buttons;
        },
        enumerable: true,
        configurable: true
    });
    SPRte.prototype._finalizeAction = function (ariaActionName) {
        if (ariaActionName) {
            this._ariaConfirmAction(ariaActionName);
        }
        this._updateActiveButtons();
    };
    /**
     * @param format - Name of the format to apply
     */
    SPRte.prototype._formatOrPrepare = function (formatKey) {
        this.focus();
        var format = this._config.formats.get(formatKey);
        // Check if the format is masked and skip action
        if (format.maskedBy) {
            for (var _i = 0, _a = format.maskedBy; _i < _a.length; _i++) {
                var maskingFormat = _a[_i];
                if (this._buttonStates.get(maskingFormat) === ToolbarButton_1.ButtonState.Active) {
                    return;
                }
            }
        }
        var range = this._currentSelection;
        var _b = [range.start, range.end], start = _b[0], end = _b[1];
        var value = format.editorValue ? format.editorValue : !this._editor.isFormatAppliedToRange(start, end, format);
        this._cleanupBeforeFormatting(start, end, format);
        var formats = {};
        formats[format.editorKey] = value;
        this._editor.format(start, end, formats);
        this._finalizeAction(formatKey);
    };
    SPRte.prototype._handleAlignCenter = function () {
        this._formatOrPrepare('alignCenter');
    };
    SPRte.prototype._handleAlignLeft = function () {
        this._formatOrPrepare('alignLeft');
    };
    SPRte.prototype._handleAlignRight = function () {
        this._formatOrPrepare('alignRight');
    };
    SPRte.prototype._handleBold = function () {
        this._formatOrPrepare('bold');
    };
    SPRte.prototype._handleHeading2 = function () {
        this._formatOrPrepare('h2');
    };
    SPRte.prototype._handleHeading3 = function () {
        this._formatOrPrepare('h3');
    };
    SPRte.prototype._handleHeading4 = function () {
        this._formatOrPrepare('h4');
    };
    SPRte.prototype._handleItalic = function () {
        this._formatOrPrepare('italic');
    };
    SPRte.prototype._handleLink = function () {
        if (this._currentSelection) {
            // If there is existing link modify its URL, otherwise create new one if selection is not collapsed
            if (this._buttonStates.get('link') === ToolbarButton_1.ButtonState.Active) {
                var linkAddress = this._editor.getFormatValue(this._currentSelection.start, this._currentSelection.end, this._config.formats.get('link'));
                this._openLinkDialog(linkAddress);
            }
            else if (this._currentSelection.start !== this._currentSelection.end) {
                this._openLinkDialog();
            }
            this._updateActiveButtons();
        }
    };
    SPRte.prototype._handleListBullets = function () {
        this._formatOrPrepare('bullet');
    };
    SPRte.prototype._handleListNumbered = function () {
        this._formatOrPrepare('list');
    };
    SPRte.prototype._handlePlainText = function () {
        this.focus();
        if (this._currentSelection) {
            // Use the clean method for any styling format
            var blockStyles = this._config.supportedFormatsArray.filter(function (format) { return format.isBlockStyle; });
            this._cleanupBeforeFormatting(this._currentSelection.start, this._currentSelection.end, blockStyles[0]);
            this._finalizeAction();
        }
    };
    SPRte.prototype._handleQuote = function () {
        this._formatOrPrepare('blockquote');
    };
    /**
      * Checks if a selection change should initiate, then:
      * - If the selection was marked for completion, completes it
      * - Otherwise, markes the selection as initiated to be completed later
      */
    SPRte.prototype._handleSelectionChange = function (range) {
        if (range) {
            this.setState({ currentSubmenuOpen: undefined });
            if (this._restoreOnFocus()) {
                this._updateFormattingBar();
                return;
            }
        }
        if (!range) {
            this._updateFormattingBar(true);
        }
        else if (!this._currentSelection || this.state.isFormattingBarHidden) {
            this._currentSelection = range;
            this._updateFormattingBar();
        }
        else if (this._currentSelection.start !== range.start || this._currentSelection.end !== range.end) {
            // Initiate a selection and complete it if it was marked for completion
            this._selectionInitiated = true;
            if (this._selectionShouldEnd) {
                this._currentSelection = range;
                this._updateFormattingBar();
                // Reset initiation flag because selection change is already handled
                this._selectionInitiated = false;
            }
            // Clear completion flag for future events
            this._selectionShouldEnd = false;
        }
    };
    SPRte.prototype._handleClearFormatting = function () {
        this.focus();
        var range = this._currentSelection;
        var _a = [range.start, range.end], start = _a[0], end = _a[1];
        var formats = {};
        for (var _i = 0, _b = this._config.supportedFormatsArray; _i < _b.length; _i++) {
            var format = _b[_i];
            formats[format.editorKey] = false;
        }
        this._editor.format(start, end, formats);
        this._finalizeAction(CanvasStrings_resx_1.default.FormattingBarClearFormattingButtonTitle);
    };
    SPRte.prototype._handleTextChange = function () {
        if (this.state.displayMode === sp_client_base_1.DisplayMode.Edit) {
            // Note: Use if-else because classList.toggle doesn't work properly in IE
            if (this._editorElement.textContent === '') {
                this._editorElement.classList.add('ql-container--blank');
            }
            else {
                this._editorElement.classList.remove('ql-container--blank');
            }
            if (this._editor) {
                this._currentSelection = this._editor.getSelection() || this._currentSelection;
            }
            if (this.props.onChange) {
                this.props.onChange();
            }
        }
    };
    SPRte.prototype._handleUnderline = function () {
        this._formatOrPrepare('underline');
    };
    SPRte.prototype._handleUnlink = function () {
        this.focus();
        if (this._currentSelection) {
            this._editor.format(this._currentSelection.start, this._currentSelection.end, { 'link': false });
            this._finalizeAction(CanvasStrings_resx_1.default.FormattingBarUnlinkButtonTitle);
        }
    };
    /**
     * Clean up the existing formatting of given range before applying the new format, by doing:
     *  - Clear all styling formats if new format is also a styling format
     *  - Clear all the formats masked by the new format
     *
     * @param start - Start of the range getting formatted
     * @param end - End of the range getting formatted
     * @param newFormat - Name of new format being applied
     */
    SPRte.prototype._cleanupBeforeFormatting = function (start, end, newFormat) {
        var formatsToClear = {};
        // If this is a styling format, clear all styling formats
        if (newFormat.isBlockStyle) {
            var blockStyles = this._config.supportedFormatsArray.filter(function (format) { return format.isBlockStyle; });
            for (var _i = 0, blockStyles_1 = blockStyles; _i < blockStyles_1.length; _i++) {
                var format = blockStyles_1[_i];
                formatsToClear[format.editorKey] = false;
            }
        }
        // Clear all formats masked by this format
        if (newFormat.masks) {
            for (var _a = 0, _b = newFormat.masks; _a < _b.length; _a++) {
                var maskedFormatKey = _b[_a];
                formatsToClear[this._config.formats.get(maskedFormatKey).editorKey] = false;
            }
        }
        this._editor.format(start, end, formatsToClear, true);
    };
    SPRte.prototype._onLinkDialogSaved = function () {
        if (this._linkDialog.textFieldValue) {
            this._editor.format(this._currentSelection.start, this._currentSelection.end, { 'link': this._linkDialog.textFieldValue });
        }
        this._linkElement = undefined;
        this._finalizeAction(CanvasStrings_resx_1.default.FormattingBarLinkButtonTitle);
        this._closeLinkDialog();
    };
    SPRte.prototype._openLinkDialog = function (defaultAddress) {
        if (defaultAddress === void 0) { defaultAddress = ''; }
        this._linkAddress = defaultAddress;
        this.setState({
            isLinkDialogOpen: true
        });
    };
    SPRte.prototype._handleEditorFocus = function (evt) {
        this._restoreOnFocus();
    };
    SPRte.prototype._handleFormattingBarKeyDown = function (evt) {
        if (CanvasA11y_1.isEscape(evt)) {
            if (this._editableDiv && !this._editableDiv.isEqualNode(document.activeElement)) {
                this.focus();
                evt.stopPropagation();
                evt.preventDefault();
            }
        }
    };
    SPRte.prototype._handleKeyDown = function (evt) {
        if (CanvasA11y_1.isKey(CanvasA11y_1.KeyCodes.F10, evt, true) && this._formattingbarElement) {
            this.context.store.a11yManager.navigateInside(this._formattingbarElement);
            this.context.store.a11yManager.
                ariaAlert(CanvasStrings_resx_1.default.ToolbarNavigationArrowKeys + " " + CanvasStrings_resx_1.default.ToolbarNavigationTabKeys);
            evt.stopPropagation();
            evt.preventDefault();
        }
        else if (CanvasA11y_1.isKey('K'.charCodeAt(0), evt, false, true)) {
            this._handleLink();
            evt.stopPropagation();
            evt.preventDefault();
        }
    };
    SPRte.prototype._handleKeyUp = function (evt) {
        this._checkSelectionChange();
        this._updateActiveButtons();
    };
    SPRte.prototype._handleScroll = function () {
        if (this.state.formattingBarPosition) {
            var isSticky = this.state.formattingBarPosition.position === 'fixed';
            if (this._shouldFormattingBarStick() ? !isSticky : isSticky) {
                var newState = {
                    formattingBarPosition: this._getFormattingBarPosition(),
                    isLinkDialogOpen: false
                };
                this.setState(newState);
            }
        }
    };
    SPRte.prototype._restoreOnFocus = function () {
        var restore = false;
        if (this._restoreSelectionOnNextFocus && this._currentSelection) {
            this._restoreSelectionOnNextFocus = false;
            this._editor.setSelection(this._currentSelection);
            restore = true;
        }
        if (this._restoreScrollTopOnNextFocus && this._currentScrollTop) {
            this._restoreScrollTopOnNextFocus = false;
            this.context.store.scrollableParent.scrollTop = this._currentScrollTop;
            restore = true;
        }
        return restore;
    };
    SPRte.prototype._setButtonStates = function () {
        var range = this._currentSelection;
        if (range) {
            /* Make a map to keep track of updated buttons. Its goal is to minimize the number
            of calls to isFormatAppliedToRange (equal to the number of currently non-masked formats) */
            var updatedFormats = new Map();
            for (var _i = 0, _a = this._config.supportedFormatsArray; _i < _a.length; _i++) {
                var format = _a[_i];
                updatedFormats.set(format.key, false);
            }
            // First figure out the state of masking formats and their masked formats
            var maskingFormats = this._config.supportedFormatsArray.filter(function (format) { return !!format.masks; });
            for (var _b = 0, maskingFormats_1 = maskingFormats; _b < maskingFormats_1.length; _b++) {
                var maskingFormat = maskingFormats_1[_b];
                if (!updatedFormats.get(maskingFormat.key)) {
                    var isActive = this._editor.isFormatAppliedToRange(range.start, range.end, maskingFormat);
                    this._buttonStates.set(maskingFormat.key, isActive ? ToolbarButton_1.ButtonState.Active : ToolbarButton_1.ButtonState.Normal);
                    updatedFormats.set(maskingFormat.key, true);
                    if (isActive) {
                        for (var _c = 0, _d = maskingFormat.masks; _c < _d.length; _c++) {
                            var maskedFormat = _d[_c];
                            this._buttonStates.set(maskedFormat, ToolbarButton_1.ButtonState.Disabled);
                            updatedFormats.set(maskedFormat, true);
                        }
                    }
                }
            }
            // Figure out activeness for the rest of the formats
            for (var _e = 0, _f = this._config.supportedFormatsArray; _e < _f.length; _e++) {
                var format = _f[_e];
                if (!updatedFormats.get(format.key)) {
                    var isActive = this._editor.isFormatAppliedToRange(range.start, range.end, format);
                    this._buttonStates.set(format.key, isActive ? ToolbarButton_1.ButtonState.Active : ToolbarButton_1.ButtonState.Normal);
                }
            }
        }
    };
    /**
     * This should be called whenever the activeness of buttons could have changed
     * It rerenders the component to make sure the change is rendered
     */
    SPRte.prototype._updateActiveButtons = function () {
        this.forceUpdate();
    };
    /**
     * Hide/Show the formatting bar and update the formatting bar position if needed
     * If the editor is not focused, hide the formatting bar
     * If the selection is collapsed the formatting bar will render in a static location
     * If the selection is not collapsed the formatting bar will appear near the selection
     */
    SPRte.prototype._updateFormattingBar = function (isHidden) {
        if (isHidden === void 0) { isHidden = false; }
        if (!this._editorElement) {
            return;
        }
        var updatePosition = true;
        var newState = {
            formattingBarPosition: {
                left: SPRte._TOOLBAR_DEFAULT_POSITION.left,
                top: SPRte._TOOLBAR_DEFAULT_POSITION.top,
                position: SPRte._TOOLBAR_DEFAULT_POSITION.position
            },
            isFormattingBarHidden: isHidden
        };
        if (isHidden && this._formattingbarElement) {
            // If the editor or a toolbar button has the focus, don't hide the toolbar
            if (document.activeElement.isEqualNode(this._editableDiv)) {
                isHidden = false;
            }
            else {
                var buttonNodes = this._formattingbarElement.querySelectorAll('.ToolbarButton');
                for (var i = 0; i < buttonNodes.length; i++) {
                    if (document.activeElement.isEqualNode(buttonNodes[i])) {
                        newState.isFormattingBarHidden = false;
                        newState.formattingBarPosition = this.state.formattingBarPosition;
                        isHidden = false;
                        // Don't update the position if isHidden got overriden because a button was clicked
                        updatePosition = false;
                        break;
                    }
                }
            }
            if (isHidden && !document.activeElement.isContentEditable) {
                // This makes the contenteditable element non-editable
                window.getSelection().removeAllRanges();
            }
        }
        if (!isHidden) {
            newState.isFormattingBarHidden = false;
            if (updatePosition) {
                newState.formattingBarPosition = this._getFormattingBarPosition();
            }
        }
        this.setState(newState);
    };
    SPRte.contextTypes = {
        store: React.PropTypes.object.isRequired
    };
    /**
     * @ readOnly
     */
    SPRte._TOOLBAR_DEFAULT_POSITION = {
        left: 0,
        top: -36,
        position: 'absolute'
    };
    /* tslint:disable:max-line-length */
    SPRte._URL_VALIDATION_REGEX = new RegExp('((^https?:\/\/)|(^ftp:\/\/)|(^file:\/\/)|(^mailto:)|(^news:)|(^pnm:\/\/)|(^mms:\/\/)|(^\/)|(^#)|(^\\\\)).+', 'i');
    /* tslint:enable:max-line-length */
    /**
     * @ readOnly
     *
     * The scrollOffset that works for a full-height canvas
     */
    SPRte._BASE_SCROLL_THRESHOLD = -10;
    /**
     * @ readOnly
     */
    SPRte._CANVASZONE_PADDING_HORIZONTAL = 8;
    return SPRte;
}(React.Component));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SPRte;

//# sourceMappingURL=SPRte.js.map
