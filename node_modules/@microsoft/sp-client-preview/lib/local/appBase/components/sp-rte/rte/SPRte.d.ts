/**
 * @copyright Microsoft Corporation. All rights reserved.
 */
import * as React from 'react';
import { DisplayMode } from '@microsoft/sp-client-base';
import { ICanvasContext } from '../../sp-canvas/canvas/canvasComponent/ICanvasComponent';
import ISerializedCanvasControl from '../../canvas/canvas/ISerializedCanvasControl';
import { ISPRteFormattingBarPosition } from '../formattingbar/SPRteFormattingBar';
import './SPRte.scss';
export interface ISPRteProps extends ISerializedCanvasControl {
    innerHTML?: string;
}
export interface ISPRteState {
    currentSubmenuOpen?: 'alignment' | 'format' | 'list';
    displayMode?: DisplayMode;
    formattingBarPosition?: ISPRteFormattingBarPosition;
    isFormattingBarHidden?: boolean;
    isLinkDialogOpen?: boolean;
}
/**
 * @class Rich Text Editor class. This component wraps around all the RTE logic including the text editor
 * and the formatting bar and is used as a canvas control.
 */
export default class SPRte extends React.Component<ISPRteProps, ISPRteState> {
    static contextTypes: React.ValidationMap<SPRte>;
    /**
     * @ readOnly
     */
    private static _TOOLBAR_DEFAULT_POSITION;
    private static _URL_VALIDATION_REGEX;
    /**
     * @ readOnly
     *
     * The scrollOffset that works for a full-height canvas
     */
    private static _BASE_SCROLL_THRESHOLD;
    /**
     * @ readOnly
     */
    private static _CANVASZONE_PADDING_HORIZONTAL;
    context: ICanvasContext;
    private _config;
    private _currentScrollTop;
    private _currentSelection;
    private _domElement;
    private _editor;
    private _editorElement;
    private _editableDiv;
    private _formattingbar;
    private _formattingbarElement;
    private _formattingbarWidth;
    private _buttonStates;
    private _linkAddress;
    private _linkDialog;
    private _linkElement;
    /**
     * _previousHTML is set when a the _quill instance is destroyed.
     * We destroy the quill editor when SPRte is in read mode. The Quill HTML content is used to create a new
     * Quill instance if SPRte is switched from edit -> read -> edit modes in one session.
     */
    private _previousHTML;
    /**
     * This stores reference to .ql-editor element to avoid finding it on every render
     */
    private _restoreSelectionOnNextFocus;
    private _restoreScrollTopOnNextFocus;
    private _selectionInitiated;
    private _selectionShouldEnd;
    constructor(props: ISPRteProps);
    render(): React.ReactElement<ISPRteProps>;
    componentDidMount(): void;
    componentDidUpdate(prevProps: ISPRteProps, prevState: ISPRteState): void;
    componentWillUnmount(): void;
    componentWillUpdate(nextProps: ISPRteProps, nextState: ISPRteState): void;
    focus(): void;
    setDisplayMode(newMode: DisplayMode): void;
    /**
     * Return the serialized instance of this control
     */
    serialize(): ISerializedCanvasControl;
    private _afterEditorCreated(editor);
    private _ariaConfirmAction(formatKeyOrName);
    /**
     * Note: keyup and mouseup can happen before or after selection-change depending on the user input
     * That's why we need to mark these events in separate flags (_selectionInitiated and _selectionShouldEnd)
     * Whenever one of them happens, we check if the other one has happened so we could complete the action
     *
     * Checks if a selection change should complete, then:
     * - If the selection was already initiated, completes it
     * - Otherwise, markes the selection to be completed after initiation
     */
    private _checkSelectionChange();
    private _closeLinkDialog();
    private _createNewEditor(innerHTML);
    private _shouldFormattingBarStick();
    private _getFormattingBarPosition();
    private _getFormatButtonProps(formatKey, onClick);
    private _formattingBarButtons;
    private _finalizeAction(ariaActionName?);
    /**
     * @param format - Name of the format to apply
     */
    private _formatOrPrepare(formatKey);
    private _handleAlignCenter();
    private _handleAlignLeft();
    private _handleAlignRight();
    private _handleBold();
    private _handleHeading2();
    private _handleHeading3();
    private _handleHeading4();
    private _handleItalic();
    private _handleLink();
    private _handleListBullets();
    private _handleListNumbered();
    private _handlePlainText();
    private _handleQuote();
    /**
      * Checks if a selection change should initiate, then:
      * - If the selection was marked for completion, completes it
      * - Otherwise, markes the selection as initiated to be completed later
      */
    private _handleSelectionChange(range);
    private _handleClearFormatting();
    private _handleTextChange();
    private _handleUnderline();
    private _handleUnlink();
    /**
     * Clean up the existing formatting of given range before applying the new format, by doing:
     *  - Clear all styling formats if new format is also a styling format
     *  - Clear all the formats masked by the new format
     *
     * @param start - Start of the range getting formatted
     * @param end - End of the range getting formatted
     * @param newFormat - Name of new format being applied
     */
    private _cleanupBeforeFormatting(start, end, newFormat);
    private _onLinkDialogSaved();
    private _openLinkDialog(defaultAddress?);
    private _handleEditorFocus(evt);
    private _handleFormattingBarKeyDown(evt);
    private _handleKeyDown(evt);
    private _handleKeyUp(evt);
    private _handleScroll();
    private _restoreOnFocus();
    private _setButtonStates();
    /**
     * This should be called whenever the activeness of buttons could have changed
     * It rerenders the component to make sure the change is rendered
     */
    private _updateActiveButtons();
    /**
     * Hide/Show the formatting bar and update the formatting bar position if needed
     * If the editor is not focused, hide the formatting bar
     * If the selection is collapsed the formatting bar will render in a static location
     * If the selection is not collapsed the formatting bar will appear near the selection
     */
    private _updateFormattingBar(isHidden?);
}
