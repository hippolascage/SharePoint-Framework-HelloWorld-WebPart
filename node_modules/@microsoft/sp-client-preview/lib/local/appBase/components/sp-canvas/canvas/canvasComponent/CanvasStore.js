"use strict";
var sp_client_base_1 = require('@microsoft/sp-client-base');
var CanvasWebPartHost_1 = require('../../../canvas/canvas/CanvasWebPartHost');
var CanvasControlType_1 = require('../../../canvas/canvas/CanvasControlType');
var ClientSideWebPartManager_1 = require('../../../../../clientSideWebParts/core/ClientSideWebPartManager');
var PropertyPaneDefinitions_1 = require('../../../../../common/webParts/PropertyPaneDefinitions');
var CanvasStore = (function () {
    function CanvasStore(serviceScope, render, mode, serializedCanvas, handleCanvasChanged, scrollThreshold) {
        sp_client_base_1.Validate.isNotNullOrUndefined(serviceScope, 'serviceScope');
        sp_client_base_1.Validate.isNotNullOrUndefined(render, 'render');
        sp_client_base_1.Validate.isNotNullOrUndefined(mode, 'mode');
        this._addReference = this._addReference.bind(this);
        this._notifyChanged = this._notifyChanged.bind(this);
        this.addControl = this.addControl.bind(this);
        this.closeToolbox = this.closeToolbox.bind(this);
        this.deleteControl = this.deleteControl.bind(this);
        this.handleConfigureButtonClicked = this.handleConfigureButtonClicked.bind(this);
        this.handleDeleteButtonClicked = this.handleDeleteButtonClicked.bind(this);
        this.handleDeleteDialogConfirmation = this.handleDeleteDialogConfirmation.bind(this);
        this.handleDeleteDialogDismiss = this.handleDeleteDialogDismiss.bind(this);
        this.handleWindowBlur = this.handleWindowBlur.bind(this);
        this.reclaimFocus = this.reclaimFocus.bind(this);
        this.scrollIntoView = this.scrollIntoView.bind(this);
        this.openToolbox = this.openToolbox.bind(this);
        this._render = render;
        this._controls = new Map();
        this._controlsProps = [];
        this._displayMode = mode;
        this._handleCanvasChanged = handleCanvasChanged;
        this._isDeleteDialogOpen = false;
        this._pollActiveElement = this._pollActiveElement.bind(this);
        this._scrollThreshold = scrollThreshold || 0;
        this._webPartManager = new ClientSideWebPartManager_1.default(new CanvasWebPartHost_1.default(serviceScope, this.scrollIntoView.bind(this, 'full'), handleCanvasChanged, this.reclaimFocus));
        this._toolboxProps = {
            isOpen: false,
            onItemClick: this.addControl.bind(this, 0),
            row: undefined,
            toolboxItems: [],
            verticalPosition: undefined
        };
        if (this._displayMode === sp_client_base_1.DisplayMode.Edit) {
            this.webPartManager.fetchWebParts();
        }
    }
    Object.defineProperty(CanvasStore.prototype, "addReference", {
        get: function () {
            return this._addReference;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "a11yManager", {
        get: function () {
            return this._a11yManager;
        },
        set: function (elem) {
            this._a11yManager = elem;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "canvasElement", {
        get: function () {
            return this._canvasElement;
        },
        set: function (elem) {
            this._canvasElement = elem;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "controlsProps", {
        get: function () {
            return this._controlsProps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "deletedRow", {
        get: function () {
            return this._deletedRow;
        },
        set: function (row) {
            this._deletedRow = row;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "displayMode", {
        get: function () {
            return this._displayMode;
        },
        set: function (newMode) {
            if (this._displayMode !== newMode) {
                this._displayMode = newMode;
                for (var _i = 0, _a = this.controlsProps; _i < _a.length; _i++) {
                    var props = _a[_i];
                    this._controls.get(props.id).setDisplayMode(newMode);
                }
                if (this._displayMode === sp_client_base_1.DisplayMode.Read) {
                    this._selectedControlId = undefined;
                    this.webPartManager.configureStart(undefined, PropertyPaneDefinitions_1.PropertyPaneState.Close);
                }
                if (this._displayMode === sp_client_base_1.DisplayMode.Edit) {
                    this.webPartManager.fetchWebParts();
                }
                this._render();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "hoveredControlId", {
        /**
         * The hoveredControlId keeps track of which control the pointer is currently over.
         * It is used as a workaround to track pointer events on web parts that have IFrames.
         */
        set: function (id) {
            this._hoveredControlId = id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "isDeleteDialogOpen", {
        get: function () {
            return this._isDeleteDialogOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "notifyChanged", {
        get: function () {
            return this._notifyChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "scrollableParent", {
        get: function () {
            return this._scrollableParentElement;
        },
        set: function (elem) {
            this._scrollableParentElement = elem;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "scrollThreshold", {
        get: function () {
            return this._scrollThreshold;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "selectedControlId", {
        get: function () {
            return this._selectedControlId;
        },
        set: function (id) {
            if (this._selectedControlId !== id) {
                this._selectedControlId = id;
                /**
                 * If open, change the Property Pane to reflect the new selection. If the new selection is not a web part,
                 * change the Property Pane to the empty state.
                 */
                var control = this._controls.get(id);
                if (control && control.props.controlType !== CanvasControlType_1.default.WebPartZone) {
                    this._webPartManager.configureStart(undefined);
                }
                else {
                    this._webPartManager.configureStart(id);
                }
                this._render();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "toolboxProps", {
        get: function () {
            var _this = this;
            this._toolboxProps.toolboxItems = [];
            /* tslint:disable:no-any */
            this._getManifestMap().forEach(function (manifest, cid) {
                /* tslint:enable:no-any */
                var itemProps = {
                    controlType: CanvasControlType_1.default.WebPartZone,
                    displayMode: sp_client_base_1.DisplayMode.Edit,
                    id: undefined,
                    webPartId: cid,
                    webPartData: undefined,
                    webPartManifest: manifest
                };
                var toolboxItem = {
                    itemProps: itemProps,
                    description: manifest.preconfiguredEntries[0].description.default,
                    displayName: manifest.preconfiguredEntries[0].title.default,
                    msIconName: manifest.preconfiguredEntries[0].officeFabricIconFontName
                };
                _this._toolboxProps.toolboxItems.push(toolboxItem);
            });
            return this._toolboxProps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "webPartManager", {
        get: function () {
            return this._webPartManager;
        },
        enumerable: true,
        configurable: true
    });
    CanvasStore.prototype.addControl = function (row, itemProps) {
        this._selectedControlId = itemProps.id = sp_client_base_1.Guid.newGuid().toString();
        this._addControl(row, itemProps);
        this._render();
        this._notifyChanged();
    };
    CanvasStore.prototype.deleteControl = function (row) {
        this._deletedRow = row;
        this._controlsProps.splice(row, 1);
        if (this._controlsProps.length === 0) {
            this._webPartManager.configureStart(undefined, PropertyPaneDefinitions_1.PropertyPaneState.Close);
        }
        this._render();
        this._notifyChanged();
    };
    CanvasStore.prototype.getControl = function (id) {
        return this._controls.get(id);
    };
    CanvasStore.prototype.openToolbox = function (row, verticalPosition) {
        if (this._toolboxProps.isOpen) {
            this.closeToolbox();
        }
        this._toolboxProps.isOpen = true;
        this._toolboxProps.onItemClick = this.addControl.bind(this, row);
        this._toolboxProps.row = row;
        this._toolboxProps.verticalPosition = verticalPosition;
        document.addEventListener('click', this.closeToolbox);
        this._render();
    };
    CanvasStore.prototype.closeToolbox = function () {
        this._toolboxProps.isOpen = false;
        this._toolboxProps.row = undefined;
        document.removeEventListener('click', this.closeToolbox);
        this._render();
    };
    CanvasStore.prototype.handleConfigureButtonClicked = function (id) {
        var isCurrentlySelected = this.selectedControlId === id;
        // Only toggle the Property Pane if the currently selected control's configure button is clicked.
        this._controls.get(id).handleConfigureButtonClicked(isCurrentlySelected);
        // Set private member so we don't call configureStart twice.
        this._selectedControlId = id;
        this._render();
    };
    CanvasStore.prototype.handleDeleteButtonClicked = function (row) {
        this._rowToBeDeleted = row;
        var control = this._controlsProps[this._rowToBeDeleted];
        this._selectedControlId = control.id;
        this._webPartManager.configureStart(control.controlType === CanvasControlType_1.default.WebPartZone ? this._selectedControlId : undefined);
        this._isDeleteDialogOpen = true;
        this._render();
    };
    CanvasStore.prototype.handleDeleteDialogConfirmation = function () {
        var controlProps = this._controlsProps[this._rowToBeDeleted];
        if (controlProps.controlType === CanvasControlType_1.default.WebPartZone) {
            this._controls.get(controlProps.id).handleDeleteButtonClicked();
        }
        this._isDeleteDialogOpen = false;
        this.deleteControl(this._rowToBeDeleted);
    };
    CanvasStore.prototype.handleDeleteDialogDismiss = function () {
        this._rowToBeDeleted = undefined;
        this._isDeleteDialogOpen = false;
        this._render();
    };
    /**
     * IFrame's swallow pointer events, so this is a workaround to detect when focus has shifted to
     * an IFrame. Additionally, to compensate for IFrame to IFrame interactions we poll for the document.activeElement.
     * If document.activeElement is not the same as it was in the last poll then the focus has shifted from the IFrame.
     * If the new document.activeElement is an IFrame continue polling, otherwise we can stop polling because focus
     * is back inside of the current document.
     */
    CanvasStore.prototype.handleWindowBlur = function (e) {
        if (this._hoveredControlId && document.activeElement.tagName === 'IFRAME') {
            this.selectedControlId = this._hoveredControlId;
            this._oldActiveElement = document.activeElement;
            // Before setting a new interval clear the last one, this prevents more than one poll to be active.
            window.clearInterval(this._pollId);
            this._pollId = window.setInterval(this._pollActiveElement, 250);
        }
    };
    CanvasStore.prototype.deserialize = function (serializedCanvas) {
        this._controlsProps = [];
        this._controls = new Map();
        if (serializedCanvas) {
            var wrapper = document.createElement('div');
            wrapper.innerHTML = serializedCanvas;
            var rows = wrapper.querySelectorAll('[data-sp-canvascontrol]');
            var rowLength = rows.length;
            for (var i = 0; i < rowLength; ++i) {
                var row = rows[i];
                var controlProps = JSON.parse(decodeURI(row.getAttribute('data-sp-controldata')));
                controlProps.displayMode = this._displayMode;
                this._addControl(i, controlProps);
            }
        }
    };
    CanvasStore.prototype.reclaimFocus = function () {
        this._controls.get(this._selectedControlId).focus();
    };
    /**
     * If needed, scrolls element into view after the element is added to the Canvas.
     * Note: Javascript scrollIntoView is not consistent cross-browser
     *
     * @param type - Specifies whether to scroll if the 'full' web part is visible or a 'partial' part of the web part
     *   is visible
     * @param element - A rendered element inside the Canvas to scroll to
     * @param duration - The length of time the animation should take. Frames are calculated by duration / delta time.
     * @param margin - Optional. Margin to be scrolled into view. If not provided, margin is not scrolled into view
     */
    CanvasStore.prototype.scrollIntoView = function (type, element, duration, margin) {
        if (margin === void 0) { margin = 0; }
        if (!this.scrollableParent || !element) {
            return;
        }
        var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        var frameBottom = Math.min(viewportHeight, this.scrollableParent.getBoundingClientRect().bottom);
        var elementClientRect = element.getBoundingClientRect();
        // 'partial' checks bottom to see if the element is partially hidden after adding, if it is scroll into view
        // 'full checks if the entire web part is hidden, if it is scroll into view
        if ((type === 'partial' ? elementClientRect.bottom : elementClientRect.top) > frameBottom) {
            this._scrollElementIntoView(frameBottom, element, duration, margin);
        }
    };
    CanvasStore.prototype.serialize = function () {
        var body = document.createElement('div');
        var controlRow = document.createElement('div');
        controlRow.setAttribute('data-sp-canvascontrol', '');
        var componentIdElement = document.createElement('div');
        componentIdElement.setAttribute('data-sp-componentId', '');
        var htmlPropertiesElement = document.createElement('div');
        htmlPropertiesElement.setAttribute('data-sp-htmlproperties', '');
        for (var _i = 0, _a = this._controlsProps; _i < _a.length; _i++) {
            var control = _a[_i];
            var row = controlRow.cloneNode();
            var controlData = this._controls.get(control.id).serialize();
            if (control.controlType === CanvasControlType_1.default.RTE) {
                row.innerHTML = controlData.innerHTML;
            }
            else if (control.controlType === CanvasControlType_1.default.WebPartZone) {
                var componentId = componentIdElement.cloneNode();
                componentId.textContent = controlData.webPartId;
                var htmlProperties = htmlPropertiesElement.cloneNode();
                htmlProperties.innerHTML = controlData.webPartData.htmlProperties;
                row.appendChild(componentId);
                row.appendChild(htmlProperties);
            }
            row.setAttribute('data-sp-controldata', encodeURI(JSON.stringify(controlData)));
            body.appendChild(row);
        }
        var wrapper = document.createElement('div');
        wrapper.appendChild(body);
        return wrapper.innerHTML;
    };
    CanvasStore.prototype.tryGeneratePreviewImageUrl = function () {
        var webpartIds = [];
        for (var _i = 0, _a = this._controlsProps; _i < _a.length; _i++) {
            var control = _a[_i];
            if (control.controlType === CanvasControlType_1.default.WebPartZone) {
                webpartIds.push(control.id);
            }
        }
        return this.webPartManager.tryGeneratePreviewImageUrl(webpartIds);
    };
    CanvasStore.prototype._addControl = function (row, itemProps) {
        if (!itemProps.id) {
            itemProps.id = sp_client_base_1.Guid.newGuid().toString();
        }
        if (itemProps.controlType === CanvasControlType_1.default.WebPartZone &&
            !itemProps.webPartManifest) {
            var webPartProps = itemProps;
            webPartProps.webPartManifest = this._getManifestMap().get(webPartProps.webPartId);
        }
        this._controlsProps.splice(row, 0, itemProps);
    };
    CanvasStore.prototype._addReference = function (ref) {
        if (ref) {
            this._controls.set(ref.props.id, ref);
        }
    };
    /**
     * Calculates the easing number using the quadratic in-out formula
     */
    CanvasStore.prototype._calculateEasing = function (time, start, diff, duration) {
        time /= duration / 2;
        if (time < 1) {
            return diff / 2 * time * time + start;
        }
        else {
            --time;
            return -diff / 2 * (time * (time - 2) - 1) + start;
        }
    };
    /* tslint:disable:no-any */
    CanvasStore.prototype._getManifestMap = function () {
        var tempMap = new Map();
        var manifests = this._webPartManager.getWebParts();
        /* tslint:enable:no-any */
        for (var _i = 0, manifests_1 = manifests; _i < manifests_1.length; _i++) {
            var manifest = manifests_1[_i];
            tempMap.set(manifest.id, manifest);
        }
        return tempMap;
    };
    CanvasStore.prototype._pollActiveElement = function () {
        var activeElement = document.activeElement;
        if (activeElement.tagName !== 'IFRAME') {
            window.clearInterval(this._pollId);
        }
        else if (this._oldActiveElement !== activeElement && this._hoveredControlId) {
            this._oldActiveElement = activeElement;
            this.selectedControlId = this._hoveredControlId;
        }
    };
    CanvasStore.prototype._scroll = function (start, end, duration, time) {
        var _this = this;
        if (time === void 0) { time = 0; }
        var diff = end - start;
        var deltaTime = 20;
        if (time < duration) {
            requestAnimationFrame(function () {
                time += deltaTime;
                _this.scrollableParent.scrollTop = _this._calculateEasing(time, start, diff, duration);
                _this._scroll(start, end, duration, time);
            });
        }
    };
    CanvasStore.prototype._scrollElementIntoView = function (frameBottom, element, duration, margin) {
        var elementClientRect = element.getBoundingClientRect();
        var scrollPosition = elementClientRect.bottom - this.canvasElement.getBoundingClientRect().top;
        var frameTop = Math.max(0, this.scrollableParent.getBoundingClientRect().top);
        var offset = frameTop - frameBottom + this._scrollThreshold + margin;
        var newScrollTop = scrollPosition + offset + this._scrollThreshold;
        this._scroll(this.scrollableParent.scrollTop, newScrollTop, duration);
    };
    CanvasStore.prototype._notifyChanged = function () {
        if (this._handleCanvasChanged) {
            this._handleCanvasChanged();
        }
    };
    return CanvasStore;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CanvasStore;

//# sourceMappingURL=CanvasStore.js.map
