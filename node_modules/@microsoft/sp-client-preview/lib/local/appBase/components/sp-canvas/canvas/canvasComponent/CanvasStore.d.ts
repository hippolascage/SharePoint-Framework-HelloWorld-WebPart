import { DisplayMode, ServiceScope } from '@microsoft/sp-client-base';
import ClientSideWebPartManager from '../../../../../clientSideWebParts/core/ClientSideWebPartManager';
import { ISerializedCanvasControl } from '../canvasControl/ISerializedCanvasControl';
import { IToolboxProps } from '../../toolbox/toolbox/IToolbox';
import SPRte from '../../../sp-rte/rte/SPRte';
import WebPartZone from '../../../canvas/sampleCanvasControls/WebPartZone';
import { CanvasA11yManager } from '../../a11y/CanvasA11y';
export default class CanvasStore {
    private _a11yManager;
    private _canvasElement;
    private _controls;
    private _controlsProps;
    private _deletedRow;
    private _displayMode;
    private _handleCanvasChanged;
    private _hoveredControlId;
    private _isDeleteDialogOpen;
    private _oldActiveElement;
    private _pollId;
    private _render;
    private _scrollableParentElement;
    private _scrollThreshold;
    private _selectedControlId;
    private _rowToBeDeleted;
    private _toolboxProps;
    private _webPartManager;
    constructor(serviceScope: ServiceScope, render: () => void, mode: DisplayMode, serializedCanvas?: string, handleCanvasChanged?: () => void, scrollThreshold?: number);
    addReference: (ref: SPRte | WebPartZone) => void;
    a11yManager: CanvasA11yManager;
    canvasElement: HTMLElement;
    controlsProps: ISerializedCanvasControl[];
    deletedRow: number;
    displayMode: DisplayMode;
    /**
     * The hoveredControlId keeps track of which control the pointer is currently over.
     * It is used as a workaround to track pointer events on web parts that have IFrames.
     */
    hoveredControlId: string;
    isDeleteDialogOpen: boolean;
    notifyChanged: () => void;
    scrollableParent: HTMLElement;
    scrollThreshold: number;
    selectedControlId: string;
    toolboxProps: IToolboxProps;
    webPartManager: ClientSideWebPartManager;
    addControl(row: number, itemProps: ISerializedCanvasControl): void;
    deleteControl(row: number): void;
    getControl(id: string): SPRte | WebPartZone;
    openToolbox(row: number, verticalPosition: number): void;
    closeToolbox(): void;
    handleConfigureButtonClicked(id: string): void;
    handleDeleteButtonClicked(row: number): void;
    handleDeleteDialogConfirmation(): void;
    handleDeleteDialogDismiss(): void;
    /**
     * IFrame's swallow pointer events, so this is a workaround to detect when focus has shifted to
     * an IFrame. Additionally, to compensate for IFrame to IFrame interactions we poll for the document.activeElement.
     * If document.activeElement is not the same as it was in the last poll then the focus has shifted from the IFrame.
     * If the new document.activeElement is an IFrame continue polling, otherwise we can stop polling because focus
     * is back inside of the current document.
     */
    handleWindowBlur(e: MouseEvent): void;
    deserialize(serializedCanvas: string): void;
    reclaimFocus(): void;
    /**
     * If needed, scrolls element into view after the element is added to the Canvas.
     * Note: Javascript scrollIntoView is not consistent cross-browser
     *
     * @param type - Specifies whether to scroll if the 'full' web part is visible or a 'partial' part of the web part
     *   is visible
     * @param element - A rendered element inside the Canvas to scroll to
     * @param duration - The length of time the animation should take. Frames are calculated by duration / delta time.
     * @param margin - Optional. Margin to be scrolled into view. If not provided, margin is not scrolled into view
     */
    scrollIntoView(type: 'full' | 'partial', element: HTMLElement, duration: number, margin?: number): void;
    serialize(): string;
    tryGeneratePreviewImageUrl(): string;
    private _addControl(row, itemProps);
    private _addReference(ref);
    /**
     * Calculates the easing number using the quadratic in-out formula
     */
    private _calculateEasing(time, start, diff, duration);
    private _getManifestMap();
    private _pollActiveElement();
    private _scroll(start, end, duration, time?);
    private _scrollElementIntoView(frameBottom, element, duration, margin);
    private _notifyChanged();
}
