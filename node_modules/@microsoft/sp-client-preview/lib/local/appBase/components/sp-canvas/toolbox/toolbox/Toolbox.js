"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var React = require('react');
var FocusZone_1 = require('office-ui-fabric-react/lib/FocusZone');
var sp_client_base_1 = require('@microsoft/sp-client-base');
var sp_client_base_2 = require('@microsoft/sp-client-base');
var odsp_utilities_bundle_1 = require('@ms/odsp-utilities-bundle');
var CanvasControlType_1 = require('../../../canvas/canvas/CanvasControlType');
var ToolboxGroup_1 = require('../toolboxGroup/ToolboxGroup');
var ToolboxItem_1 = require('../toolboxItem/ToolboxItem');
var ToolboxItemClassifier_1 = require('../toolboxItem/ToolboxItemClassifier');
var CanvasA11y_1 = require('../../a11y/CanvasA11y');
require('./Toolbox.scss');
var CanvasStrings_resx_1 = require('../../loc/CanvasStrings.resx');
/**
 * @todo [VSO:SPPPlat] #231682
 */
var NEWSFEED_WEBPART_FLIGHT = 792;
var NEWSREEL_WEBPART_FLIGHT = 790;
var NEWSFEED_ID = 'a5df8fdf-b508-4b66-98a6-d83bc2597f63';
var NEWSREEL_ID = '0ef418ba-5d19-4ade-9db0-b339873291d0';
var Toolbox = (function (_super) {
    __extends(Toolbox, _super);
    function Toolbox(props, context) {
        _super.call(this, props, context);
        this._handleKeyDownCapture = this._handleKeyDownCapture.bind(this);
        this.state = {
            verticalPosition: props.verticalPosition
        };
    }
    Toolbox.prototype.componentDidMount = function () {
        this._domNode.addEventListener('keydown', this._handleKeyDownCapture, true);
    };
    Toolbox.prototype.componentDidUpdate = function (prevProps) {
        if (this.props.isOpen !== prevProps.isOpen) {
            if (this.props.isOpen) {
                this.context.store.a11yManager.saveState();
                this.context.store.a11yManager.navigateTo(this._domNode);
                // This assumes there is one non-webpart item (RTE)
                var localizedItemCount = odsp_utilities_bundle_1.StringHelper.formatWithLocalizedCountValue(CanvasStrings_resx_1.default.CanvasItems, CanvasStrings_resx_1.default.CanvasItemsInterval, this.props.toolboxItems.length + 1);
                var message = odsp_utilities_bundle_1.StringHelper.format(CanvasStrings_resx_1.default.ToolboxNavigationArrowKeys, localizedItemCount);
                this.context.store.a11yManager.ariaAlert(message);
            }
            else {
                this.context.store.a11yManager.clearState();
            }
        }
    };
    Toolbox.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.isOpen && this.context.store.scrollableParent) {
            // Use the scrollableParent as our viewport
            var _a = this.context.store.scrollableParent.getBoundingClientRect(), top_1 = _a.top, bottom = _a.bottom;
            var toolboxRowCount = Math.min(Math.ceil(nextProps.toolboxItems.length + 1 / 3), 3);
            var toolboxHeight = toolboxRowCount * 110;
            var canvasTop = this.context.store.canvasElement.getBoundingClientRect().top;
            var hintOffset = 43 - (toolboxRowCount * 5);
            var verticalPosition = nextProps.verticalPosition;
            // Render Toolbox above hint if there is no room below the hint and there is room above
            if ((verticalPosition + toolboxHeight + hintOffset + canvasTop > bottom) &&
                (verticalPosition - toolboxHeight - hintOffset > top_1)) {
                verticalPosition -= toolboxHeight + hintOffset;
            }
            this.setState({ verticalPosition: verticalPosition });
        }
    };
    Toolbox.prototype.render = function () {
        var _this = this;
        var _a = this.props, isOpen = _a.isOpen, onItemClick = _a.onItemClick, toolboxItems = _a.toolboxItems;
        var classifier = new ToolboxItemClassifier_1.default();
        for (var _i = 0, toolboxItems_1 = toolboxItems; _i < toolboxItems_1.length; _i++) {
            var item = toolboxItems_1[_i];
            /* tslint:disable:no-any */
            var webPartManifest = item.itemProps.webPartManifest;
            /* tslint:enable:no-any */
            /**
             * Component manifests will be sent to the client regardless of flight status.
             * Currently checking the newsreel flight on client to hide the web part from the Toolbox
             * if the flight is not on. @todo [VSO:SPPPlat] #231682
             */
            if ((webPartManifest.id === NEWSREEL_ID && !sp_client_base_2.SPFlight.isEnabled(NEWSREEL_WEBPART_FLIGHT)) ||
                (webPartManifest.id === NEWSFEED_ID && !sp_client_base_2.SPFlight.isEnabled(NEWSFEED_WEBPART_FLIGHT))) {
                continue;
            }
            item.key = webPartManifest.id;
            item.onClick = onItemClick;
            item.msIconName = webPartManifest.preconfiguredEntries[0].officeFabricIconFontName;
            classifier.registerItem(webPartManifest.id, item);
        }
        // Construct the featured toolbox group
        var featuredItemViews = [];
        // First add the RTE to featured items
        featuredItemViews.push(React.createElement(ToolboxItem_1.default, {description: CanvasStrings_resx_1.default.TextWebpartDescription, displayName: CanvasStrings_resx_1.default.TextWebPartDisplayName, itemProps: { controlType: CanvasControlType_1.default.RTE, displayMode: sp_client_base_1.DisplayMode.Edit, id: undefined }, msIconName: 'Font', onClick: onItemClick}));
        // next get the featured items and add them to the toolbox
        var featuredItemProps = classifier.classify(true);
        featuredItemProps.forEach(function (item) {
            featuredItemViews.push(React.createElement(ToolboxItem_1.default, React.__spread({}, item)));
        });
        // Add them to the featured group
        var featuredGroup = React.createElement(ToolboxGroup_1.default, {groupName: CanvasStrings_resx_1.default.ToolboxGroupNameFeatured, key: CanvasStrings_resx_1.default.ToolboxGroupNameFeatured, hasHeader: true}, featuredItemViews);
        // Construct the non featured toolbox group
        var nonFeaturedItemViews = [];
        var nonFeaturedItemProps = classifier.classify(false, function (item1, item2) {
            return item1.displayName.localeCompare(item2.displayName);
        });
        nonFeaturedItemProps.forEach(function (item) {
            nonFeaturedItemViews.push(React.createElement(ToolboxItem_1.default, React.__spread({}, item)));
        });
        // Add them to the non featured group
        var nonFeaturedGroup = React.createElement(ToolboxGroup_1.default, {groupName: CanvasStrings_resx_1.default.ToolboxGroupNameNonFeatured, key: CanvasStrings_resx_1.default.ToolboxGroupNameNonFeatured, hasHeader: false}, nonFeaturedItemViews);
        return (React.createElement("div", {role: 'toolbar', className: 'CanvasToolbox', ref: function (ref) { return _this._domNode = ref; }, style: { display: isOpen ? 'block' : 'none', top: this.state.verticalPosition }}, React.createElement(FocusZone_1.FocusZone, {direction: FocusZone_1.FocusZoneDirection.horizontal, isCircularNavigation: true}, featuredGroup, nonFeaturedGroup)));
    };
    Toolbox.prototype._handleKeyDownCapture = function (e) {
        if (CanvasA11y_1.isEscape(e)) {
            this.context.store.a11yManager.restoreState();
            this.context.store.closeToolbox();
            e.stopPropagation();
            e.preventDefault();
        }
        else if (CanvasA11y_1.isTab(e)) {
            e.stopPropagation();
            e.preventDefault();
        }
    };
    Toolbox.contextTypes = {
        store: React.PropTypes.object.isRequired
    };
    return Toolbox;
}(React.Component));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Toolbox;

//# sourceMappingURL=Toolbox.js.map
