{"version":3,"sources":["local/appBase/components/canvas/sampleCanvasControls/WebPartZone.tsx"],"names":[],"mappings":"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","file":"local/appBase/components/canvas/sampleCanvasControls/WebPartZone.js","sourcesContent":["/**\r\n * @file WebPartZone.ts\r\n * @copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\n\r\nimport * as React from 'react';\r\nimport { DisplayMode } from '@microsoft/sp-client-base';\r\nimport { IClientSideWebPartManifest } from '@microsoft/sp-module-interfaces';\r\n\r\nimport ClientSideWebPartManager from '../../../../clientSideWebParts/core/ClientSideWebPartManager';\r\nimport { ICanvasContext } from '../../sp-canvas/canvas/canvasComponent/ICanvasComponent';\r\nimport ISerializedCanvasControl from '../canvas/ISerializedCanvasControl';\r\nimport IWebPartData from '../../../../clientSideWebParts/core/IWebPartData';\r\nimport IWebPartManagerContext from '../../../../clientSideWebParts/core/IWebPartManagerContext';\r\nimport { PropertyPaneState } from '../../../../common/webParts/PropertyPaneDefinitions';\r\nimport { getFirstFocusableChild } from '../../sp-canvas/a11y/CanvasA11y';\r\n\r\nexport interface IWebPartZoneState {\r\n  displayMode: DisplayMode;\r\n}\r\n\r\nexport interface IWebPartZoneProps extends ISerializedCanvasControl {\r\n  webPartData: IWebPartData;\r\n  webPartId: string;\r\n  /* tslint:disable:no-any */\r\n  webPartManifest: IClientSideWebPartManifest<any>;\r\n  /* tslint:enable:no-any */\r\n}\r\n\r\nexport default class WebPartZone extends React.Component<IWebPartZoneProps, IWebPartZoneState> {\r\n  public static contextTypes: React.ValidationMap<WebPartZone> = {\r\n    store: React.PropTypes.object.isRequired\r\n  };\r\n  public static webPartManagerInitialized: boolean = false;\r\n\r\n  public context: ICanvasContext;\r\n\r\n  /**\r\n   * Indicates whether the web part has loaded and is safe to perform synchronous actions.\r\n   */\r\n  private _isLoaded: boolean;\r\n\r\n  /**\r\n   * The promise is used to perform actions after the async loading of the web part code. The web\r\n   * part manager only creates a reference in its map after the web part code is loaded. Therefore,\r\n   * invoking methods on the web part manager that reference an unloaded web part is invalid.\r\n   */\r\n  private _loadWebPartPromise: Promise<void>;\r\n\r\n  private _webPartDiv: HTMLElement;\r\n  private _webPartManager: ClientSideWebPartManager;\r\n\r\n  constructor(props: IWebPartZoneProps, context: ICanvasContext) {\r\n    super(props, context);\r\n    this._webPartManager = this.context.store.webPartManager;\r\n\r\n    this.handleConfigureButtonClicked = this.handleConfigureButtonClicked.bind(this);\r\n    this.state = {\r\n      displayMode: this.props.displayMode\r\n    };\r\n  }\r\n\r\n  // @todo This is a workaround for deserialization of a Canvas without the manifests.\r\n  // We need to think about a longer term solution.\r\n  public componentDidMount(): void {\r\n    const context: IWebPartManagerContext = {\r\n      domElement: this._webPartDiv,\r\n      instanceId: this.props.id,\r\n      manifest: this.props.webPartManifest,\r\n      displayMode: this.props.displayMode,\r\n      webPartData: this.props.webPartData\r\n    };\r\n\r\n    this._loadWebPartPromise = this._webPartManager.loadWebPart(context).then(() => {\r\n      if (this.state.displayMode === DisplayMode.Edit && this.props.id === this.context.store.selectedControlId) {\r\n        this.context.store.webPartManager.configureStart(this.props.id);\r\n      }\r\n\r\n      // @todo: Currently loadWebPart() swallows exceptions\r\n      this._isLoaded = true;\r\n    });\r\n  }\r\n\r\n  public shouldComponentUpdate(newProps: IWebPartZoneProps, newState: IWebPartZoneState): boolean {\r\n    // Defer all updating to the web part manager and the web part\r\n    return false;\r\n  }\r\n\r\n  public render(): React.ReactElement<IWebPartZoneProps> {\r\n    return (\r\n      <div\r\n        ref={ (htmlElement: HTMLElement) => this._webPartDiv = htmlElement }\r\n        style= { { width: '100%' } } >\r\n      </div>\r\n    );\r\n  }\r\n\r\n  public get instanceId(): string {\r\n    return this.props.id;\r\n  }\r\n\r\n  public get isFocusable(): boolean {\r\n    return !!getFirstFocusableChild(this._webPartDiv);\r\n  }\r\n\r\n  public focus(): void {\r\n    if (!this.context.store.a11yManager.navigateInside(this._webPartDiv)) {\r\n      this.context.store.a11yManager.navigateOutOf(this._webPartDiv);\r\n    }\r\n  }\r\n\r\n  public handleConfigureButtonClicked(shouldToggle: boolean): void {\r\n    /**\r\n     * Using _isLoaded flag instead of the promise because we want a click on the configure button to\r\n     * no-op. If we had used a promise, the web part selection could have shifted by the time the\r\n     * loading is complete and thus incorrectly change the context of the property pane. A no-op makes\r\n     * sense because the web part would have no UI rendered yet, and the framework indicates the web part\r\n     * is still in the process of loading.\r\n     */\r\n    if (this._isLoaded) {\r\n      this._webPartManager.configureStart(\r\n        this.props.id,\r\n        shouldToggle ? PropertyPaneState.Toggle : PropertyPaneState.Open\r\n      );\r\n    }\r\n  }\r\n\r\n  public handleDeleteButtonClicked(): void {\r\n    /**\r\n     * If a web part was still in the process of loading and then the zone is deleted from the Canvas,\r\n     * we still want to ensure the web part manager cleans up its references and disposes the web part.\r\n     */\r\n    this._loadWebPartPromise.then(() => this._webPartManager.onWebPartDelete(this.props.id));\r\n  }\r\n\r\n  public serialize(): ISerializedCanvasControl {\r\n    const tempArray: string[] = [this.props.id];\r\n\r\n    /**\r\n     * If the web part has not loaded, we can safely return the web part data we are trying to load with because\r\n     * the data could not have been modified.\r\n     */\r\n    const webPartData: IWebPartData =\r\n      this._isLoaded ? this._webPartManager.serialize(tempArray).get(this.props.id) : this.props.webPartData;\r\n    const serialization: IWebPartZoneProps = JSON.parse(JSON.stringify(this.props));\r\n\r\n    serialization.webPartManifest = undefined;\r\n    serialization.webPartData = webPartData;\r\n\r\n    return serialization;\r\n  }\r\n\r\n  public setDisplayMode(newDisplayMode: DisplayMode): void {\r\n    this.setState({\r\n      displayMode: newDisplayMode\r\n    });\r\n\r\n    /**\r\n     * The Canvas zone will switch mode, and then wait for the web part to fully render before asking\r\n     * the web part manager to switch the mode of the web part.\r\n     */\r\n    this._loadWebPartPromise.then(() => this._webPartManager.setDisplayMode(newDisplayMode, this.props.id));\r\n  }\r\n}\r\n"],"sourceRoot":"/src"}