"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var React = require('react');
var ReactDOM = require('react-dom');
var sp_client_base_1 = require('@microsoft/sp-client-base');
var CanvasControlType_1 = require('./CanvasControlType');
var CanvasToolboxItemsGroup_1 = require('./CanvasToolboxItemsGroup');
require('./CanvasToolbox.scss');
var CanvasStrings_resx_1 = require('../../sp-canvas/loc/CanvasStrings.resx');
var CanvasToolbox = (function (_super) {
    __extends(CanvasToolbox, _super);
    function CanvasToolbox(props, context) {
        _super.call(this, props, context);
        this._handleToolboxItemClick = this._handleToolboxItemClick.bind(this);
        this._toolboxItems = new Map();
        this._toolboxItems.set('Text', [{
                defaultProps: {
                    displayMode: sp_client_base_1.DisplayMode.Edit
                },
                displayName: CanvasStrings_resx_1.default.ParagraphWebpartDisplayName,
                isWebPart: false,
                msIconName: 'text',
                reactClass: undefined,
                controlType: CanvasControlType_1.default.RTE
            }]);
        this._getWebPartManifests();
    }
    CanvasToolbox.prototype.componentDidMount = function () {
        this._domNode = ReactDOM.findDOMNode(this);
    };
    CanvasToolbox.prototype.componentDidUpdate = function () {
        if (this._domNode && this.props.isOpen) {
            // Re-poistion toolbox above the hint if it goes out of viewport
            var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
            if (this._domNode) {
                if (this._domNode.getBoundingClientRect().bottom > viewportHeight) {
                    var toolboxRect = this._domNode.getBoundingClientRect();
                    // Subtract the height of toolbox plus some margin (40px) to account for the hint height and its margin
                    var newTop = this.props.verticalPosition - (toolboxRect.bottom - toolboxRect.top) - 40;
                    // Open toolbox upwards only if it doesn't go out upwards
                    if (newTop > 0) {
                        this._domNode.style.top = newTop + 'px';
                    }
                    else {
                        // Toolbox doesn't fit in the viewport in any direction, scroll it into view
                        // This is an edge case where the window is way too small
                        this._domNode.scrollIntoView();
                    }
                }
            }
        }
    };
    CanvasToolbox.prototype.render = function () {
        var top = this.props.verticalPosition;
        var toolboxStyles = {
            top: top,
            display: this.props.isOpen ? 'block' : 'none'
        };
        return (React.createElement("div", {className: 'CanvasToolbox', style: toolboxStyles}, this._renderToolboxItemsGroups()));
    };
    CanvasToolbox.prototype._renderToolboxItemsGroups = function () {
        var _this = this;
        var toolboxGroups = [];
        this._toolboxItems.forEach(function (items, group) {
            toolboxGroups.push(React.createElement(CanvasToolboxItemsGroup_1.default, {groupName: group, key: group, onToolboxItemClick: _this._handleToolboxItemClick, toolboxItems: items}));
        });
        return toolboxGroups;
    };
    CanvasToolbox.prototype._getWebPartManifests = function () {
        var _this = this;
        this.context.store.serviceScope.whenFinished(function () {
            var environmentType = _this.context.store.serviceScope.consume(sp_client_base_1.environmentServiceKey).type;
            /**
             * Temporarily use g_webPartManifests to populate the toolbox because the
             * PageContext variable does not respect flights
             */
            /* tslint:disable:no-any */
            var manifests;
            /* tslint:enable:no-any */
            if (environmentType === sp_client_base_1.EnvironmentType.Local || environmentType === sp_client_base_1.EnvironmentType.Test) {
                manifests = _this.context.store.webPartManager.getWebParts();
            }
            else {
                manifests = [];
                /* tslint:disable:no-any */
                var globalManifests = window.g_webPartManifests || [];
                /* tslint:enable:no-any */
                for (var _i = 0, globalManifests_1 = globalManifests; _i < globalManifests_1.length; _i++) {
                    var manifest = globalManifests_1[_i];
                    if (manifest &&
                        manifest.componentType === 'WebPart') {
                        manifests.push(manifest);
                    }
                }
            }
            if (manifests) {
                for (var _a = 0, manifests_1 = manifests; _a < manifests_1.length; _a++) {
                    var webPartManifest = manifests_1[_a];
                    var item = {
                        controlType: CanvasControlType_1.default.WebPartZone,
                        defaultProps: {
                            webPartManifest: webPartManifest,
                            webPartData: undefined,
                            webPartId: webPartManifest.id
                        },
                        displayName: webPartManifest.preconfiguredEntries[0].title.default,
                        isWebPart: true,
                        msIconName: webPartManifest.preconfiguredEntries[0].officeFabricIconFontName
                    };
                    // Group property is optional. Classic web parts use Custom group if no group is defined.
                    if (!webPartManifest.preconfiguredEntries[0].group) {
                        webPartManifest.preconfiguredEntries[0].group = { default: 'Custom' };
                    }
                    var group = void 0;
                    if (group = _this._toolboxItems.get(webPartManifest.preconfiguredEntries[0].group.default)) {
                        group.push(item);
                    }
                    else {
                        _this._toolboxItems.set(webPartManifest.preconfiguredEntries[0].group.default, [item]);
                    }
                }
            }
        });
    };
    /* tslint:disable:no-any */
    CanvasToolbox.prototype._handleToolboxItemClick = function (controlType, itemProps) {
        /* tslint:enable:no-any */
        this.props.onToolboxItemClick(controlType, itemProps, this.props.rowIndex);
    };
    CanvasToolbox.contextTypes = {
        store: React.PropTypes.object.isRequired
    };
    return CanvasToolbox;
}(React.Component));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CanvasToolbox;

//# sourceMappingURL=CanvasToolbox.js.map
