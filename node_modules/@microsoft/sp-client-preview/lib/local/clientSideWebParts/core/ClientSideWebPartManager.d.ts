import { DisplayMode } from '@microsoft/sp-client-base';
import { IClientSideWebPartManifest } from '@microsoft/sp-module-interfaces';
import IWebPartData from './IWebPartData';
import IWebPartEvent from './IWebPartEvent';
import IWebPartHost from '../../common/webParts/IWebPartHost';
import IWebPartManagerContext from './IWebPartManagerContext';
import { PropertyPaneState } from '../../common/webParts/PropertyPaneDefinitions';
/**
 * The ClientSideWebPartManager is expected to be the external world interface to client side webparts. Each
 * host is expected to create an instance of this class and manage loading of all webparts in that host
 * through that one instance. e.g. On one page, if there are multiple Canvas objects, each one could have
 * one instance of this class. If the page hosts webparts without the Canvas, then the page can have an
 * instance of this class. Overall this class is expected to provide the following purpose:
 *
 *    - Orchestrates loading of one or more webparts in a host.
 *    - It takes care of loading webpart dependencies asynchronously. Each webpart loads completely
 *      independently of the other webparts in the host.
 *    - Keep a reference to all the loaded webparts and help provide bulk operations on the webparts.
 *    - Help manage memory leak type issues in one place.
 *    - Integrate the webparts with the PropertyPane and other external entities.
 *    - Help troubleshoot webparts during escalations.
 *
 *     loadWebPart   Load webpart in the provided host container. The host container can be a classic sharepoint page,
 *                   modern authoring canvas, or a custom sharepoint page.
 *     setDisplayMode    Switch mode of all webparts
 *     serialize     Return a serialized context of all webparts
 *     raiseEvent    Raise an event to the associated event aggregator
 *
 */
export default class ClientSideWebPartManager {
    /**
     * Dictionary of all the webparts
     */
    private _webparts;
    /**
     * Host that contains this instance.
     * Note, at the current time there is no support for multiple hostsand the host not is expected to change.
     */
    private _host;
    private _logSource;
    /**
     * GUID validation regex
     */
    private _guidRegex;
    /**
     * Reference to the propertypane controller.
     */
    private _propertyPaneController;
    /**
     * Timer to mark the canvas dirty.
     */
    private _dirtyBitTimer;
    /**
     * If true, webparts have already been fetched.
     */
    private _webpartsHaveBeenFetched;
    /**
     * Event aggregator instance scoped to this web part manager instance.
     */
    private _eventAggregator;
    /**
     * Web part status renderer instance scoped to this web part manager instance.
     */
    private _statusRenderer;
    /**
     * Page context reference.
     */
    private _pageContext;
    /**
     * Initialize the ClientSideWebPartManager.
     *
     * @param host - Reference to the host object. The host parameter is expetected to contain external
     *        world references. e.g. preloadedPageData, eventAggregator, etc...
     */
    constructor(host: IWebPartHost);
    /**
     * Load a webpart in the provided dom element. Does the following steps
     *
     *    - Validate params
     *    - Perform an async import of the bootstrapModule and preLoadModules from the provided manifest
     *    - Instantiate the webpart
     *    - Call the render method on the webpart object
     *
     * @param context - Web part manager context.
     */
    loadWebPart(context: IWebPartManagerContext): Promise<void>;
    /**
     * This makes a REST call to load the current site's webparts into the module loader.
     */
    fetchWebParts(): void;
    /**
     * Get list of active webparts
     *
     * @return {IClientSideWebPartManifest[]}: returns array of manifests
     */
    getWebParts(): IClientSideWebPartManifest<any>[];
    /**
     * Set the display mode of the specified web part. If no web part id is specified, switch mode of all web parts.
     * If the display mode passed is same as the current mode, no change is applied.
     *
     * @param {DisplayMode} mode: the new DisplayMode
     * @param {string} id: id of the webpart
     */
    setDisplayMode(mode: DisplayMode, id?: string): void;
    /**
     * Serialize the specified webparts. If no webparts are specified, serialize all webparts.
     *
     * @param {string[]} ids: Ids of the webparts
     */
    serialize(ids: string[]): Map<string, IWebPartData>;
    /**
     * Dispose the specified webparts. If no webparts are specified, dispose all webparts.
     *
     * @param {string[]} ids: Ids of the webparts
     */
    dispose(ids?: string[]): void;
    /**
     * Start the web part configuration process.
     *
     * @param id - web part id.
     * @param propertyPaneState - indicates in what state the PropertyPane should be.
     */
    configureStart(id: string, propertyPaneState?: PropertyPaneState): void;
    /**
      * Method to handle the webpart delete action.
      * @param id - id of the webpart which is deleted.
      */
    onWebPartDelete(id: string): void;
    /**
     * Raise an event to the associated event aggregator
     *
     * @param {string} eventName: Event name, such as 'configure:start'.
     * @param {Event} eventObject: object containing event properties.
     */
    raiseEvent<T>(eventName: string, event: IWebPartEvent<T>): void;
    /**
     * Render an error message in the web part container div.  Also logs the error message to the IWebPartHost logger.
     *
     * @param {domElement} domElement: Container div for the webpart
     * @param {Error} error: An error object containing the error message to render.
     * @return {void}
     */
    renderError(domElement: HTMLElement, error: Error): void;
    tryGeneratePreviewImageUrl(ids: string[]): string;
    /**
     * Internal method to validate and process input parameters
     *
     * @param context - provided webpart context
     */
    private _validateInput(context);
    /**
     * Validate the manifest
     *
     * @param {IClientSideWebPartManifest} manifest: webpart manifest
     * @param {DisplayMode} mode: display mode
     * @return true if the manifest is valid
     */
    private _validateManifest(manifest, mode);
    /**
     * Execute the provided callback for the list of provided webpart ids. If no list if provided,
     * execute the callback on all webparts.
     */
    private _executeForIdsOrAll(ids, cb);
    /**
     * Generate webpart context
     */
    private _getWebPartContext(context);
    private _instanceOfBase(wpi);
    private _getLoadedModuleList(moduleLibrary);
    /**
     * This is a temporary implementation of updating the host that a webpart has updated properties.
     * Currently we run a timer that regularly checks for updated properties and raises the dirty bit
     * handler to the host. @todo (VSO SPPPLAT#200728) tracks fixing this scenario in a better way.
     */
    private _startDirtyBitTimer(mode);
    /**
     * Creates a new QosMonitor with a scenario name specific to the web part type.
     */
    private _createQosMonitor(manifest);
    /**
     * Web part tag is unique per every web part instance.
     */
    private _createWebPartTag(manifest, instanceId);
    private _deleteWebPart(id);
    /**
     * Temporary fix till we have actual support for the multiple pre-configured entries feature.
     * (SPPPLAT VSO#232724)
     */
    private _getManifestInstance(context);
}
