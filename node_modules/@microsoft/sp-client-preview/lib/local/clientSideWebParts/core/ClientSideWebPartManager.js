/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * This file contains code for the ClientSideWebPartManager. The webart host is expected to
 * load and manage webparts through the webpart manager APIs.
 */
'use strict';
var lodash = require('@microsoft/sp-lodash-subset');
var sp_module_loader_1 = require('@microsoft/sp-module-loader');
var sp_client_base_1 = require('@microsoft/sp-client-base');
var odsp_utilities_bundle_1 = require('@ms/odsp-utilities-bundle');
var BaseClientSideWebPart_1 = require('./BaseClientSideWebPart');
var ClientSideWebPartStatusRenderer_1 = require('./ClientSideWebPartStatusRenderer');
var EventAggregator_1 = require('../../common/events/EventAggregator');
var Utils_1 = require('../../utilities/misc/Utils');
var PropertyPaneDefinitions_1 = require('../../common/webParts/PropertyPaneDefinitions');
var propertyPaneController_1 = require('../propertyPane/propertyPaneController/propertyPaneController');
var sp_client_base_2 = require('@microsoft/sp-client-base');
var Strings_resx_1 = require('./loc/Strings.resx');
var WebPartContext_1 = require('./WebPartContext');
/**
 * The ClientSideWebPartManager is expected to be the external world interface to client side webparts. Each
 * host is expected to create an instance of this class and manage loading of all webparts in that host
 * through that one instance. e.g. On one page, if there are multiple Canvas objects, each one could have
 * one instance of this class. If the page hosts webparts without the Canvas, then the page can have an
 * instance of this class. Overall this class is expected to provide the following purpose:
 *
 *    - Orchestrates loading of one or more webparts in a host.
 *    - It takes care of loading webpart dependencies asynchronously. Each webpart loads completely
 *      independently of the other webparts in the host.
 *    - Keep a reference to all the loaded webparts and help provide bulk operations on the webparts.
 *    - Help manage memory leak type issues in one place.
 *    - Integrate the webparts with the PropertyPane and other external entities.
 *    - Help troubleshoot webparts during escalations.
 *
 *     loadWebPart   Load webpart in the provided host container. The host container can be a classic sharepoint page,
 *                   modern authoring canvas, or a custom sharepoint page.
 *     setDisplayMode    Switch mode of all webparts
 *     serialize     Return a serialized context of all webparts
 *     raiseEvent    Raise an event to the associated event aggregator
 *
 */
var ClientSideWebPartManager = (function () {
    /**
     * Initialize the ClientSideWebPartManager.
     *
     * @param host - Reference to the host object. The host parameter is expetected to contain external
     *        world references. e.g. preloadedPageData, eventAggregator, etc...
     */
    function ClientSideWebPartManager(host) {
        /**
         * Dictionary of all the webparts
         */
        this._webparts = new Map();
        /*
         * WebPart manager log source
         */
        this._logSource = sp_client_base_1._LogSource.create('ClientSideWebPartManager');
        /**
         * GUID validation regex
         */
        this._guidRegex = new RegExp('^[a-z0-9]{8}(-([0-9a-fA-F]){4}){3}-[a-z0-9]{12}$', 'i');
        /**
         * If true, webparts have already been fetched.
         */
        this._webpartsHaveBeenFetched = false;
        /**
         * Event aggregator instance scoped to this web part manager instance.
         */
        this._eventAggregator = new EventAggregator_1.default();
        /**
         * Web part status renderer instance scoped to this web part manager instance.
         */
        this._statusRenderer = new ClientSideWebPartStatusRenderer_1.default();
        sp_client_base_1.Validate.isNotNullOrUndefined(host, 'host');
        this._host = host;
        this._pageContext = host.serviceScope.consume(sp_client_base_1.pageContextServiceKey);
        this.configureStart = this.configureStart.bind(this);
    }
    /**
     * Load a webpart in the provided dom element. Does the following steps
     *
     *    - Validate params
     *    - Perform an async import of the bootstrapModule and preLoadModules from the provided manifest
     *    - Instantiate the webpart
     *    - Call the render method on the webpart object
     *
     * @param context - Web part manager context.
     */
    ClientSideWebPartManager.prototype.loadWebPart = function (context) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._validateInput(context);
            // If manifest is null, we should display an error. This can be a legitimate case when the manifest has
            // been deleted or webpart removed from the tenant level repository or the webpart is not being shipped
            // anymore but some page still contains
            // a reference to an instance of that webpart.
            if (!_this._validateManifest(context.manifest, context.displayMode)) {
                _this.renderError(context.domElement, new Error(odsp_utilities_bundle_1.StringHelper.format(Strings_resx_1.default.ManifestNullError, context.instanceId)));
                return;
            }
            /* tslint:disable:no-any */
            var manifest = context.manifest;
            /* tslint:enable:no-any */
            var instanceId = context.instanceId;
            var domElement = context.domElement;
            // Performance and QOS markers
            var performanceTag = _this._createWebPartTag(manifest, instanceId);
            var qosMonitor = _this._createQosMonitor(manifest);
            sp_client_base_1._PerformanceLogger.addComponent(performanceTag);
            sp_client_base_1._PerformanceLogger.startMarkForComponent(performanceTag);
            // Start the loading indicator
            _this._statusRenderer.displayLoadingIndicator(domElement, manifest.preconfiguredEntries[0].title.default.toString());
            /* tslint:disable:no-any */
            var modulePromise = sp_module_loader_1.default.loadManifestModules(manifest.id);
            /* tslint:enable:no-any */
            if (modulePromise) {
                modulePromise.then(
                /* tslint:disable:no-any */
                function (moduleLibrary) {
                    sp_client_base_1._PerformanceLogger.markComponent(performanceTag, 'modulesLoaded');
                    /* tslint:enable:no-any */
                    _this._statusRenderer.clearLoadingIndicator(context.domElement);
                    sp_client_base_1._TraceLogger.logVerbose(_this._logSource, "Successfully loaded modules for webpart " + manifest.id);
                    if (!moduleLibrary) {
                        throw new Error(Strings_resx_1.default.UndefinedModule);
                    }
                    try {
                        /* tslint:disable:no-any */
                        var wp = moduleLibrary;
                        /* tslint:enable:no-any */
                        // If the webpart has a default export, use that.
                        if (wp && wp.default) {
                            wp = wp.default;
                        }
                        if (!wp) {
                            var message = odsp_utilities_bundle_1.StringHelper.format(Strings_resx_1.default.ModuleNotLoaded, manifest.id, manifest.id, _this._getLoadedModuleList(moduleLibrary));
                            throw new Error(message);
                        }
                        if (typeof (wp) !== 'function' && wp.default) {
                            wp = wp.default;
                        }
                        if (typeof (wp) !== 'function') {
                            throw new Error(odsp_utilities_bundle_1.StringHelper.format(Strings_resx_1.default.IncorrectBoostrapModule, manifest.id));
                        }
                        var typedWp = wp;
                        // @todo: add a mechanism to detect webpart DOM node removal such that if the app
                        // is switching between SPA pages, we can make sure webparts are consistently and
                        // appropriately disposed. VSO#144986.
                        var wpi = new typedWp(_this._getWebPartContext(context));
                        _this._webparts.set(instanceId, wpi);
                        // Start the dirty bit timer if required
                        _this._startDirtyBitTimer(context.displayMode);
                        // If the webpart is derived from the base class, we want to enforce a stricter call flow
                        // which will lead to simpler webpart code.
                        if (_this._instanceOfBase(wpi)) {
                            // internal render will write out specific failures
                            return wpi._internalFirstTimeRender(context.displayMode, qosMonitor, context.webPartData).then(function () {
                                qosMonitor.writeSuccess();
                                sp_client_base_1._PerformanceLogger.endMarkForComponent(performanceTag);
                                resolve();
                            });
                        }
                        else {
                            throw new Error(Strings_resx_1.default.NonBaseWebPart);
                        }
                    }
                    catch (ex) {
                        var wpi_1 = _this._webparts.get(instanceId);
                        if (wpi_1) {
                            Utils_1.executeWithoutFailing(function () { _this._statusRenderer.clearLoadingIndicator(domElement); }, _this._logSource);
                            Utils_1.executeWithoutFailing(function () { wpi_1._internalDispose(); }, _this._logSource);
                            Utils_1.executeWithoutFailing(function () { _this._webparts.delete(instanceId); }, _this._logSource);
                        }
                        Utils_1.executeWithoutFailing(function () {
                            qosMonitor.writeUnexpectedFailure('UnhandledLoadError', ex, { 'instanceId': instanceId });
                        }, _this._logSource);
                        _this.renderError(domElement, ex);
                        reject();
                    }
                }).catch(function (errorMsg) {
                    var err = new Error(odsp_utilities_bundle_1.StringHelper.format(Strings_resx_1.default.ScriptLoadErrorTemplate, errorMsg));
                    Utils_1.executeWithoutFailing(function () {
                        qosMonitor.writeUnexpectedFailure('ScriptLoad', err, { 'instanceId': instanceId });
                    }, _this._logSource);
                    _this.renderError(domElement, err);
                    reject();
                });
            }
            else {
                var error = new Error("No loader could be found, unable to load webpart " + manifest.id + ".");
                _this.renderError(domElement, error);
                reject();
            }
        });
    };
    /**
     * This makes a REST call to load the current site's webparts into the module loader.
     */
    ClientSideWebPartManager.prototype.fetchWebParts = function () {
        var _this = this;
        // If the webServerRelativeUrl is missing, or if webparts have already been fetched
        //  we don't have anything to do here.
        if (this._pageContext.web &&
            this._pageContext.web.serverRelativeUrl &&
            !this._webpartsHaveBeenFetched) {
            this._webpartsHaveBeenFetched = true;
            var requestUrl_1 = this._pageContext.web.serverRelativeUrl + "/_api/web/GetClientSideWebParts";
            this._host.serviceScope.whenFinished(function () {
                var httpClient = _this._host.serviceScope.consume(sp_client_base_1.httpClientServiceKey);
                httpClient.get(requestUrl_1)
                    .then(function (response) {
                    return response.json();
                })
                    .then(function (value) {
                    var manifests = value.value.map(function (manifestObject) {
                        return JSON.parse(manifestObject.Manifest);
                    });
                    sp_module_loader_1.default.importManifests(manifests, /* overwriteExisting */ false);
                })
                    .catch(function (error) {
                    console.error("Error loading webparts: " + error);
                    _this._webpartsHaveBeenFetched = false;
                });
            });
        }
    };
    /**
     * Get list of active webparts
     *
     * @return {IClientSideWebPartManifest[]}: returns array of manifests
     */
    /* tslint:disable:no-any */
    ClientSideWebPartManager.prototype.getWebParts = function () {
        /* tslint:enable:no-any */
        var manifests = sp_module_loader_1.default.getManifests();
        /* tslint:disable:no-any */
        var result = [];
        /* tslint:enable:no-any */
        if (manifests) {
            for (var _i = 0, manifests_1 = manifests; _i < manifests_1.length; _i++) {
                var manifest = manifests_1[_i];
                if (manifest &&
                    manifest.componentType === 'WebPart') {
                    /* tslint:disable:no-any */
                    result.push(manifest);
                }
            }
        }
        return result;
    };
    /**
     * Set the display mode of the specified web part. If no web part id is specified, switch mode of all web parts.
     * If the display mode passed is same as the current mode, no change is applied.
     *
     * @param {DisplayMode} mode: the new DisplayMode
     * @param {string} id: id of the webpart
     */
    ClientSideWebPartManager.prototype.setDisplayMode = function (mode, id) {
        var cb = function (wp) {
            if (wp) {
                wp._internalSetDisplayMode(mode);
            }
        };
        if (id) {
            var wp = this._webparts.get(id);
            if (wp) {
                wp._internalSetDisplayMode(mode);
            }
        }
        else {
            this._executeForIdsOrAll(undefined, cb);
        }
        // Start the dirty bit timer if required
        this._startDirtyBitTimer(mode);
    };
    /**
     * Serialize the specified webparts. If no webparts are specified, serialize all webparts.
     *
     * @param {string[]} ids: Ids of the webparts
     */
    ClientSideWebPartManager.prototype.serialize = function (ids) {
        var sd = new Map();
        var cb = function (wp, id) {
            if (wp) {
                sd.set(id, wp._internalSerialize());
            }
        };
        this._executeForIdsOrAll(ids, cb);
        return sd;
    };
    /**
     * Dispose the specified webparts. If no webparts are specified, dispose all webparts.
     *
     * @param {string[]} ids: Ids of the webparts
     */
    ClientSideWebPartManager.prototype.dispose = function (ids) {
        var _this = this;
        var cb = function (wp, id) {
            if (wp) {
                wp._internalDispose();
                _this._deleteWebPart(id);
            }
        };
        this._executeForIdsOrAll(ids, cb);
    };
    /**
     * Start the web part configuration process.
     *
     * @param id - web part id.
     * @param propertyPaneState - indicates in what state the PropertyPane should be.
     */
    ClientSideWebPartManager.prototype.configureStart = function (id, propertyPaneState) {
        var _this = this;
        if (propertyPaneState === void 0) { propertyPaneState = PropertyPaneDefinitions_1.PropertyPaneState.Default; }
        if (!this._propertyPaneController) {
            this._propertyPaneController =
                new propertyPaneController_1.default(function (wpId) {
                    return _this._webparts.get(wpId);
                }, this._host.webPartConfigurationEventCallback);
        }
        this._propertyPaneController.configureStart(id, propertyPaneState);
    };
    /**
      * Method to handle the webpart delete action.
      * @param id - id of the webpart which is deleted.
      */
    ClientSideWebPartManager.prototype.onWebPartDelete = function (id) {
        this._deleteWebPart(id);
    };
    /**
     * Raise an event to the associated event aggregator
     *
     * @param {string} eventName: Event name, such as 'configure:start'.
     * @param {Event} eventObject: object containing event properties.
     */
    ClientSideWebPartManager.prototype.raiseEvent = function (eventName, event) {
        this._eventAggregator.raiseEvent(eventName, event);
    };
    /**
     * Render an error message in the web part container div.  Also logs the error message to the IWebPartHost logger.
     *
     * @param {domElement} domElement: Container div for the webpart
     * @param {Error} error: An error object containing the error message to render.
     * @return {void}
     */
    ClientSideWebPartManager.prototype.renderError = function (domElement, error) {
        var _this = this;
        Utils_1.executeWithoutFailing(function () {
            _this._statusRenderer.renderError(domElement, error);
            sp_client_base_1._TraceLogger.logError(_this._logSource, error);
        }, this._logSource);
    };
    /*
     * Get the first webpart with preview image url specified
     *
     * @param {string[]} ids: Ids of the webparts
     */
    ClientSideWebPartManager.prototype.tryGeneratePreviewImageUrl = function (ids) {
        var previewImageUrl = undefined;
        var cb = function (wp, id) {
            // workaround for typescript targeting es5 only support for...of for array and string
            // also Map does not support some or every
            // @todo: Bug 222340 when switching to es6, use for...of and return after first match
            if (!previewImageUrl) {
                previewImageUrl = wp.previewImageUrl;
            }
        };
        this._executeForIdsOrAll(ids, cb);
        return previewImageUrl;
    };
    /**
     * Internal method to validate and process input parameters
     *
     * @param context - provided webpart context
     */
    ClientSideWebPartManager.prototype._validateInput = function (context) {
        sp_client_base_1.Validate.isNotNullOrUndefined(context, 'webpart manager context');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.domElement, 'webpart element');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.instanceId, 'webpart instanceId');
        sp_client_base_1.Validate.isTrue(!this._webparts.get(context.instanceId), 'Duplicate webpart id not allowed');
    };
    /**
     * Validate the manifest
     *
     * @param {IClientSideWebPartManifest} manifest: webpart manifest
     * @param {DisplayMode} mode: display mode
     * @return true if the manifest is valid
     */
    /* tslint:disable:no-any */
    ClientSideWebPartManager.prototype._validateManifest = function (manifest, mode) {
        /* tslint:enable:no-any */
        // If the manifest is null, then
        //    In read mode, we throw as the host should never attempt to load the webpart without the manifest.
        //    In edit mode, we should display an error
        if (!manifest) {
            if (mode === sp_client_base_1.DisplayMode.Read) {
                // Note: not localizing this expception on purpose. This is an internal error that users should never see.
                throw new Error('Null manifest. Code should never reach here in Read mode. The host should not attempt to ' +
                    'display the webpart if the manifest is null.');
            }
            else {
                return false;
            }
        }
        // Clone the manifest and then validate the clone. This way we make sure there are no functions and other
        // non-field based types in the manifest
        /* tslint:disable:no-any */
        var cm = lodash.cloneDeep(manifest);
        /* tslint:enable:no-any */
        /* tslint:disable:triple-equals */
        sp_client_base_1.Validate.isTrue(cm.manifestVersion == 1 || cm.manifestVersion == 2, 'Only version 1 manifests are currently supported');
        /* tslint:enable:triple-equals */
        sp_client_base_1.Validate.isTrue(!!cm.id, 'webpart id cannot be null or undefined');
        sp_client_base_1.Validate.isTrue(this._guidRegex.test(cm.id), 'webpart id has to be a GUID');
        sp_client_base_1.Validate.isTrue(!!cm.version, 'webpart version cannot be null or undefined');
        return true;
    };
    /**
     * Execute the provided callback for the list of provided webpart ids. If no list if provided,
     * execute the callback on all webparts.
     */
    ClientSideWebPartManager.prototype._executeForIdsOrAll = function (ids, cb) {
        var _this = this;
        if (ids) {
            ids.forEach(function (id) {
                var wp = _this._webparts.get(id);
                cb(wp, id);
            });
        }
        else {
            this._webparts.forEach(function (wp, id) {
                cb(wp, id);
            });
        }
    };
    /**
     * Generate webpart context
     */
    ClientSideWebPartManager.prototype._getWebPartContext = function (context) {
        return new WebPartContext_1.default(context, this._getManifestInstance(context), this._host, this._statusRenderer, this._eventAggregator, this.configureStart, this._createWebPartTag(context.manifest, context.instanceId));
    };
    /* tslint:disable:no-any */
    ClientSideWebPartManager.prototype._instanceOfBase = function (wpi) {
        /* tslint:enable:no-any */
        /* tslint:disable:no-string-literal */
        return wpi instanceof BaseClientSideWebPart_1.default || wpi['__type'] === 'BaseClientSideWebPart';
        /* tslint:enable:no-string-literal */
    };
    ClientSideWebPartManager.prototype._getLoadedModuleList = function (moduleLibrary) {
        var loadedModulesString = '';
        for (var m in moduleLibrary) {
            if (moduleLibrary.hasOwnProperty(m)) {
                if (loadedModulesString) {
                    loadedModulesString += ',';
                }
                loadedModulesString += "" + m;
            }
        }
        return loadedModulesString;
    };
    /**
     * This is a temporary implementation of updating the host that a webpart has updated properties.
     * Currently we run a timer that regularly checks for updated properties and raises the dirty bit
     * handler to the host. @todo (VSO SPPPLAT#200728) tracks fixing this scenario in a better way.
     */
    ClientSideWebPartManager.prototype._startDirtyBitTimer = function (mode) {
        var _this = this;
        // Clear the timer in read mode
        if (mode === sp_client_base_1.DisplayMode.Read) {
            if (this._dirtyBitTimer) {
                window.clearInterval(this._dirtyBitTimer);
                this._dirtyBitTimer = undefined;
            }
        }
        else if (!this._dirtyBitTimer) {
            var cb_1 = function (wp) {
                if (wp) {
                    wp._internalSetDirtyBit();
                }
            };
            this._dirtyBitTimer = window.setInterval(function () {
                _this._executeForIdsOrAll(undefined, cb_1);
            }, 1000);
        }
    };
    /**
     * Creates a new QosMonitor with a scenario name specific to the web part type.
     */
    /* tslint:disable:no-any */
    ClientSideWebPartManager.prototype._createQosMonitor = function (manifest) {
        /* tslint:enable:no-any */
        return new sp_client_base_2._QosMonitor("WebPart." + manifest.id);
    };
    /**
     * Web part tag is unique per every web part instance.
     */
    /* tslint:disable:no-any */
    ClientSideWebPartManager.prototype._createWebPartTag = function (manifest, instanceId) {
        /* tslint:enable:no-any */
        return "WebPart." + manifest.id + "." + instanceId;
    };
    ClientSideWebPartManager.prototype._deleteWebPart = function (id) {
        sp_client_base_1.Validate.isNotNullOrUndefined(id, 'id');
        // Adding this condition because, this method can be called before instantiating
        // propertypanecontroller. Instantiation happens only when user clicks 'ConfigureStart'.
        if (this._propertyPaneController) {
            this._propertyPaneController.onWebPartDelete(id);
        }
        this._webparts.delete(id);
    };
    /**
     * Temporary fix till we have actual support for the multiple pre-configured entries feature.
     * (SPPPLAT VSO#232724)
     */
    /* tslint:disable:no-any */
    ClientSideWebPartManager.prototype._getManifestInstance = function (context) {
        var manifest = context.manifest;
        var manifestClone = lodash.cloneDeep(manifest);
        delete manifestClone.preconfiguredEntries;
        var manifestInstance = manifestClone;
        /* tslint:enable:no-any */
        lodash.merge(manifestInstance, manifest.preconfiguredEntries[0]);
        return manifestInstance;
    };
    return ClientSideWebPartManager;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ClientSideWebPartManager;

//# sourceMappingURL=ClientSideWebPartManager.js.map
