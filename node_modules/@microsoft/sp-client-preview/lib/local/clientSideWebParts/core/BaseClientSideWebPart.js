/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file Base class for client side web parts.
 */
/* tslint:disable:member-ordering */
'use strict';
var lodash = require('@microsoft/sp-lodash-subset');
var odsp_utilities_bundle_1 = require('@ms/odsp-utilities-bundle');
var sp_client_base_1 = require('@microsoft/sp-client-base');
var PropertyPaneDefinitions_1 = require('../../common/webParts/PropertyPaneDefinitions');
var Object_1 = require('../../utilities/misc/Object');
var Strings_resx_1 = require('./loc/Strings.resx');
var cswp_base_module_scss_1 = require('./styles/cswp-base.module.scss');
require('./styles/cswp-loading-spinner.scss');
/**
 * This abstract class implements the the base functionality for a client side web part. Every client side web part
 * needs to inherit from this class. Along with the base functionality, this class provides some APIs that can be
 * used by the web part. These APIs fall in two catagories.
 *
 * The first category of APIs provide data and functionality. Example, the web part context (i.e. this.context). This
 * API should be used to access contextual data relevant to this web part instance.
 *
 * The second category of APIs provide a base implementation for the web part lifecycle and can be overridden for an
 * updated implementation. The render() API is the only API that is mandatory to be implemented/overridden by a web
 * part. All other life cycle APIs have a base implementation and can be overridden based on the needs of the web part.
 * Please refer to the documentation of the individual APIs to make the right decision.
 */
var BaseClientSideWebPart = (function () {
    /**
     * Constructor for the BaseClientSideWebPart class.
     * If a sub class overrides the constructor, it needs to call super(context) as the first line of its constructor.
     *
     * @param context - web part context.
     *
     * e.g.
     *   constructor(conext: IWebPartContext) {
     *     super(context);
     *     .
     *     . class specific constructor code ..
     *   }
     */
    function BaseClientSideWebPart(ctx) {
        this._initialized = false;
        this._logSource = sp_client_base_1._LogSource.create('BaseClientSideWebPart');
        // Disallow instantiation of the base class by itself
        /* tslint:disable:no-string-literal */
        if (this.constructor['name'] === 'BaseClientSideWebPart') {
            /* tslint:enable:no-string-literal */
            throw new Error(Strings_resx_1.default.BaseConstructError);
        }
        /* tslint:disable:use-named-parameter */
        var context = arguments[0];
        /* tslint:enable:use-named-parameter */
        this._processInputParams(context);
        sp_client_base_1._TraceLogger.logVerbose(this._logSource, odsp_utilities_bundle_1.StringHelper.format(Strings_resx_1.default.ConstructLog, this.context.instanceId));
        this._initialized = true;
        this._renderedOnce = false;
        /* tslint:disable:no-string-literal */
        this['__type'] = 'BaseClientSideWebPart';
        /* tslint:enable:no-string-literal */
        // Bind the callbacks
        this.render = this.render.bind(this);
        this.dispose = this.dispose.bind(this);
        this.renderError = this.renderError.bind(this);
        this.clearError = this.clearError.bind(this);
        this.onPropertyConfigurationComplete = this.onPropertyConfigurationComplete.bind(this);
        this.onPropertyPaneRendered = this.onPropertyPaneRendered.bind(this);
    }
    Object.defineProperty(BaseClientSideWebPart.prototype, "context", {
        // Readonly protected properties. To change these to readonly once TypeScript supports that feature.
        /**
         * This property is a pointer to the web part context.
         * @see IWebPartContex for more details.
         *
         * @readonly
         */
        get: function () { return this._context; },
        /**
         * Error on attempt to set readonly properties. The following properties will go away when TypeScript supports
         * readonly.
         * @internal
         */
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "domElement", {
        /**
         * This property is a pointer to the root DOM element of the web part. This is a DIV element and contains the whole
         * DOM subtree of the web part.
         *
         * @readonly
         */
        get: function () { return this._context.domElement; },
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "displayMode", {
        /**
         * This property is the current display mode of the web part.
         *
         * @readonly
         */
        get: function () { return this._displayMode; },
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "properties", {
        /**
         * This property is the pointer to the custom property bag of the web part.
         *
         * @readonly
         */
        get: function () { return this._properties; },
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "renderedOnce", {
        /**
         * This property indicates whether the web part has been rendered once or not. After the first time rendering,
         * the value of this property is always true. Till a full re-render of the web part happens.
         *
         * @readonly
         */
        get: function () { return this._renderedOnce; },
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "renderedFromDefaultProperties", {
        /**
         * This property indicates whether the web part was rendered from the default properties, as opposed to using
         * serialized state from the last time that the web part was saved.
         *
         * @readonly
         */
        get: function () { return this._renderedFromDefaultProperties; },
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "propertyPaneSettings", {
        /**
         * This property is the pointer to the web part configuration settings. If the web part wants to use the PropertyPane
         * for configuration, this API needs to be overridden and the web part needs to return the set of properties it wants
         * to display in the PropertyPane.
         *
         * @see IPropertyPane and other PropertyPane integration wiki documentation for more details.
         *
         * @readonly
         */
        get: function () { return undefined; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "disableReactivePropertyChanges", {
        /**
         * This property is used to change the web part's PropertyPane interaction from Reactive to NonReactive. The default
         * behaviour is Reactive. Where,
         * Reactive implies that changes made in the PropertyPane are transmitted to the web part instantly and the user can
         * see instant updates. This helps the page creator get instant feedback and decide if they should keep the new
         * configuration changes or not.
         * NonReactive implies that the configuraiton changes are transmitted to the web part only after 'Apply' PropertyPane
         * button is clicked.
         *
         * @readonly
         */
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "previewImageUrl", {
        /**
         * This property points to the preview image for the web part. The base implementation returns undefined. Web parts
         * that want to provide a valid preview image url need to override this API. The preview image url can be used to
         * create a preview of the web part or of the page on which the web part is present.
         *
         * @readonly
         */
        get: function () { return undefined; },
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "accessibleTitle", {
        /**
         * This property points to the accessible title of web part made available to screen readers. The base implementation
         * returns that default title in the manifest. Web parts that want to provide more descriptive title containing
         * contextual information need to override this API.
         *
         * @readonly
         */
        get: function () { return this._getDefaultAccessibleTitle(); },
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "manifest", {
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "instanceId", {
        set: function (o) { this._throwReadOnlyError(); },
        enumerable: true,
        configurable: true
    });
    /**
     * This API is called once during the lifetime of the web part during the intial render and just before the onInit
     * API call. The purpose of this API is to help a web part developer deserialize the web part data and manage the
     * versioning of their data as the web part code evolves. The web part data may have been persisted with an older
     * or newer version of the web part code. This API gives the web part developer an opportunity to re-structure their
     * data to the appropriate data schema. The persisted data contains the version number information. That information
     * can be used to make decisions on how to re-structure the data.
     *
     * @param data - web part persisted data.
     * @return - web part property bag.
     *
     */
    BaseClientSideWebPart.prototype.deserialize = function (data) {
        return undefined;
    };
    /**
     * This API should be overridden to perform long running operations e.g. data fetching from a remote service before
     * the initial rendering of the web part. The loading indicator is displayed during the lifetime of this method.
     * This API is called only once during the lifecycle of a web part.
     */
    BaseClientSideWebPart.prototype.onInit = function () {
        return this._genericAsyncHandler();
    };
    /**
     * This API is called to render the web part. There is no base implementation of this API and the web part is
     * required to override this API.
     */
    BaseClientSideWebPart.prototype.render = function () {
        throw new Error(Strings_resx_1.default.MustOverrideRenderError);
    };
    /**
     * This API is called when the display mode of a web part is changed. The default implementation of this API calls
     * the web part render method to re-render the web part with the new display mode. If a web part developer does not
     * want a full re-render to happen on display mode change, they can override this API and perform specific updates
     * to the web part DOM to switch its display mode.
     *
     * @param oldDisplayMode - The old display mode.
     *
     */
    BaseClientSideWebPart.prototype.onDisplayModeChanged = function (oldDisplayMode) {
        // This API should not be called when there was no change in display mode.
        sp_client_base_1.Validate.isTrue(oldDisplayMode !== this.displayMode, Strings_resx_1.default.OnDisplayModeChangedInvalidInvocation);
        this._renderWithAccessibileTitle();
    };
    /**
     * This API is called before a web part is serialized. The default implementation is a no-op. A web part developer
     * is expected to override this API when the web part's state is not fully reflected in the property bag i.e.
     * this.properties. In the overridden method, the web part developer is expected to update the state of the web
     * part property bag. This way the web part serialization process will use the upto date state of the web part.
     *
     * @return - reference to searchable properties and properties that need link fixup. Please read
     * the documentation of IHtmlProperties interface for more details.
     */
    BaseClientSideWebPart.prototype.onBeforeSerialize = function () {
        return undefined;
    };
    /**
     * This API is used to receive custom event notifications from the host page or another web part. ReservedEventNames
     * defines some reserved events. Each web part may process web part specific events.
     *
     * @param eventName - Event name, such as "configure:start".
     * @param eventObject - object containing event source, destination and property information.
     *
     * @internal
     */
    BaseClientSideWebPart.prototype.onEvent = function (eventName, eventObject) {
        /* EMPTY BLOCK */
    };
    /**
     * This API is called at the end of the web part lifecycle. It should be overridden to dispose any
     * resources that the web part is holding onto.
     */
    BaseClientSideWebPart.prototype.dispose = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API should be used to invoke the PropertyPane to help configure the web part.
     *
     * @param boolean - If specified and true - refresh a PropertyPane that's already been open, but not open
     * if it is not already open.
     */
    BaseClientSideWebPart.prototype.configureStart = function (refreshOnly) {
        var state = refreshOnly ? PropertyPaneDefinitions_1.PropertyPaneState.Default : PropertyPaneDefinitions_1.PropertyPaneState.Open;
        this._context.configureStart(this.context.instanceId, state);
    };
    /**
     * This API is invoked on property changes in the PropertyPane when the PropertyPane is being used in Reactive mode.
     * The base implementation of this API updates the web part property bag and re-render the web part. This API also
     * invokes the web part host's setDirty API.
     *
     * @param propertyPath - JSON path of the property in the property bag.
     * @param newValue - New value of the property.
     */
    /* tslint:disable:no-any */
    BaseClientSideWebPart.prototype.onPropertyChange = function (propertyPath, newValue) {
        /* tslint:enable:no-any */
        this._updateProperty(propertyPath, newValue);
        if (this.context.host.setDirty) {
            this.context.host.setDirty(this.context.instanceId);
        }
        if (!this.disableReactivePropertyChanges) {
            this._renderWithAccessibileTitle();
        }
    };
    /**
     * This API is called when the current web part configuration process is completed. ConfigurationComplete event
     * is fired when user switches between web parts while the PropertyPane is open, and this event handler is called
     * for the previously selected web part.
     *
     */
    BaseClientSideWebPart.prototype.onPropertyConfigurationComplete = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API is involed when the PropertyPane is rendered.
     */
    BaseClientSideWebPart.prototype.onPropertyPaneRendered = function () {
        /* EMPTY BLOCK */
    };
    /**
     * this API is invoked when the the changes are applied on the PropertyPane when the PropertyPane is used in
     * Non-Reactive mode. This API is not invoked when the PropertyPane is used in Reactive mode.
     */
    BaseClientSideWebPart.prototype.onPropertyPaneSave = function () {
        if (this.disableReactivePropertyChanges) {
            this._renderWithAccessibileTitle();
        }
        this._propertiesBackup = undefined;
    };
    /**
     * This API should be used to render an error message in the web part display area. Also logs the error message
     * using the trace logger.
     *
     * @param error - An error object containing the error message to render.
     */
    BaseClientSideWebPart.prototype.renderError = function (error) {
        this.context.statusRenderer.clearLoadingIndicator(this.domElement);
        this.context.statusRenderer.renderError(this.domElement, error);
        sp_client_base_1._TraceLogger.logError(this._logSource, error);
    };
    /**
     * This API should be used to clear the error message from the web part display area.
     */
    BaseClientSideWebPart.prototype.clearError = function () {
        this.context.statusRenderer.clearError(this.domElement);
    };
    /**
     * Internal base implemenation of the web part data deserialization.
     *
     * @param data - web part data
     */
    BaseClientSideWebPart.prototype._internalDeserialize = function (data) {
        if (data && data.properties) {
            // Give the web part an opportunity to deserialize the properties. If the web part
            // returns a valid property bag, use it as is else perform default deserialization.
            var p = this.deserialize(data);
            if (p) {
                this._properties = p;
            }
            else {
                this._properties = data.properties;
                this._renderedFromDefaultProperties = false;
                // @todo: (SPPPLAT VSO#227730) removing a regression caused by manifest V2 change. The manifest
                // is a part of the properties blob. Which then gets serialized into the page blob.
                /* tslint:disable:no-string-literal */
                delete data.properties['manifest'];
            }
        }
        else {
            this._renderedFromDefaultProperties = true;
        }
    };
    /**
     * Internal API for the first time render of the web part. The purpose of this API is to enforce intialization steps
     * before the actual render is called. This API is called only once during the web part loading lifecycle.
     *
     * @return {Promise<void>} The promise indicates the render loop is finished (success or fail).
     */
    /* tslint:disable:no-unused-variable */
    BaseClientSideWebPart.prototype._internalFirstTimeRender = function (mode, qosMonitor, data) {
        var _this = this;
        if (mode === void 0) { mode = sp_client_base_1.DisplayMode.Read; }
        /* tslint:enable:no-unused-variable */
        if (!this._initialized) {
            qosMonitor.writeUnexpectedFailure('BaseConstructorNotCalled');
            throw new Error(Strings_resx_1.default.BaseConstructorNotCalledError);
        }
        // Set the display mode of the web part
        this._displayMode = mode;
        // Deserialize the web part data
        this._internalDeserialize(data);
        // By this point in the lifecycle the web part should have a non-null property bag.
        if (!this._properties) {
            qosMonitor.writeUnexpectedFailure('PropertyBagNull');
            throw new Error(Strings_resx_1.default.PropertyBagNullError);
        }
        // Perform web part initialization and then render the web part.
        var promise = this.onInit();
        if (!promise) {
            throw new Error(Strings_resx_1.default.OnInitReturnedNullPromise);
        }
        return promise.then(function () {
            sp_client_base_1._PerformanceLogger.markComponent(_this.context.webPartTag, 'init');
            _this.context.statusRenderer.clearLoadingIndicator(_this.domElement);
            _this._renderWithAccessibileTitle();
            _this._renderedOnce = true;
        });
    };
    /**
     * Internal API to switch the web part's display mode. This API updates the display mode and then re-renders the web
     * part in the new mode.
     */
    /* tslint:disable:no-unused-variable */
    BaseClientSideWebPart.prototype._internalSetDisplayMode = function (newDisplayMode) {
        /* tslint:enable:no-unused-variable */
        if (this._displayMode !== newDisplayMode) {
            var oldDisplayMode = this._displayMode;
            this._displayMode = newDisplayMode;
            this.onDisplayModeChanged(oldDisplayMode);
        }
    };
    /**
     * Internal API to get property pane settings.
     *
     * @return Property pane data
     */
    /* tslint:disable:no-unused-variable */
    BaseClientSideWebPart.prototype._internalGetPropertyPaneSettings = function () {
        /* tslint:enable:no-unused-variable */
        // Keep a copy of the properties to be used for discard
        if (!this._propertiesBackup) {
            this._propertiesBackup = lodash.cloneDeep(this.properties);
        }
        return {
            webPartId: this.context.instanceId,
            title: this.context.manifest.title.default,
            isReactive: !this.disableReactivePropertyChanges,
            settings: this.propertyPaneSettings,
            properties: lodash.cloneDeep(this.properties),
            // The following handlers are being overridden in the PropertyPane controller and hence
            // we do not need to bind them here. We still do not want to make them optional because
            // that could lead to unwanted bugs.
            onPropertyChange: undefined,
            onClose: undefined,
            onSave: undefined,
            onConfigurationComplete: this.onPropertyConfigurationComplete,
            onRendered: this.onPropertyPaneRendered,
            onLostFocus: undefined
        };
    };
    /**
     * Internal API to set the dirty bit on the web part host if the web part properties have changed.
     */
    /* tslint:disable:no-unused-variable */
    BaseClientSideWebPart.prototype._internalSetDirtyBit = function () {
        /* tslint:enable:no-unused-variable */
        var serializedState = this._internalSerialize();
        var newState = JSON.stringify(serializedState);
        // Don't set dirty bit the first time because the Canvas
        // would have done it when the webpart got added.
        if (!this._previousState) {
            this._previousState = newState;
        }
        else if (this._previousState !== newState && this.context.host.setDirty) {
            this.context.host.setDirty(this.context.instanceId, serializedState);
            this._previousState = newState;
        }
    };
    /**
     * Internal API to serialize the web part properties.
     */
    BaseClientSideWebPart.prototype._internalSerialize = function () {
        var htmlProps = this.onBeforeSerialize();
        var htmlPropsString = this._getHtmlProps(htmlProps);
        return {
            id: this.context.manifest.id,
            instanceId: this.context.instanceId,
            version: this.context.manifest.version,
            title: this.context.manifest.title.default,
            properties: this.properties,
            htmlProperties: htmlPropsString
        };
    };
    /**
     * Internal API to dispose resources that the web part might be holding on to.
     */
    /* tslint:disable:no-unused-variable */
    BaseClientSideWebPart.prototype._internalDispose = function () {
        /* tslint:enable:no-unused-variable */
        this.dispose();
        sp_client_base_1._TraceLogger.logVerbose(this._logSource, odsp_utilities_bundle_1.StringHelper.format(Strings_resx_1.default.DisposeLog, this.context.instanceId));
    };
    /**
     * Update the web part property if it is in the property bag.
     *
     * @param propertyPath - property path as expected by lodash update (https://lodash.com/docs#update).
     *   (e.g. 'o.a.b', 'o[0].a.b[1].c'). These paths are similar to those in the JSONPath spec described by
     *   Stefan Goessner at (http://goessner.net/articles/JsonPath/). Currently we plan to use lodash.get, has
     *   and update APIs which support paths. Some day we may migrate to using actual JSONPath.js. But that
     *   should not be an issue because the path formatting conventions are same in lodash and JSONPath.
     */
    /* tslint:disable:no-any */
    BaseClientSideWebPart.prototype._updateProperty = function (propertyPath, newValue) {
        /* tslint:enable:no-any */
        // should we check if this is a valid property path. For now maybe not.
        lodash.update(this.properties, propertyPath, function () { return newValue; });
    };
    BaseClientSideWebPart.prototype._processInputParams = function (context) {
        sp_client_base_1.Validate.isNotNullOrUndefined(context, 'webpart context');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.domElement, 'webpart element');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.instanceId, 'webpart instanceId');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.manifest, 'webpart manifest');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.webPartTag, 'webpart tag');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.httpClient, 'webpart httpClient');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.basicHttpClient, 'webpart basicHttpClient');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.pageContext, 'webpart context pageContext');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.eventAggregator, 'webpart context eventAggregator');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.statusRenderer, 'webpart context statusRenderer');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.configureStart, 'webpart context configureStart');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.host, 'webpart host');
        sp_client_base_1.Validate.isNotNullOrUndefined(context.serviceScope, 'webpart service scope');
        Object_1.deepFreeze(context.manifest);
        this._context = context;
        this._properties = this._getMergedProperties();
        this._logEntry = 'BaseClientSideWebPart';
    };
    /**
     * Merge the provided properties with manifest properties and return the merged property bag.
     */
    BaseClientSideWebPart.prototype._getMergedProperties = function (p) {
        return lodash.merge(lodash.clone(this._context.manifest.properties), p);
    };
    /**
     * A generic NOP async handler.
     */
    BaseClientSideWebPart.prototype._genericAsyncHandler = function () {
        return new Promise(function (resolve, reject) {
            resolve(undefined);
        });
    };
    /**
     * Generate an HTML string for searchable, link and imageLink properties from the web part data.
     * The serialized page data needs to be stored in a way (pseudo HTML) that the server can index searchable
     * properties and fix links when links change. The SharePoint server is a semantic HTML parser and processes
     * HTML and not JSON blobs.
     *
     * This function returns multiple HTML tags, one for each searchable and link property. The format of the
     * tags are as follows:
     *
     * Searchable properties: "<div data-sp-prop-name='prop1'>value1</div>"
     * Link properties: "<link data-sp-prop-name='prop2' href='http://www.contoso.com/page1.aspx'>"
     * Image properties: "<img data-sp-prop-name='prop2' href='http://www.contoso.com/image.png'>"
     *
     * @param htmlProps - reference to html properties key/value dictionaries.
     * @return - pseudo HTML string equivalent of the HTML properties.
     */
    BaseClientSideWebPart.prototype._getHtmlProps = function (htmlProps) {
        var htmlPropsString;
        if (htmlProps) {
            htmlPropsString = this._getHtmlPropsString(htmlProps);
        }
        else {
            htmlPropsString = this._getHtmlPropsStringFromManifest();
        }
        return htmlPropsString;
    };
    BaseClientSideWebPart.prototype._getHtmlPropsString = function (htmlProps) {
        var _this = this;
        var htmlPropsString = '';
        if (htmlProps.searchableProperties) {
            Object.keys(htmlProps.searchableProperties).every(function (propName) {
                htmlPropsString +=
                    _this._getHtmlPropString(propName, 'search', htmlProps.searchableProperties[propName]);
                return true;
            });
        }
        if (htmlProps.linkProperties) {
            Object.keys(htmlProps.linkProperties).every(function (propName) {
                htmlPropsString +=
                    _this._getHtmlPropString(propName, 'link', htmlProps.linkProperties[propName]);
                return true;
            });
        }
        if (htmlProps.imageLinkProperties) {
            Object.keys(htmlProps.imageLinkProperties).every(function (propName) {
                htmlPropsString +=
                    _this._getHtmlPropString(propName, 'imageLink', htmlProps.imageLinkProperties[propName]);
                return true;
            });
        }
        return htmlPropsString;
    };
    /**
     * Generate the HTML string from the property names provided in the manifest.
     */
    BaseClientSideWebPart.prototype._getHtmlPropsStringFromManifest = function () {
        var _this = this;
        var htmlPropsString = '';
        if (this.context.manifest.searchablePropertyNames) {
            this.context.manifest.searchablePropertyNames.forEach(function (propName) {
                htmlPropsString +=
                    _this._getHtmlPropString(propName, 'search', lodash.get(_this._properties, propName));
            });
        }
        if (this.context.manifest.linkPropertyNames) {
            this.context.manifest.linkPropertyNames.forEach(function (propName) {
                htmlPropsString +=
                    _this._getHtmlPropString(propName, 'link', lodash.get(_this._properties, propName));
            });
        }
        if (this.context.manifest.imageLinkPropertyNames) {
            this.context.manifest.imageLinkPropertyNames.forEach(function (propName) {
                htmlPropsString +=
                    _this._getHtmlPropString(propName, 'imageLink', lodash.get(_this._properties, propName));
            });
        }
        return htmlPropsString;
    };
    /**
     * Get the HTML props string.
     */
    BaseClientSideWebPart.prototype._getHtmlPropString = function (propName, propType, propValue) {
        var htmlPropString = '';
        if (propName) {
            if (typeof propValue === 'string' && propValue) {
                switch (propType) {
                    /* tslint:disable:max-line-length */
                    case 'search':
                        htmlPropString += "<div data-sp-prop-name='" + lodash.escape(propName) + "'>" + lodash.escape(propValue) + "</div>";
                        break;
                    case 'link':
                        htmlPropString += "<link data-sp-prop-name='" + lodash.escape(propName) + "' href='" + lodash.escape(propValue) + "'/>";
                        break;
                    case 'imageLink':
                        htmlPropString += "<img data-sp-prop-name='" + lodash.escape(propName) + "' src='" + lodash.escape(propValue) + "'/>";
                        break;
                }
            }
        }
        return htmlPropString;
    };
    /**
     * Throw an error indicating that this property is readonly and cannot be set.
     */
    BaseClientSideWebPart.prototype._throwReadOnlyError = function () {
        throw new Error(Strings_resx_1.default.ReadOnlyPropertyError);
    };
    /**
     * Wraps render to ensure any type of rendering has access to the latest context
     * to provide the most accurate accessible info to screen readers.
     */
    BaseClientSideWebPart.prototype._renderWithAccessibileTitle = function () {
        this.render();
        // Render the accessible description after and associate by ID to avoid re-rendering the whole zone
        // when webpart updates contextual info.
        var accessibleContext = this.accessibleTitle || this._getDefaultAccessibleTitle();
        if (accessibleContext) {
            // Keep ID in sync with CanvasZone.render
            var contextualLabelId = "cswpAccessibleLabelContextual_" + this.context.instanceId;
            var accessibleDiv = this.domElement.querySelector("#" + contextualLabelId);
            var isNewLabelElement = !accessibleDiv;
            if (isNewLabelElement) {
                accessibleDiv = document.createElement('div');
                accessibleDiv.id = contextualLabelId;
                accessibleDiv.className = cswp_base_module_scss_1.default.screenReaderOnly;
            }
            accessibleDiv.textContent = accessibleContext;
            if (isNewLabelElement) {
                this.domElement.appendChild(accessibleDiv);
            }
        }
    };
    /**
     * Gets default accessible title in the format "{Web part name} web part", such as "Image web part".
     * Note: pulled into own method because TypeScript doesn't allow derived classes to call super protected properties.
     */
    BaseClientSideWebPart.prototype._getDefaultAccessibleTitle = function () {
        return odsp_utilities_bundle_1.StringHelper.format(Strings_resx_1.default.GenericAccessibleLabelTemplate, this.context.manifest.title.default);
    };
    return BaseClientSideWebPart;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseClientSideWebPart;

//# sourceMappingURL=BaseClientSideWebPart.js.map
