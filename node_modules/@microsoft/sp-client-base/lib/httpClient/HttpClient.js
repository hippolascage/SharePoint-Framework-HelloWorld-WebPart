"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lodash = require('@microsoft/sp-lodash-subset');
var ServiceKey_1 = require('../serviceScope/ServiceKey');
var IDigestCache_1 = require('./IDigestCache');
var BasicHttpClient_1 = require('./BasicHttpClient');
var ODataBatch_1 = require('./ODataBatch');
var HttpClientCommon_1 = require('./HttpClientCommon');
var RandomProvider_1 = require('../common/RandomProvider');
var PerformanceLogger_1 = require('../telemetry/Api/PerformanceLogger');
var LogSource_1 = require('../telemetry/Api/LogSource');
/**
 * HttpClient is used to perform REST calls against SharePoint.  It adds default
 * headers, manages the digest needed for writes, and collects telemetry that
 * helps the service to monitor the performance of an application.
 *
 * For communicating with non-SharePoint services, use the BasicHttpClient
 * class instead.
 * @public
 */
var HttpClient = (function (_super) {
    __extends(HttpClient, _super);
    function HttpClient(serviceScope) {
        var _this = this;
        _super.call(this, serviceScope);
        this.serviceScope.whenFinished(function () {
            _this._digestCache = serviceScope.consume(IDigestCache_1.digestCacheServiceKey);
            _this._randomProvider = serviceScope.consume(RandomProvider_1.randomProviderServiceKey);
            _this._parentSource = serviceScope.consume(LogSource_1.logSourceServiceKey);
        });
    }
    /**
     * This uses a heuristic to guess the SPWeb URL associated with the provided
     * REST URL.  This is necessary for operations such as the X-RequestDigest
     * and ODATA batching, which require POSTing to a separate REST endpoint
     * in order to complete a request.
     * For excample, if the requestUrl is "/sites/site/web/_api/service",
     * the returned URL would be "/sites/site/web".  Or if the requestUrl
     * is "http://example.com/_layouts/service", the returned URL would be
     * "http://example.com".
     * @param requestUrl  The URL for a SharePoint REST service
     * @returns the inferred SPWeb URL
     */
    HttpClient.getWebUrlFromRequestUrl = function (requestUrl) {
        // First we need to guess the webUrl by looking for a reserved
        // segment such as "_api":
        var segmentIndex = -1;
        var upperCaseUrl = requestUrl.toUpperCase();
        for (var _i = 0, _a = HttpClient._reservedUrlSegments; _i < _a.length; _i++) {
            var reservedUrlSegment = _a[_i];
            segmentIndex = upperCaseUrl.indexOf(reservedUrlSegment);
            if (segmentIndex >= 0) {
                return requestUrl.substr(0, segmentIndex);
            }
        }
        throw new Error('Unable to determine web URL');
    };
    /**
     * Generally, the parameters and semantics for HttpClient.fetch() are essentially
     * the same as the WHATWG API standard that is documented here:
     * https://fetch.spec.whatwg.org/
     *
     * The HttpClient subclass adds some additional behaviors that are convenient when
     * working with SharePoint ODATA API's (which can be avoided by using
     * BasicHttpClient instead):
     * - Default "Accept" and "Content-Type" headers are added if not explicitly specified.
     * - For write operations, an "X-RequestDigest" header is automatically added
     * - The request digest token is automatically fetched and stored in a cache, with
     *   support for preloading
     *
     * For a write operation, HttpClient will automatically add the "X-RequestDigest"
     * header, which may need to be obtained by issuing a seperate request such as
     * "https://example.com/sites/sample/_api/contextinfo".  Typically the appropriate
     * SPWeb URL can be guessed by looking for a reserved URL segment such as "_api"
     * in the original URL passed to fetch(); if not, use IHttpClientOptions.webUrl
     * to specify it explicitly.
     *
     * @params url - the URL to fetch
     * @params options - additional options that affect the request
     * @returns a promise that will return the result
     * @override
     */
    HttpClient.prototype.fetch = function (url, options) {
        var _this = this;
        if (!options) {
            options = {};
        }
        var modifiedOptions = lodash.clone(options);
        // Apply default headers
        if (!options.credentials) {
            modifiedOptions.credentials = 'same-origin';
        }
        // NOTE: RequestInit.cache is apparently currently unimplemented in Chrome
        // and our polyfill, so we don't specify it here.
        var headers = HttpClientCommon_1.default.constructDefaultHeaders(options);
        modifiedOptions.headers = headers;
        if (!headers.has('OData-Version')) {
            // SharePoint's guidance is that everyone should be using ODATA version 4.0 now.
            // If you don't provide an OData-Version, then the server will decide using a heuristic,
            // which is not what we want
            headers.append('OData-Version', '4.0');
        }
        // NOTE: If options.method is missing, the default is GET
        if (options.method) {
            var method = options.method.toUpperCase();
            if (method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS') {
                // For writes, SharePoint requires an "X-RequestDigest" header.
                if (!headers.has('X-RequestDigest')) {
                    var webUrl = options.webUrl || HttpClient.getWebUrlFromRequestUrl(url);
                    // Now fetch the digest
                    var promise = this._digestCache.fetchDigest(webUrl)
                        .then(function (digest) {
                        headers.append('X-RequestDigest', digest);
                        return _this._fetchWithInstrumentation(new Request(url, modifiedOptions));
                    });
                    return HttpClientCommon_1.default.handleAuthenticationErrors(promise, webUrl, this._digestCache);
                }
            }
        }
        return this._fetchWithInstrumentation(new Request(url, modifiedOptions));
    };
    /**
     * Calls fetch(), but sets the method to 'GET'.
     * @params url - the URL to fetch
     * @params options - additional options that affect the request
     * @returns a promise that will return the result
     * @override
     */
    HttpClient.prototype.get = function (url, options) {
        var modifiedOptions = lodash.clone(options || {});
        modifiedOptions.method = 'GET';
        return this.fetch(url, modifiedOptions);
    };
    /**
     * Calls fetch(), but sets the method to 'POST'.
     * @params url - the URL to fetch
     * @params options - additional options that affect the request
     * @returns a promise that will return the result
     * @override
     */
    HttpClient.prototype.post = function (url, options) {
        var modifiedOptions = lodash.clone(options || {});
        modifiedOptions.method = 'POST';
        return this.fetch(url, modifiedOptions);
    };
    /**
     * Begins an ODATA batch, which allows multiple REST queries to be bundled into
     * a single web request.
     */
    HttpClient.prototype.beginBatch = function (batchOptions) {
        return new ODataBatch_1.default(this.serviceScope, batchOptions);
    };
    HttpClient.prototype._fetchWithInstrumentation = function (request) {
        var _this = this;
        var tag = this._performanceTag;
        PerformanceLogger_1.default.startMarkForApi(tag);
        return this.fetchCore(request).then(function (response) {
            PerformanceLogger_1.default.endMarkForApi(tag, _this._logSourceId, request.url, response);
            return response;
        });
    };
    Object.defineProperty(HttpClient.prototype, "_performanceTag", {
        get: function () {
            var randomSuffix = Math.floor(this._randomProvider.getRandom() * 100000).toString();
            return this._logSourceId + "." + randomSuffix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HttpClient.prototype, "_logSourceId", {
        get: function () {
            if (this._parentSource.isEmpty()) {
                return HttpClient._logSource.id;
            }
            return this._parentSource.id;
        },
        enumerable: true,
        configurable: true
    });
    HttpClient._logSource = LogSource_1.default.create('httpClient');
    HttpClient._reservedUrlSegments = [
        '/_API/',
        '/_LAYOUTS/',
        '/_VTI_BIN/'];
    return HttpClient;
}(BasicHttpClient_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HttpClient;
exports.httpClientServiceKey = ServiceKey_1.default.create('sp-client-base:HttpClient', HttpClient);

//# sourceMappingURL=HttpClient.js.map
