/**
 * @copyright (c) Microsoft Corporation. All rights reserved.
 */
"use strict";
var lodash = require('@microsoft/sp-lodash-subset');
var ODataBatchedRequest_1 = require('./ODataBatchedRequest');
var HttpClient_1 = require('./HttpClient');
var Guid_1 = require('../guid/Guid');
var FetchProvider_1 = require('./FetchProvider');
var RandomProvider_1 = require('../common/RandomProvider');
var IDigestCache_1 = require('./IDigestCache');
var HttpClientCommon_1 = require('./HttpClientCommon');
/**
 * The ODataBatch class accumulates a number of REST service calls and
 * transmits them as a single ODATA batch.  This protocol is documented here:
 * http://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part1-protocol.html
 *
 * The usage is to call ODataBatch.fetch() to queue each individual request,
 * and then call ODataBatch.execute() to execute the batch operation.
 * The execute() method returns a promise that resolves when the real REST
 * call has completed.  Each call to fetch() also returns a promise that will
 * resolve with a Response object for that particular request.
 *
 * @public
 */
var ODataBatch = (function () {
    function ODataBatch(serviceScope, batchOptions) {
        var _this = this;
        this._batchOptions = batchOptions || {};
        this._batchedRequests = [];
        serviceScope.whenFinished(function () {
            _this._fetchProvider = serviceScope.consume(FetchProvider_1.fetchProviderServiceKey);
            _this._randomProvider = serviceScope.consume(RandomProvider_1.randomProviderServiceKey);
            _this._digestCache = serviceScope.consume(IDigestCache_1.digestCacheServiceKey);
        });
    }
    /**
     * Queues a new request, and returns a promise that can be used to access
     * the server response (after execute() has completed).  The parameters for
     * this function are basically the same as the WHATWG API standard documented here:
     * https://fetch.spec.whatwg.org/
     *
     * However, be aware that certain REST headers are ignored or not allowed inside
     * a batch.  See the ODATA documentation for details.
     *
     * When execute() is called, it will POST to a URL such as
     * "http://example.com/sites/sample/_api/$batch".  Typically ODataBatch can successfully
     * guess the appropriate SPWeb URL by looking for a reserved URL segment such as "_api"
     * in the first URL passed to fetch().  If not, use IODataBatchOptions.webUrl to specify it
     * explicitly.
     *
     * @params url - the URL to fetch, or an already initialized Request object
     * @params options - additional options that affect the request
     * @returns a promise that will return the result
     */
    ODataBatch.prototype.fetch = function (url, options) {
        if (!options) {
            options = {};
        }
        // Apply most of the same default headers as HttpClient
        var modifiedOptions = lodash.clone(options);
        modifiedOptions.headers = HttpClientCommon_1.default.constructDefaultHeaders(options);
        var request = new Request(url, modifiedOptions);
        var requestUrl = request.url;
        if (!this._webUrl) {
            // If the webUrl wasn't provided to the constructor, then we infer it from
            // the first request.
            this._webUrl = HttpClient_1.default.getWebUrlFromRequestUrl(requestUrl);
        }
        var batchedRequest = new ODataBatchedRequest_1.default(request);
        this._batchedRequests.push(batchedRequest);
        return batchedRequest.promise;
    };
    /**
     * Calls fetch(), but sets the method to 'GET'.
     * @params url - the URL to fetch
     * @params options - additional options that affect the request
     * @returns a promise that will return the result
     */
    ODataBatch.prototype.get = function (url, options) {
        var modifiedOptions = lodash.clone(options || {});
        modifiedOptions.method = 'GET';
        return this.fetch(url, modifiedOptions);
    };
    /**
     * Calls fetch(), but sets the method to 'POST'.
     * @params url - the URL to fetch
     * @params options - additional options that affect the request
     * @returns a promise that will return the result
     */
    ODataBatch.prototype.post = function (url, options) {
        var modifiedOptions = lodash.clone(options || {});
        modifiedOptions.method = 'POST';
        return this.fetch(url, modifiedOptions);
    };
    /**
     * Executes the batched queries that were queued using ODataBatch.fetch().
     */
    ODataBatch.prototype.execute = function () {
        var _this = this;
        var batchBody = '\n';
        var batchGuid = Guid_1.default.newGuid(this._randomProvider);
        // In the loop below, we will build up a chain of promises that append
        // each request to the batch body, and then the "return" statement will
        // add the final processing to the chain.
        var chain = Promise.resolve();
        this._batchedRequests.forEach(function (batchedRequest) {
            chain = chain.then(function () {
                return batchedRequest.request.text();
            }).then(function (requestText) {
                var request = batchedRequest.request;
                batchBody += "--batch_" + batchGuid.toString() + "\n";
                batchBody += "Content-type: application/http\n"
                    + "Content-Transfer-Encoding: binary\n\n";
                // Example:
                // "POST https://example.com/_api/web HTTP/1.1"
                batchBody += request.method + " " + request.url + " HTTP/1.1\n";
                request.headers.forEach(function (value, name) {
                    batchBody += name + ": " + value + "\n";
                });
                batchBody += '\n';
                batchBody += requestText;
                batchBody += '\n\n';
            });
        });
        return chain.then(function () {
            // Close the batch
            batchBody += "--batch_" + batchGuid + "--\n";
            return _this._digestCache.fetchDigest(_this._webUrl);
        }).then(function (digest) {
            // Start the $batch request
            var headers = new Headers();
            headers.append('Accept', 'application/json');
            headers.append('OData-Version', '4.0');
            headers.append('Content-Type', "multipart/mixed; boundary=batch_" + batchGuid);
            headers.append('Content-Length', batchBody.length.toString());
            headers.append('X-RequestDigest', digest);
            var request = new Request(_this._webUrl + '/_api/$batch', {
                method: 'POST',
                headers: headers,
                body: batchBody,
                credentials: 'same-origin',
                cache: 'no-cache'
            });
            var promise = _this._fetchProvider.fetch(request);
            return HttpClientCommon_1.default.handleAuthenticationErrors(promise, _this._webUrl, _this._digestCache);
        }).then(function (response) {
            if (!response.ok) {
                throw new Error('ODataBatch: The batch request failed: ' + response.statusText);
            }
            return response.text();
        }).then(function (text) {
            var responses = _this._parseResponsesFromBody(text);
            if (responses.length !== _this._batchedRequests.length) {
                throw new Error("ODataBatch: Expecting " + _this._batchedRequests.length + " responses");
            }
            for (var i = 0; i < _this._batchedRequests.length; ++i) {
                var request = _this._batchedRequests[i];
                request.notifyCompleted(responses[i]);
            }
            return _this;
        });
    };
    ODataBatch.prototype._parseResponsesFromBody = function (text) {
        var responses = [];
        var header = '--batchresponse_';
        // Ex. "HTTP/1.1 500 Internal Server Error"
        var statusRegExp = new RegExp('^HTTP/[0-9.]+ +([0-9]+) +(.*)', 'i');
        var lines = text.split('\n');
        var parserState = 'batch';
        var batchStatus;
        var batchStatusText;
        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];
            switch (parserState) {
                case 'batch':
                    if (line.substr(0, header.length) === header) {
                        parserState = 'batchHeaders';
                    }
                    else {
                        if (line.trim() !== '') {
                            throw new Error('ODataBatch: Invalid response, line ' + i);
                        }
                    }
                    break;
                case 'batchHeaders':
                    if (line.trim() === '') {
                        parserState = 'status';
                    }
                    break;
                case 'status':
                    // Ex. "HTTP/1.1 500 Internal Server Error"
                    var parts = statusRegExp.exec(line);
                    if (parts.length !== 3) {
                        throw new Error('ODataBatch: Invalid status, line ' + i);
                    }
                    // Ex. "500"
                    batchStatus = parseInt(parts[1], 10);
                    // Ex. "Internal Server Error"
                    batchStatusText = parts[2];
                    parserState = 'statusHeaders';
                    break;
                case 'statusHeaders':
                    if (line.trim() === '') {
                        parserState = 'body';
                    }
                    break;
                case 'body':
                    var response = void 0;
                    if (batchStatus === 204) {
                        // https://github.com/whatwg/fetch/issues/178
                        response = new Response();
                    }
                    else {
                        response = new Response(line, { status: batchStatus, statusText: batchStatusText });
                    }
                    responses.push(response);
                    parserState = 'batch';
                    break;
            }
        }
        if (parserState !== 'status') {
            throw new Error('ODataBatch: Unexpected end of input');
        }
        return responses;
    };
    return ODataBatch;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ODataBatch;

//# sourceMappingURL=ODataBatch.js.map
