/**
 * @copyright Microsoft Corporation. All rights reserved.
 */
"use strict";
var UrlUtilities_1 = require('../common/UrlUtilities');
var FetchProvider_1 = require('./FetchProvider');
var TimeProvider_1 = require('../common/TimeProvider');
var LogSource_1 = require('../telemetry/Api/LogSource');
var TraceLogger_1 = require('../telemetry/Api/TraceLogger');
/**
 * The internal implementation of IDigestCache.
 */
var DigestCache = (function () {
    function DigestCache(serviceScope) {
        var _this = this;
        this._digestsByUrl = new Map();
        serviceScope.whenFinished(function () {
            _this._fetchProvider = serviceScope.consume(FetchProvider_1.fetchProviderServiceKey);
            _this._dateProvider = serviceScope.consume(TimeProvider_1.dateProviderServiceKey);
        });
    }
    /** Implements IDigestCache */
    DigestCache.prototype.fetchDigest = function (webUrl) {
        var _this = this;
        var normalizedWebUrl = UrlUtilities_1.default.removeEndSlash(webUrl);
        var cachedDigest = this._digestsByUrl.get(normalizedWebUrl);
        if (cachedDigest) {
            var timestamp = this._dateProvider.getTimestamp();
            if (timestamp < cachedDigest.expirationTimestamp) {
                TraceLogger_1.default.logVerbose(DigestCache._logSource, 'DigestCache: Reusing cached digest.  Expiration: ' + cachedDigest.expirationTimestamp);
                return Promise.resolve(cachedDigest.value);
            }
        }
        // If it wasn't in the cache, then we need to fetch a new one.
        // Create the REST API URL
        var digestUrl = normalizedWebUrl + '/_api/contextinfo';
        // NOTE: We don't want people to be injecting random headers throughout
        // their code.  As HttpClient evolves, maybe there is some way we can
        // combine this with the headers being added there.
        var rawRequest = new Request(digestUrl, {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-type': 'application/json;odata=verbose;charset=utf-8'
            },
            credentials: 'same-origin',
            cache: 'no-cache'
        });
        return this._fetchProvider.fetch(rawRequest).then(function (response) {
            return response.json();
        }).then(function (responseObject) {
            var digestValue = responseObject.FormDigestValue;
            var seconds = responseObject.FormDigestTimeoutSeconds;
            var expirationTimeMs = _this._dateProvider.getTimestamp() + 1000 * seconds;
            _this.addDigestToCache(normalizedWebUrl, digestValue, expirationTimeMs);
            TraceLogger_1.default.logVerbose(DigestCache._logSource, 'DigestCache: Fetched new digest');
            return digestValue;
        });
    };
    /** Implements IDigestCache */
    DigestCache.prototype.addDigestToCache = function (webUrl, digestValue, expirationTimestamp) {
        var normalizedWebUrl = UrlUtilities_1.default.removeEndSlash(webUrl);
        var newCachedDigest = {
            value: digestValue,
            expirationTimestamp: expirationTimestamp - DigestCache.EXPIRATION_SLOP_MS
        };
        this._digestsByUrl.set(normalizedWebUrl, newCachedDigest);
    };
    /** Implements IDigestCache */
    DigestCache.prototype.clearDigest = function (webUrl) {
        var normalizedWebUrl = UrlUtilities_1.default.removeEndSlash(webUrl);
        var found = this._digestsByUrl.delete(normalizedWebUrl);
        TraceLogger_1.default.logVerbose(DigestCache._logSource, "DigestCache: Requested to clear cache entry: " + (found ? 'found' : 'not found'));
        return found;
    };
    /** Implements IDigestCache */
    DigestCache.prototype.clearAllDigests = function () {
        this._digestsByUrl.clear();
    };
    // The digest cache expiration times are measured from whenever the C# code on the server
    // generated the digest, whereas in the current implementation, we start measuring from
    // whenever the framework finished loading.  We do have access to the server's timestamp,
    // relying on it could run into trouble if the browser's clock is wrong.  SPPPlat VSO 223612
    // will add a bit of logic to TimeProvider to protect against that.  Until then, we can
    // work around the issue by trimming the expiration times back by a small amount, which
    // represents the estimated page render time.
    DigestCache.EXPIRATION_SLOP_MS = 3000;
    DigestCache._logSource = LogSource_1.default.create('DigestCache');
    return DigestCache;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DigestCache;

//# sourceMappingURL=DigestCache.js.map
