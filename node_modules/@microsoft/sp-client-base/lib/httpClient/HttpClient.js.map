{"version":3,"sources":["httpClient/HttpClient.ts"],"names":[],"mappings":"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","file":"httpClient/HttpClient.js","sourcesContent":["import * as lodash from '@microsoft/sp-lodash-subset';\r\nimport ServiceKey from '../serviceScope/ServiceKey';\r\nimport ServiceScope from '../serviceScope/ServiceScope';\r\nimport IDigestCache, { digestCacheServiceKey } from './IDigestCache';\r\nimport BasicHttpClient, { IBasicHttpClientOptions } from './BasicHttpClient';\r\nimport ODataBatch, { IODataBatchOptions } from './ODataBatch';\r\nimport HttpClientCommon from './HttpClientCommon';\r\nimport { IRandomProvider, randomProviderServiceKey } from '../common/RandomProvider';\r\nimport _PerformanceLogger from '../telemetry/Api/PerformanceLogger';\r\nimport LogSource, { logSourceServiceKey } from '../telemetry/Api/LogSource';\r\n\r\n/**\r\n * HttpClient is used to perform REST calls against SharePoint.  It adds default\r\n * headers, manages the digest needed for writes, and collects telemetry that\r\n * helps the service to monitor the performance of an application.\r\n *\r\n * For communicating with non-SharePoint services, use the BasicHttpClient\r\n * class instead.\r\n * @public\r\n */\r\nexport default class HttpClient extends BasicHttpClient {\r\n  private static _logSource: LogSource = LogSource.create('httpClient');\r\n  private static _reservedUrlSegments: string[] = [\r\n    '/_API/',\r\n    '/_LAYOUTS/',\r\n    '/_VTI_BIN/'];\r\n\r\n  private _digestCache: IDigestCache;\r\n  private _randomProvider: IRandomProvider;\r\n  private _parentSource: LogSource;\r\n\r\n  /**\r\n   * This uses a heuristic to guess the SPWeb URL associated with the provided\r\n   * REST URL.  This is necessary for operations such as the X-RequestDigest\r\n   * and ODATA batching, which require POSTing to a separate REST endpoint\r\n   * in order to complete a request.\r\n   * For excample, if the requestUrl is \"/sites/site/web/_api/service\",\r\n   * the returned URL would be \"/sites/site/web\".  Or if the requestUrl\r\n   * is \"http://example.com/_layouts/service\", the returned URL would be\r\n   * \"http://example.com\".\r\n   * @param requestUrl  The URL for a SharePoint REST service\r\n   * @returns the inferred SPWeb URL\r\n   */\r\n  public static getWebUrlFromRequestUrl(requestUrl: string): string {\r\n    // First we need to guess the webUrl by looking for a reserved\r\n    // segment such as \"_api\":\r\n    let segmentIndex: number = -1;\r\n    const upperCaseUrl: string = requestUrl.toUpperCase();\r\n\r\n    for (const reservedUrlSegment of HttpClient._reservedUrlSegments) {\r\n      segmentIndex = upperCaseUrl.indexOf(reservedUrlSegment);\r\n      if (segmentIndex >= 0) {\r\n        return requestUrl.substr(0, segmentIndex);\r\n      }\r\n    }\r\n\r\n    throw new Error('Unable to determine web URL');\r\n  }\r\n\r\n  constructor(serviceScope: ServiceScope) {\r\n    super(serviceScope);\r\n    this.serviceScope.whenFinished(() => {\r\n      this._digestCache = serviceScope.consume(digestCacheServiceKey);\r\n      this._randomProvider = serviceScope.consume(randomProviderServiceKey);\r\n      this._parentSource = serviceScope.consume(logSourceServiceKey);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generally, the parameters and semantics for HttpClient.fetch() are essentially\r\n   * the same as the WHATWG API standard that is documented here:\r\n   * https://fetch.spec.whatwg.org/\r\n   *\r\n   * The HttpClient subclass adds some additional behaviors that are convenient when\r\n   * working with SharePoint ODATA API's (which can be avoided by using\r\n   * BasicHttpClient instead):\r\n   * - Default \"Accept\" and \"Content-Type\" headers are added if not explicitly specified.\r\n   * - For write operations, an \"X-RequestDigest\" header is automatically added\r\n   * - The request digest token is automatically fetched and stored in a cache, with\r\n   *   support for preloading\r\n   *\r\n   * For a write operation, HttpClient will automatically add the \"X-RequestDigest\"\r\n   * header, which may need to be obtained by issuing a seperate request such as\r\n   * \"https://example.com/sites/sample/_api/contextinfo\".  Typically the appropriate\r\n   * SPWeb URL can be guessed by looking for a reserved URL segment such as \"_api\"\r\n   * in the original URL passed to fetch(); if not, use IHttpClientOptions.webUrl\r\n   * to specify it explicitly.\r\n   *\r\n   * @params url - the URL to fetch\r\n   * @params options - additional options that affect the request\r\n   * @returns a promise that will return the result\r\n   * @override\r\n   */\r\n  public fetch(url: string, options: IHttpClientOptions): Promise<Response> {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    const modifiedOptions: IHttpClientOptions = lodash.clone(options);\r\n\r\n    // Apply default headers\r\n    if (!options.credentials) {\r\n      modifiedOptions.credentials = 'same-origin';\r\n    }\r\n\r\n    // NOTE: RequestInit.cache is apparently currently unimplemented in Chrome\r\n    // and our polyfill, so we don't specify it here.\r\n\r\n    const headers: Headers = HttpClientCommon.constructDefaultHeaders(options);\r\n    modifiedOptions.headers = headers;\r\n\r\n    if (!headers.has('OData-Version')) {\r\n      // SharePoint's guidance is that everyone should be using ODATA version 4.0 now.\r\n      // If you don't provide an OData-Version, then the server will decide using a heuristic,\r\n      // which is not what we want\r\n      headers.append('OData-Version', '4.0');\r\n    }\r\n\r\n    // NOTE: If options.method is missing, the default is GET\r\n    if (options.method) {\r\n      const method: string = options.method.toUpperCase();\r\n      if (method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS') {\r\n        // For writes, SharePoint requires an \"X-RequestDigest\" header.\r\n        if (!headers.has('X-RequestDigest')) {\r\n          const webUrl: string = options.webUrl || HttpClient.getWebUrlFromRequestUrl(url);\r\n\r\n          // Now fetch the digest\r\n          const promise: Promise<Response> = this._digestCache.fetchDigest(webUrl)\r\n            .then((digest: string) => {\r\n              headers.append('X-RequestDigest', digest);\r\n\r\n              return this._fetchWithInstrumentation(new Request(url, modifiedOptions));\r\n            });\r\n\r\n          return HttpClientCommon.handleAuthenticationErrors(promise, webUrl, this._digestCache);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this._fetchWithInstrumentation(new Request(url, modifiedOptions));\r\n  }\r\n\r\n  /**\r\n   * Calls fetch(), but sets the method to 'GET'.\r\n   * @params url - the URL to fetch\r\n   * @params options - additional options that affect the request\r\n   * @returns a promise that will return the result\r\n   * @override\r\n   */\r\n  public get(url: string, options?: IHttpClientOptions): Promise<Response> {\r\n    const modifiedOptions: IHttpClientOptions = lodash.clone(options || {});\r\n    modifiedOptions.method = 'GET';\r\n    return this.fetch(url, modifiedOptions);\r\n  }\r\n\r\n  /**\r\n   * Calls fetch(), but sets the method to 'POST'.\r\n   * @params url - the URL to fetch\r\n   * @params options - additional options that affect the request\r\n   * @returns a promise that will return the result\r\n   * @override\r\n   */\r\n  public post(url: string, options: IHttpClientOptions): Promise<Response> {\r\n    const modifiedOptions: IHttpClientOptions = lodash.clone(options || {});\r\n    modifiedOptions.method = 'POST';\r\n    return this.fetch(url, modifiedOptions);\r\n  }\r\n\r\n  /**\r\n   * Begins an ODATA batch, which allows multiple REST queries to be bundled into\r\n   * a single web request.\r\n   */\r\n  public beginBatch(batchOptions?: IODataBatchOptions): ODataBatch {\r\n    return new ODataBatch(this.serviceScope, batchOptions);\r\n  }\r\n\r\n  private _fetchWithInstrumentation(request: Request): Promise<Response> {\r\n    const tag: string = this._performanceTag;\r\n    _PerformanceLogger.startMarkForApi(tag);\r\n    return this.fetchCore(request).then((response: Response) => {\r\n      _PerformanceLogger.endMarkForApi(tag, this._logSourceId, request.url, response);\r\n      return response;\r\n    });\r\n  }\r\n\r\n  private get _performanceTag(): string {\r\n    const randomSuffix: string = Math.floor(this._randomProvider.getRandom() * 100000).toString();\r\n    return `${this._logSourceId}.${randomSuffix}`;\r\n  }\r\n\r\n  private get _logSourceId(): string {\r\n    if (this._parentSource.isEmpty()) {\r\n      return HttpClient._logSource.id;\r\n    }\r\n    return this._parentSource.id;\r\n  }\r\n}\r\n\r\nexport const httpClientServiceKey: ServiceKey<HttpClient> = ServiceKey.create<HttpClient>\r\n  ('sp-client-base:HttpClient', HttpClient);\r\n\r\n/**\r\n * This interface defines the options for the HttpClient operations such as\r\n * get(), post(), fetch(), etc.  It is based on the WHATWG API standard\r\n * parameters that are documented here:\r\n * https://fetch.spec.whatwg.org/\r\n * @public\r\n */\r\nexport interface IHttpClientOptions extends IBasicHttpClientOptions {\r\n  /**\r\n   * For a write operation, HttpClient will automatically add the\r\n   * \"X-RequestDigest\" header, which may need to be fetched using a seperate\r\n   * request such as \"https://example.com/sites/sample/_api/contextinfo\".\r\n   * Typically the SPWeb URL (\"https://example.com/sites/sample\" in this\r\n   * example) can be guessed by looking for a reserved URL segment such\r\n   * as \"_api\" in the original REST query, however certain REST endpoints\r\n   * do not contain a reserved URL segment; in this case, the webUrl can\r\n   * be explicitly specified using this option.\r\n   */\r\n  webUrl?: string;\r\n}\r\n"],"sourceRoot":"/src"}