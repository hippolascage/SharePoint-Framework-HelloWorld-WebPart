{"version":3,"sources":["httpClient/DigestCache.ts"],"names":[],"mappings":"AAAA;;GAEG;;AAGH,6BAAyB,wBAAwB,CAAC,CAAA;AAClD,8BAAwD,iBAAiB,CAAC,CAAA;AAC1E,6BAAsD,wBAAwB,CAAC,CAAA;AAE/E,0BAAsB,4BAA4B,CAAC,CAAA;AACnD,4BAAwB,8BAA8B,CAAC,CAAA;AAEvD;;GAEG;AACH;IAgBE,qBAAY,YAA0B;QAhBxC,iBAgGC;QA/EG,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAAyB,CAAC;QAEtD,YAAY,CAAC,YAAY,CAAC;YACxB,KAAI,CAAC,cAAc,GAAG,YAAY,CAAC,OAAO,CAAC,uCAAuB,CAAC,CAAC;YACpE,KAAI,CAAC,aAAa,GAAG,YAAY,CAAC,OAAO,CAAC,qCAAsB,CAAC,CAAC;QACpE,CAAC,CAAC,CAAC;IACL,CAAC;IAED,8BAA8B;IACvB,iCAAW,GAAlB,UAAmB,MAAc;QAAjC,iBA6CC;QA5CC,IAAM,gBAAgB,GAAW,sBAAY,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;QACrE,IAAM,YAAY,GAAkB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;QAE7E,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;YACjB,IAAM,SAAS,GAAW,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,CAAC;YAC5D,EAAE,CAAC,CAAC,SAAS,GAAG,YAAY,CAAC,mBAAmB,CAAC,CAAC,CAAC;gBACjD,qBAAW,CAAC,UAAU,CAAC,WAAW,CAAC,UAAU,EAC3C,mDAAmD,GAAG,YAAY,CAAC,mBAAmB,CAAC,CAAC;gBAC1F,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;YAC7C,CAAC;QACH,CAAC;QAED,8DAA8D;QAC9D,0BAA0B;QAC1B,IAAM,SAAS,GAAW,gBAAgB,GAAG,mBAAmB,CAAC;QAEjE,uEAAuE;QACvE,qEAAqE;QACrE,mDAAmD;QACnD,IAAM,UAAU,GAAY,IAAI,OAAO,CAAC,SAAS,EAC/C;YACE,MAAM,EAAE,MAAM;YACd,OAAO,EAAE;gBACP,QAAQ,EAAE,kBAAkB;gBAC5B,cAAc,EAAE,8CAA8C;aAC/D;YACD,WAAW,EAAE,aAAa;YAC1B,KAAK,EAAE,UAAU;SAClB,CAAC,CAAC;QAEL,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,UAAC,QAAkB;YACnE,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;QACzB,CAAC,CAAC,CAAC,IAAI,CAAC,UAAC,cAA6B;YAEpC,IAAM,WAAW,GAAW,cAAc,CAAC,eAAe,CAAC;YAC3D,IAAM,OAAO,GAAW,cAAc,CAAC,wBAAkC,CAAC;YAC1E,IAAM,gBAAgB,GAAW,KAAI,CAAC,aAAa,CAAC,YAAY,EAAE,GAAG,IAAI,GAAG,OAAO,CAAC;YAEpF,KAAI,CAAC,gBAAgB,CAAC,gBAAgB,EAAE,WAAW,EAAE,gBAAgB,CAAC,CAAC;YAEvE,qBAAW,CAAC,UAAU,CAAC,WAAW,CAAC,UAAU,EAAE,iCAAiC,CAAC,CAAC;YAElF,MAAM,CAAC,WAAW,CAAC;QACrB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,8BAA8B;IACvB,sCAAgB,GAAvB,UAAwB,MAAc,EAAE,WAAmB,EAAE,mBAA2B;QACtF,IAAM,gBAAgB,GAAW,sBAAY,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;QACrE,IAAM,eAAe,GAAkB;YACrC,KAAK,EAAE,WAAW;YAClB,mBAAmB,EAAE,mBAAmB,GAAG,WAAW,CAAC,kBAAkB;SAC1E,CAAC;QACF,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,gBAAgB,EAAE,eAAe,CAAC,CAAC;IAC5D,CAAC;IAED,8BAA8B;IACvB,iCAAW,GAAlB,UAAmB,MAAc;QAC/B,IAAM,gBAAgB,GAAW,sBAAY,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;QACrE,IAAM,KAAK,GAAY,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;QACnE,qBAAW,CAAC,UAAU,CAAC,WAAW,CAAC,UAAU,EAC3C,mDAAgD,KAAK,GAAG,OAAO,GAAG,WAAW,CAAE,CAAC,CAAC;QACnF,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IAED,8BAA8B;IACvB,qCAAe,GAAtB;QACE,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;IAC7B,CAAC;IA9FD,yFAAyF;IACzF,uFAAuF;IACvF,yFAAyF;IACzF,4FAA4F;IAC5F,uFAAuF;IACvF,uFAAuF;IACvF,6CAA6C;IAC9B,8BAAkB,GAAW,IAAI,CAAC;IAElC,sBAAU,GAAc,mBAAS,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;IAsFzE,kBAAC;AAAD,CAhGA,AAgGC,IAAA;AAhGD;6BAgGC,CAAA","file":"httpClient/DigestCache.js","sourcesContent":["/**\r\n * @copyright Microsoft Corporation. All rights reserved.\r\n */\r\n\r\nimport ServiceScope from '../serviceScope/ServiceScope';\r\nimport UrlUtilities from '../common/UrlUtilities';\r\nimport { IFetchProvider, fetchProviderServiceKey } from './FetchProvider';\r\nimport { ITimeProvider, dateProviderServiceKey } from '../common/TimeProvider';\r\nimport IDigestCache from './IDigestCache';\r\nimport LogSource from '../telemetry/Api/LogSource';\r\nimport TraceLogger from '../telemetry/Api/TraceLogger';\r\n\r\n/**\r\n * The internal implementation of IDigestCache.\r\n */\r\nexport default class DigestCache implements IDigestCache {\r\n  // The digest cache expiration times are measured from whenever the C# code on the server\r\n  // generated the digest, whereas in the current implementation, we start measuring from\r\n  // whenever the framework finished loading.  We do have access to the server's timestamp,\r\n  // relying on it could run into trouble if the browser's clock is wrong.  SPPPlat VSO 223612\r\n  // will add a bit of logic to TimeProvider to protect against that.  Until then, we can\r\n  // work around the issue by trimming the expiration times back by a small amount, which\r\n  // represents the estimated page render time.\r\n  private static EXPIRATION_SLOP_MS: number = 3000;\r\n\r\n  private static _logSource: LogSource = LogSource.create('DigestCache');\r\n  private _fetchProvider: IFetchProvider;\r\n  private _dateProvider: ITimeProvider;\r\n\r\n  private _digestsByUrl: Map<string, ICachedDigest>;\r\n\r\n  constructor(serviceScope: ServiceScope) {\r\n    this._digestsByUrl = new Map<string, ICachedDigest>();\r\n\r\n    serviceScope.whenFinished(() => {\r\n      this._fetchProvider = serviceScope.consume(fetchProviderServiceKey);\r\n      this._dateProvider = serviceScope.consume(dateProviderServiceKey);\r\n    });\r\n  }\r\n\r\n  /** Implements IDigestCache */\r\n  public fetchDigest(webUrl: string): Promise<string> {\r\n    const normalizedWebUrl: string = UrlUtilities.removeEndSlash(webUrl);\r\n    const cachedDigest: ICachedDigest = this._digestsByUrl.get(normalizedWebUrl);\r\n\r\n    if (cachedDigest) {\r\n      const timestamp: number = this._dateProvider.getTimestamp();\r\n      if (timestamp < cachedDigest.expirationTimestamp) {\r\n        TraceLogger.logVerbose(DigestCache._logSource,\r\n          'DigestCache: Reusing cached digest.  Expiration: ' + cachedDigest.expirationTimestamp);\r\n        return Promise.resolve(cachedDigest.value);\r\n      }\r\n    }\r\n\r\n    // If it wasn't in the cache, then we need to fetch a new one.\r\n    // Create the REST API URL\r\n    const digestUrl: string = normalizedWebUrl + '/_api/contextinfo';\r\n\r\n    // NOTE: We don't want people to be injecting random headers throughout\r\n    // their code.  As HttpClient evolves, maybe there is some way we can\r\n    // combine this with the headers being added there.\r\n    const rawRequest: Request = new Request(digestUrl,\r\n      {\r\n        method: 'POST',\r\n        headers: {\r\n          'Accept': 'application/json',\r\n          'Content-type': 'application/json;odata=verbose;charset=utf-8'\r\n        },\r\n        credentials: 'same-origin',\r\n        cache: 'no-cache'\r\n      });\r\n\r\n    return this._fetchProvider.fetch(rawRequest).then((response: Response) => {\r\n      return response.json();\r\n    }).then((responseObject: IRestResponse) => {\r\n\r\n      const digestValue: string = responseObject.FormDigestValue;\r\n      const seconds: number = responseObject.FormDigestTimeoutSeconds as number;\r\n      const expirationTimeMs: number = this._dateProvider.getTimestamp() + 1000 * seconds;\r\n\r\n      this.addDigestToCache(normalizedWebUrl, digestValue, expirationTimeMs);\r\n\r\n      TraceLogger.logVerbose(DigestCache._logSource, 'DigestCache: Fetched new digest');\r\n\r\n      return digestValue;\r\n    });\r\n  }\r\n\r\n  /** Implements IDigestCache */\r\n  public addDigestToCache(webUrl: string, digestValue: string, expirationTimestamp: number): void {\r\n    const normalizedWebUrl: string = UrlUtilities.removeEndSlash(webUrl);\r\n    const newCachedDigest: ICachedDigest = {\r\n      value: digestValue,\r\n      expirationTimestamp: expirationTimestamp - DigestCache.EXPIRATION_SLOP_MS\r\n    };\r\n    this._digestsByUrl.set(normalizedWebUrl, newCachedDigest);\r\n  }\r\n\r\n  /** Implements IDigestCache */\r\n  public clearDigest(webUrl: string): boolean {\r\n    const normalizedWebUrl: string = UrlUtilities.removeEndSlash(webUrl);\r\n    const found: boolean = this._digestsByUrl.delete(normalizedWebUrl);\r\n    TraceLogger.logVerbose(DigestCache._logSource,\r\n      `DigestCache: Requested to clear cache entry: ${found ? 'found' : 'not found'}`);\r\n    return found;\r\n  }\r\n\r\n  /** Implements IDigestCache */\r\n  public clearAllDigests(): void {\r\n    this._digestsByUrl.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * Used internally by DigestCache.  This stores a request digest value and\r\n * its expiration date.\r\n */\r\ninterface ICachedDigest {\r\n  /**\r\n   * The string representing the digest.  Example value:\r\n   * \"0x6CB1C55E8C18B86...,20 Feb 2016 00:18:17 -0000\"\r\n   */\r\n  value: string;\r\n\r\n  /**\r\n   * The expiration time for the digest, in milliseconds measured using DateTime.now()\r\n   */\r\n  expirationTimestamp: number;\r\n}\r\n\r\n/**\r\n * Represents the JSON response of the /_api/contextinfo REST call.\r\n */\r\ninterface IRestResponse {\r\n  FormDigestValue: string;\r\n  FormDigestTimeoutSeconds: number;\r\n}\r\n"],"sourceRoot":"/src"}