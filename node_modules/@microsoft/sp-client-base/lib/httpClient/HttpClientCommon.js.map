{"version":3,"sources":["httpClient/HttpClientCommon.ts"],"names":[],"mappings":";AAEA;;;GAGG;AACH;IAAA;IA8EA,CAAC;IA5Ee,wCAAuB,GAArC,UAAsC,OAAoB;QACxD,IAAM,OAAO,GAAY,IAAI,OAAO,EAAE,CAAC;QAEvC,iEAAiE;QACjE,IAAI,YAAY,GAAW,KAAK,CAAC;QAEjC,iCAAiC;QACjC,EAAE,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;YACpB,IAAM,IAAI,GAAY,IAAI,OAAO,CAAC,EAAE,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;YACpE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAC,KAAa,EAAE,IAAY;gBAC/C,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,+BAA+B;gBAC5D,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,eAAe,CAAC,CAAC,CAAC;oBAC3C,YAAY,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;gBAC9B,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;QAED,0EAA0E;QAC1E,4BAA4B;QAC5B,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,KAAK,CAAC,CAAC,CAAC;YAC3C,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;gBACjC,qEAAqE;gBACrE,+CAA+C;gBAC/C,EAAE,CAAC,CAAC,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC;oBAC3B,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,8CAA8C,CAAC,CAAC;gBACjF,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,gCAAgC,CAAC,CAAC;gBACnE,CAAC;YACH,CAAC;QACH,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC3B,EAAE,CAAC,CAAC,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC;gBAC3B,+EAA+E;gBAC/E,2EAA2E;gBAC3E,4EAA4E;gBAC5E,6EAA6E;gBAC7E,4EAA4E;gBAC5E,+EAA+E;gBAC/E,+EAA+E;gBAC/E,8EAA8E;gBAC9E,gBAAgB;gBAChB,4FAA4F;gBAC5F,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,yCAAyC,CAAC,CAAC;YACtE,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;YAC/C,CAAC;QACH,CAAC;QAED,MAAM,CAAC,OAAO,CAAC;IACjB,CAAC;IAED;;;;;;;;;;OAUG;IACW,2CAA0B,GAAxC,UAAyC,OAA0B,EAAE,MAAc,EAAE,WAAyB;QAG5G,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,UAAC,QAAkB;YACrC,2EAA2E;YAC3E,yEAAyE;YACzE,sDAAsD;YACtD,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC;gBAC5B,WAAW,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YAClC,CAAC;YACD,MAAM,CAAC,QAAQ,CAAC;QAClB,CAAC,CAAC,CAAC;IACL,CAAC;IACH,uBAAC;AAAD,CA9EA,AA8EC,IAAA;AA9ED;kCA8EC,CAAA","file":"httpClient/HttpClientCommon.js","sourcesContent":["import IDigestCache from './IDigestCache';\r\n\r\n/**\r\n * NOT PUBLIC.  This class contains some internal code shared between HttpClient\r\n * and OdataBatch.\r\n */\r\nexport default class HttpClientCommon {\r\n\r\n  public static constructDefaultHeaders(options: RequestInit): Headers {\r\n    const headers: Headers = new Headers();\r\n\r\n    // HttpClient is OData 4.0 by default.  ODataBatch is always 4.0.\r\n    let odataVersion: string = '4.0';\r\n\r\n    // Copy over the existing headers\r\n    if (options.headers) {\r\n      const temp: Request = new Request('', { headers: options.headers });\r\n      temp.headers.forEach((value: string, name: string) => {\r\n        headers.append(name, value); // note name/value are reversed\r\n        if (name.toUpperCase() === 'ODATA-VERSION') {\r\n          odataVersion = value.trim();\r\n        }\r\n      });\r\n    }\r\n\r\n    // Add some default headers that people should specify for any REST query,\r\n    // assuming it's not missing\r\n    if (options.method.toUpperCase() !== 'GET') {\r\n      if (!headers.has('Content-Type')) {\r\n        // Assume our POST data is in JSON format unless otherwise specified.\r\n        // Also explicitly specify utf-8 (the default).\r\n        if (odataVersion === '3.0') {\r\n          headers.append('Content-Type', 'application/json;odata=verbose;charset=utf-8');\r\n        } else {\r\n          headers.append('Content-Type', 'application/json;charset=utf-8');\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!headers.has('Accept')) {\r\n      if (odataVersion === '4.0') {\r\n        // Request for the ODATA response to be 'minimal' (the default).  The guidance:\r\n        // \"If a client prefers a very small wire size and is intelligent enough to\r\n        // compute data using metadata expressions, the Accept header should include\r\n        // odata.metadata=minimal. If compute is more expensive than wire size or the\r\n        // client is incapable of computing control information, odata.metadata=full\r\n        // directs the service to inline the control information that normally would be\r\n        // computed from metadata expressions in the payload. odata.metadata=none is an\r\n        // option for clients that have out-of-band knowledge or don't require control\r\n        // information.\"\r\n        // http://docs.oasis-open.org/odata/odata-json-format/v4.0/os/odata-json-format-v4.0-os.html\r\n        headers.append('Accept', 'application/json;odata.metadata=minimal');\r\n      } else {\r\n        headers.append('Accept', 'application/json');\r\n      }\r\n    }\r\n\r\n    return headers;\r\n  }\r\n\r\n  /**\r\n   * For both HttpClient and ODataBatch, we fetch a digest and then use it to\r\n   * to make a REST call.  If the REST fails in a way that the digest is invalid,\r\n   * we need to discard the bad digest.  This function is the common implementation\r\n   * of that logic, in case we need to add special cases in the future.\r\n   *\r\n   * @param promise       - the promise returned by IFetchProvider.fetch()\r\n   * @param webUrl        - the cache key to clear\r\n   * @param digestCache   - the cache\r\n   * @returns             - the promise after this logic is applied\r\n   */\r\n  public static handleAuthenticationErrors(promise: Promise<Response>, webUrl: string, digestCache: IDigestCache):\r\n    Promise<Response> {\r\n\r\n    return promise.then((response: Response): Response => {\r\n      // If the response is 403, this could be because our digest was invalidated\r\n      // before its natural expiration time.  In this case, we should clear the\r\n      // cache so that next time we will fetch a new digest.\r\n      if (response.status === 403) {\r\n        digestCache.clearDigest(webUrl);\r\n      }\r\n      return response;\r\n    });\r\n  }\r\n}\r\n"],"sourceRoot":"/src"}