{"version":3,"sources":["httpClient/ODataBatch.ts"],"names":[],"mappings":"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","file":"httpClient/ODataBatch.js","sourcesContent":["/**\r\n * @copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\n\r\nimport * as lodash from '@microsoft/sp-lodash-subset';\r\nimport ServiceScope from '../serviceScope/ServiceScope';\r\nimport ODataBatchedRequest from './ODataBatchedRequest';\r\nimport HttpClient from './HttpClient';\r\nimport Guid from '../guid/Guid';\r\nimport { IFetchProvider, fetchProviderServiceKey  } from './FetchProvider';\r\nimport { IRandomProvider, randomProviderServiceKey } from '../common/RandomProvider';\r\nimport IDigestCache, { digestCacheServiceKey } from './IDigestCache';\r\nimport HttpClientCommon from './HttpClientCommon';\r\n\r\n/**\r\n * The ODataBatch class accumulates a number of REST service calls and\r\n * transmits them as a single ODATA batch.  This protocol is documented here:\r\n * http://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part1-protocol.html\r\n *\r\n * The usage is to call ODataBatch.fetch() to queue each individual request,\r\n * and then call ODataBatch.execute() to execute the batch operation.\r\n * The execute() method returns a promise that resolves when the real REST\r\n * call has completed.  Each call to fetch() also returns a promise that will\r\n * resolve with a Response object for that particular request.\r\n *\r\n * @public\r\n */\r\nexport default class ODataBatch {\r\n  private _batchOptions: IODataBatchOptions;\r\n  private _fetchProvider: IFetchProvider;\r\n  private _randomProvider: IRandomProvider;\r\n  private _digestCache: IDigestCache;\r\n\r\n  private _batchedRequests: ODataBatchedRequest[];\r\n  private _webUrl: string;\r\n\r\n  public constructor(serviceScope: ServiceScope, batchOptions?: IODataBatchOptions) {\r\n    this._batchOptions = batchOptions || {};\r\n    this._batchedRequests = [];\r\n\r\n    serviceScope.whenFinished(() => {\r\n      this._fetchProvider = serviceScope.consume(fetchProviderServiceKey);\r\n      this._randomProvider = serviceScope.consume(randomProviderServiceKey);\r\n      this._digestCache = serviceScope.consume(digestCacheServiceKey);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queues a new request, and returns a promise that can be used to access\r\n   * the server response (after execute() has completed).  The parameters for\r\n   * this function are basically the same as the WHATWG API standard documented here:\r\n   * https://fetch.spec.whatwg.org/\r\n   *\r\n   * However, be aware that certain REST headers are ignored or not allowed inside\r\n   * a batch.  See the ODATA documentation for details.\r\n   *\r\n   * When execute() is called, it will POST to a URL such as\r\n   * \"http://example.com/sites/sample/_api/$batch\".  Typically ODataBatch can successfully\r\n   * guess the appropriate SPWeb URL by looking for a reserved URL segment such as \"_api\"\r\n   * in the first URL passed to fetch().  If not, use IODataBatchOptions.webUrl to specify it\r\n   * explicitly.\r\n   *\r\n   * @params url - the URL to fetch, or an already initialized Request object\r\n   * @params options - additional options that affect the request\r\n   * @returns a promise that will return the result\r\n   */\r\n  public fetch(url: string, options?: IODataBatchRequestOptions):\r\n    Promise<Response> {\r\n\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    // Apply most of the same default headers as HttpClient\r\n    const modifiedOptions: IODataBatchRequestOptions = lodash.clone(options);\r\n    modifiedOptions.headers = HttpClientCommon.constructDefaultHeaders(options);\r\n\r\n    const request: Request = new Request(url, modifiedOptions);\r\n    const requestUrl: string = request.url;\r\n\r\n    if (!this._webUrl) {\r\n      // If the webUrl wasn't provided to the constructor, then we infer it from\r\n      // the first request.\r\n      this._webUrl = HttpClient.getWebUrlFromRequestUrl(requestUrl);\r\n    }\r\n\r\n    const batchedRequest: ODataBatchedRequest = new ODataBatchedRequest(request);\r\n    this._batchedRequests.push(batchedRequest);\r\n    return batchedRequest.promise;\r\n  }\r\n\r\n  /**\r\n   * Calls fetch(), but sets the method to 'GET'.\r\n   * @params url - the URL to fetch\r\n   * @params options - additional options that affect the request\r\n   * @returns a promise that will return the result\r\n   */\r\n  public get(url: string, options?: IODataBatchRequestOptions): Promise<Response> {\r\n    const modifiedOptions: IODataBatchRequestOptions = lodash.clone(options || {});\r\n    modifiedOptions.method = 'GET';\r\n    return this.fetch(url, modifiedOptions);\r\n  }\r\n\r\n  /**\r\n   * Calls fetch(), but sets the method to 'POST'.\r\n   * @params url - the URL to fetch\r\n   * @params options - additional options that affect the request\r\n   * @returns a promise that will return the result\r\n   */\r\n  public post(url: string, options: IODataBatchRequestOptions): Promise<Response> {\r\n    const modifiedOptions: IODataBatchRequestOptions = lodash.clone(options || {});\r\n    modifiedOptions.method = 'POST';\r\n    return this.fetch(url, modifiedOptions);\r\n  }\r\n\r\n  /**\r\n   * Executes the batched queries that were queued using ODataBatch.fetch().\r\n   */\r\n  public execute(): Promise<ODataBatch> {\r\n    let batchBody: string = '\\n';\r\n\r\n    const batchGuid: Guid = Guid.newGuid(this._randomProvider);\r\n\r\n    // In the loop below, we will build up a chain of promises that append\r\n    // each request to the batch body, and then the \"return\" statement will\r\n    // add the final processing to the chain.\r\n    let chain: Promise<void> = Promise.resolve<void>();\r\n\r\n    this._batchedRequests.forEach(\r\n      (batchedRequest: ODataBatchedRequest) => {\r\n\r\n        chain = chain.then(() => {\r\n          return batchedRequest.request.text();\r\n        }).then((requestText: string) => {\r\n          const request: Request = batchedRequest.request;\r\n\r\n          batchBody += `--batch_${batchGuid.toString()}\\n`;\r\n          batchBody += `Content-type: application/http\\n`\r\n            + `Content-Transfer-Encoding: binary\\n\\n`;\r\n\r\n          // Example:\r\n          // \"POST https://example.com/_api/web HTTP/1.1\"\r\n          batchBody += `${request.method} ${request.url} HTTP/1.1\\n`;\r\n\r\n          request.headers.forEach((value: string, name: string) => {\r\n            batchBody += `${name}: ${value}\\n`;\r\n          });\r\n          batchBody += '\\n';\r\n          batchBody += requestText;\r\n          batchBody += '\\n\\n';\r\n        });\r\n      }\r\n    );\r\n\r\n    return chain.then(() => {\r\n      // Close the batch\r\n      batchBody += `--batch_${batchGuid}--\\n`;\r\n\r\n      return this._digestCache.fetchDigest(this._webUrl);\r\n    }).then((digest: string) => {\r\n\r\n      // Start the $batch request\r\n      const headers: Headers = new Headers();\r\n      headers.append('Accept', 'application/json');\r\n      headers.append('OData-Version', '4.0');\r\n      headers.append('Content-Type', `multipart/mixed; boundary=batch_${batchGuid}`);\r\n      headers.append('Content-Length', batchBody.length.toString());\r\n      headers.append('X-RequestDigest', digest);\r\n\r\n      const request: Request = new Request(this._webUrl + '/_api/$batch', {\r\n        method: 'POST',\r\n        headers: headers,\r\n        body: batchBody,\r\n        credentials: 'same-origin',\r\n        cache: 'no-cache'\r\n      });\r\n\r\n      const promise: Promise<Response> = this._fetchProvider.fetch(request);\r\n      return HttpClientCommon.handleAuthenticationErrors(promise, this._webUrl, this._digestCache);\r\n    }).then((response: Response) => {\r\n      if (!response.ok) {\r\n        throw new Error('ODataBatch: The batch request failed: ' + response.statusText);\r\n      }\r\n      return response.text();\r\n    }).then((text: string) => {\r\n      const responses: Response[] = this._parseResponsesFromBody(text);\r\n      if (responses.length !== this._batchedRequests.length) {\r\n        throw new Error(`ODataBatch: Expecting ${this._batchedRequests.length} responses`);\r\n      }\r\n\r\n      for (let i: number = 0; i < this._batchedRequests.length; ++i) {\r\n        const request: ODataBatchedRequest = this._batchedRequests[i];\r\n        request.notifyCompleted(responses[i]);\r\n      }\r\n\r\n      return this;\r\n    });\r\n  }\r\n\r\n  private _parseResponsesFromBody(text: string): Response[] {\r\n    const responses: Response[] = [];\r\n\r\n    const header: string = '--batchresponse_';\r\n\r\n    // Ex. \"HTTP/1.1 500 Internal Server Error\"\r\n    const statusRegExp: RegExp = new RegExp('^HTTP/[0-9.]+ +([0-9]+) +(.*)', 'i');\r\n\r\n    const lines: string[] = text.split('\\n');\r\n\r\n    let parserState: string = 'batch';\r\n    let batchStatus: number;\r\n    let batchStatusText: string;\r\n\r\n    for (let i: number = 0; i < lines.length; ++i) {\r\n      const line: string = lines[i];\r\n      switch (parserState) {\r\n        case 'batch':\r\n          if (line.substr(0, header.length) === header) {\r\n            parserState = 'batchHeaders';\r\n          } else {\r\n            if (line.trim() !== '') {\r\n              throw new Error('ODataBatch: Invalid response, line ' + i);\r\n            }\r\n          }\r\n          break;\r\n        case 'batchHeaders':\r\n          if (line.trim() === '') {\r\n            parserState = 'status';\r\n          }\r\n          break;\r\n        case 'status':\r\n          // Ex. \"HTTP/1.1 500 Internal Server Error\"\r\n          const parts: string[] = statusRegExp.exec(line);\r\n          if (parts.length !== 3) {\r\n            throw new Error('ODataBatch: Invalid status, line ' + i);\r\n          }\r\n          // Ex. \"500\"\r\n          batchStatus = parseInt(parts[1], 10);\r\n          // Ex. \"Internal Server Error\"\r\n          batchStatusText = parts[2];\r\n          parserState = 'statusHeaders';\r\n          break;\r\n        case 'statusHeaders':\r\n          if (line.trim() === '') {\r\n            parserState = 'body';\r\n          }\r\n          break;\r\n        case 'body':\r\n          let response: Response;\r\n          if (batchStatus === 204) {\r\n            // https://github.com/whatwg/fetch/issues/178\r\n            response = new Response();\r\n          } else {\r\n            response = new Response(line, { status: batchStatus, statusText: batchStatusText });\r\n          }\r\n          responses.push(response);\r\n          parserState = 'batch';\r\n          break;\r\n      }\r\n    }\r\n    if (parserState !== 'status') {\r\n      throw new Error('ODataBatch: Unexpected end of input');\r\n    }\r\n\r\n    return responses;\r\n  }\r\n}\r\n\r\n/**\r\n * This interface is passed to the ODataBatch constructor.  It specifies options\r\n * that affect the entire batch.\r\n * @public\r\n */\r\nexport interface IODataBatchOptions {\r\n  /**\r\n   * ODataBatch will need to perform its POST to an endpoint such as\r\n   * \"http://example.com/sites/sample/_api/$batch\". Typically the SPWeb URL\r\n   * (\"https://example.com/sites/sample\" in this example) can be guessed by\r\n   * looking for a reserved URL segment such as \"_api\" in the first URL\r\n   * passed to fetch(), but if not, the webUrl can be explicitly specified\r\n   * using this option.\r\n   */\r\n  webUrl?: string;\r\n}\r\n\r\n/**\r\n * This interface defines the options for an individual REST request that\r\n * is part of an ODataBatch.  It is based on the WHATWG API standard\r\n * parameters that are documented here:\r\n * https://fetch.spec.whatwg.org/\r\n * @public\r\n */\r\nexport interface IODataBatchRequestOptions extends RequestInit {\r\n  // Reserved for future use\r\n}\r\n"],"sourceRoot":"/src"}