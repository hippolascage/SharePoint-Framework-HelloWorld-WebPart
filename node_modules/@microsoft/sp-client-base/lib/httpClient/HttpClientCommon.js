"use strict";
/**
 * NOT PUBLIC.  This class contains some internal code shared between HttpClient
 * and OdataBatch.
 */
var HttpClientCommon = (function () {
    function HttpClientCommon() {
    }
    HttpClientCommon.constructDefaultHeaders = function (options) {
        var headers = new Headers();
        // HttpClient is OData 4.0 by default.  ODataBatch is always 4.0.
        var odataVersion = '4.0';
        // Copy over the existing headers
        if (options.headers) {
            var temp = new Request('', { headers: options.headers });
            temp.headers.forEach(function (value, name) {
                headers.append(name, value); // note name/value are reversed
                if (name.toUpperCase() === 'ODATA-VERSION') {
                    odataVersion = value.trim();
                }
            });
        }
        // Add some default headers that people should specify for any REST query,
        // assuming it's not missing
        if (options.method.toUpperCase() !== 'GET') {
            if (!headers.has('Content-Type')) {
                // Assume our POST data is in JSON format unless otherwise specified.
                // Also explicitly specify utf-8 (the default).
                if (odataVersion === '3.0') {
                    headers.append('Content-Type', 'application/json;odata=verbose;charset=utf-8');
                }
                else {
                    headers.append('Content-Type', 'application/json;charset=utf-8');
                }
            }
        }
        if (!headers.has('Accept')) {
            if (odataVersion === '4.0') {
                // Request for the ODATA response to be 'minimal' (the default).  The guidance:
                // "If a client prefers a very small wire size and is intelligent enough to
                // compute data using metadata expressions, the Accept header should include
                // odata.metadata=minimal. If compute is more expensive than wire size or the
                // client is incapable of computing control information, odata.metadata=full
                // directs the service to inline the control information that normally would be
                // computed from metadata expressions in the payload. odata.metadata=none is an
                // option for clients that have out-of-band knowledge or don't require control
                // information."
                // http://docs.oasis-open.org/odata/odata-json-format/v4.0/os/odata-json-format-v4.0-os.html
                headers.append('Accept', 'application/json;odata.metadata=minimal');
            }
            else {
                headers.append('Accept', 'application/json');
            }
        }
        return headers;
    };
    /**
     * For both HttpClient and ODataBatch, we fetch a digest and then use it to
     * to make a REST call.  If the REST fails in a way that the digest is invalid,
     * we need to discard the bad digest.  This function is the common implementation
     * of that logic, in case we need to add special cases in the future.
     *
     * @param promise       - the promise returned by IFetchProvider.fetch()
     * @param webUrl        - the cache key to clear
     * @param digestCache   - the cache
     * @returns             - the promise after this logic is applied
     */
    HttpClientCommon.handleAuthenticationErrors = function (promise, webUrl, digestCache) {
        return promise.then(function (response) {
            // If the response is 403, this could be because our digest was invalidated
            // before its natural expiration time.  In this case, we should clear the
            // cache so that next time we will fetch a new digest.
            if (response.status === 403) {
                digestCache.clearDigest(webUrl);
            }
            return response;
        });
    };
    return HttpClientCommon;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HttpClientCommon;

//# sourceMappingURL=HttpClientCommon.js.map
