{"version":3,"sources":["serviceScope/ServiceScope.ts"],"names":[],"mappings":"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","file":"serviceScope/ServiceScope.js","sourcesContent":["import ServiceKey from './ServiceKey';\r\n\r\n/**\r\n * ServiceScope provides a formalized way for components to register and consume dependencies\r\n * (\"services\"), and to enable different implementations to be registered in different scopes.\r\n * This improves modularity by decoupling components from their dependencies in an extensible way.\r\n *\r\n * For example, suppose that various components need access to an IPageManager instance.  We could\r\n * simply make the PageManager a singleton (i.e. global variable), but this will not work e.g. if\r\n * we need to create a pop-up dialog that requires a second PageManager instance.  A better solution\r\n * would be to add the PageManager as a constructor parameter for each component that requires it,\r\n * however then we immediately face the problem that any code that calls these constructors\r\n * also needs a PageManager parameter.  In an application with many such dependencies, business\r\n * logic that ties together many subsystems would eventually pick up a constructor parameter\r\n * for every possible dependency, which is unwieldy.  A natural solution would be to move all the\r\n * dependencies into a class with name like \"ApplicationContext\", and then pass this around as our\r\n * constructor parameter.  This enables the PageManager to be passed to classes that need it\r\n * without cluttering the intermediary classes that don't.  However, it still has a design problem\r\n * that \"ApplicationContext\" has hard-coded dependencies on many unrelated things.  A more flexible\r\n * approach is to make it a dictionary that can look up items for consumers/providers who know the\r\n * right lookup key (i.e. ServiceKey).  This is the popular \"service locator\" design pattern,\r\n * familiar from the SPContext API in classic SharePoint.\r\n *\r\n * ServiceScope takes this idea a step further in two important ways:  First, it provides a scoping\r\n * mechanism so that e.g. if we had two different pages, they could each consume a unique PageManager\r\n * instance while still sharing other common dependencies.  Secondly, it allows for a ServiceKey\r\n * to provide a default implementation of the dependency.  This is important for API stability in\r\n * our modular client-side environment:  For example, suppose that version 2.0 of our application\r\n * introduced a new IDiagnosticTracing interface that a version 2.0 component will expect to consume.\r\n * If the version 2.0 component gets loaded by an older 1.0 application, it would fail.  We could\r\n * fix this by requiring each consumer to check for any missing dependencies and handle that case,\r\n * but it would require a lot of checks.  A better solution is to ensure that a default implementation\r\n * always exists, perhaps just a trivial behavior, so that components don't have to worry about it.\r\n *\r\n * Usage: ServiceScope instances are created by calling either ServiceScope.startNewRoot() or\r\n * ServiceScope.startNewChild().  They are initially in an \"unfinished\" state, during which provide()\r\n * can be called to register service keys, but consume() is forbidden.  After ServiceScope.finish()\r\n * is called, consume() is allowed and provide() is now forbidden.  These semantics ensure that\r\n * ServiceScope.consume() always returns the same result for the same key, and does not depend on\r\n * order of initialization.  It also allows us to support circular dependencies without worrying\r\n * about infinite loops, even when working with external components that were implemented by\r\n * third parties.  To avoid mistakes, it's best to always call consume() inside a callback from\r\n * serviceScope.whenFinished().\r\n * @public\r\n */\r\nexport default class ServiceScope {\r\n  private _parent: ServiceScope;\r\n  private _registrations: {\r\n    /* tslint:disable:no-any */\r\n    [keyId: string]: IRegistration<any>\r\n    /* tslint:enable:no-any */\r\n  };\r\n  private _pendingCallbacks: Array<() => void>;\r\n  private _finished: boolean;\r\n  private _autocreating: boolean;\r\n\r\n  /**\r\n   * Create a new root-level ServiceScope.  Only root-level scopes have the ability to autocreate\r\n   * default implementations of ServiceKeys.\r\n   * @returns - the newly created root ServiceScope\r\n   */\r\n  public static startNewRoot(): ServiceScope {\r\n    return new ServiceScope(undefined);\r\n  }\r\n\r\n  /**\r\n   * PRIVATE CONSTRUCTOR - DO NOT CALL THIS FROM YOUR OWN CODE.\r\n   */\r\n  constructor(parent: ServiceScope) {\r\n    this._parent = parent;\r\n    this._registrations = {};\r\n    this._pendingCallbacks = [];\r\n    this._finished = false;\r\n    this._autocreating = false;\r\n  }\r\n\r\n  /**\r\n   * This is a shorthand function that its equivalent to constructing a new instance of the\r\n   * simpleServiceClass, then registering it by calling ServiceScope.provide().\r\n   * @param serviceKey - the key that can be used later to consume the service\r\n   * @param simpleServiceClass - the TypeScript class to be constructed\r\n   * @returns - a newly constructed instance of simpleServiceClass\r\n   */\r\n  public createAndProvide<T>(\r\n    serviceKey: ServiceKey<T>,\r\n    simpleServiceClass: { new (serviceScope: ServiceScope); }\r\n  ): T {\r\n    return this.provide(serviceKey, new simpleServiceClass(this));\r\n  }\r\n\r\n  /**\r\n   * This is a shorthand function that constructs the default implementation of the specified\r\n   * serviceKey, and then registers it by calling ServiceScope.provide().\r\n   * @param serviceKey - the key that can be used later to consume the service\r\n   * @returns - a service instance that was constructed using ServiceKey.defaultCreator\r\n   */\r\n  public createDefaultAndProvide<T>(serviceKey: ServiceKey<T>): T {\r\n    const service: T = serviceKey.defaultCreator(this);\r\n    return this.provide(serviceKey, service);\r\n  }\r\n\r\n  /**\r\n   * Components should call this function to \"consume\" a dependency, i.e. look up the serviceKey\r\n   * and return the registered service instance.  If the instance cannot be found, then a default\r\n   * instance will be autocreated and registered with the root ServiceScope.\r\n   * @param serviceKey - the key that was used when provide() was called to register the service\r\n   * @returns - the service instance\r\n   */\r\n  public consume<T>(serviceKey: ServiceKey<T>): T {\r\n    if (!this._finished) {\r\n      throw new Error('Cannot consume services because the scope is not finished yet');\r\n    }\r\n    if (this._autocreating) {\r\n      throw new Error('Cannot consume services during autocreation');\r\n    }\r\n\r\n    const registration: IRegistration<T> = this._registrations[serviceKey.id];\r\n    if (registration) {\r\n      return registration.service;\r\n    }\r\n    if (this._parent) {\r\n      return this._parent.consume<T>(serviceKey);\r\n    }\r\n\r\n    // We've reached the root scope without finding the service.  Construct a default instance\r\n    let autocreatedService: T;\r\n    this._autocreating = true;\r\n    try {\r\n      autocreatedService = serviceKey.defaultCreator(this);\r\n      this._registrations[serviceKey.id] = { serviceKey, service: autocreatedService };\r\n    }\r\n    finally {\r\n      this._autocreating = false;\r\n    }\r\n    this._processPendingCallbacks();\r\n    return autocreatedService;\r\n  }\r\n\r\n  /**\r\n   * When a ServiceScope is first started, it is in an \"unfinished\" state where provide() is\r\n   * allowed but consume() is not allowed.  After calling finish(), then consume() is allowed\r\n   * but provide() is not allowed.  This formalism completely eliminates a number of tricky bugs\r\n   * such as:  Scope2 is a child of Scope1, and Scope1 provides instance A1 of interface A;\r\n   * if someone consumes A1 from Scope2 (via inheritance) before Scope2.provide() is called\r\n   * with A2, then a subsequent call to Scope2.consume() might return a different result than\r\n   * the previous call, which would be very confusing for developers.\r\n   */\r\n  public finish(): void {\r\n    if (this._finished) {\r\n      throw new Error('Already finished');\r\n    }\r\n    this._finished = true;\r\n    this._processPendingCallbacks();\r\n  }\r\n\r\n  /**\r\n   * Returns the parent of the current ServiceScope, or undefined if this is a root scope.\r\n   * @returns - the parent service scope\r\n   */\r\n  public getParent(): ServiceScope {\r\n    return this._parent;\r\n  }\r\n\r\n  /**\r\n   * It is an error to call ServiceScope.consume() before finish() has been called.\r\n   * The most reliable way to protect your component against this error is to perform the\r\n   * consume() calls inside a whenFinished() callback.  If the service scope is already\r\n   * finished, then the callback will be executed immediately; otherwise, it will be executed\r\n   * later when the scope is finished.\r\n   * @param callback - A block of code that needs to call ServiceScope.consume()\r\n   */\r\n  public whenFinished(callback: () => void): void {\r\n    if (this._finished && !this._autocreating) {\r\n      callback();\r\n    } else {\r\n      this._pendingCallbacks.push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ServiceScope.provide() is used to register an implemententation of the given serviceKey\r\n   * for the current scope.  It may only be used when the ServiceScope is in an \"unfinished\"\r\n   * state, i.e. before finish() has been called.\r\n   * @param serviceKey - the key that will later be used to consume the service\r\n   * @param service - the service instance that is being registered\r\n   * @returns - the same object that was passed as the \"service\" parameter\r\n   */\r\n  public provide<T>(serviceKey: ServiceKey<T>, service: T): T {\r\n    if (this._finished) {\r\n      throw new Error('Cannot register service because the scope is already finished');\r\n    }\r\n    if (this._registrations[serviceKey.id]) {\r\n      throw new Error('The specified service key has already been registered in this scope');\r\n    }\r\n\r\n    this._registrations[serviceKey.id] = { serviceKey, service };\r\n    return service;\r\n  }\r\n\r\n  /**\r\n   * Constructs a new ServiceScope that is a child of the current scope.  For any keys\r\n   * that are not explicitly provided by the child scope, the parent hierarchy will be\r\n   * consulted.\r\n   * @returns - the newly created root ServiceScope\r\n   */\r\n  public startNewChild(): ServiceScope {\r\n    return new ServiceScope(this);\r\n  }\r\n\r\n  private _processPendingCallbacks(): void {\r\n    const pendingCallbacks: Array<() => void> = this._pendingCallbacks;\r\n    this._pendingCallbacks = [];\r\n    for (const pendingCallback of pendingCallbacks) {\r\n      pendingCallback();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This is a convenient interface that can be used to indicate that an object\r\n * has an associated ServiceScope.\r\n * @public\r\n */\r\nexport interface IServiceScopeProvider {\r\n  /**\r\n   * Returns a ServiceScope instance that can be used to obtain dependencies\r\n   * for the current context.\r\n   * @readonly\r\n   */\r\n  serviceScope: ServiceScope;\r\n}\r\n\r\ninterface IRegistration<T> {\r\n  serviceKey: ServiceKey<T>;\r\n  service: T;\r\n}\r\n"],"sourceRoot":"/src"}