/**
 * @copyright Microsoft Corporation.All rights reserved.
 * @file TraceLogger.ts
 * TraceLogger logger
 */
"use strict";
var odsp_utilities_bundle_1 = require('@ms/odsp-utilities-bundle');
var ApplicationLogSettings_1 = require('./ApplicationLogSettings');
var LogEvent_1 = require('./LogEvent');
var LogLevel_1 = require('./LogLevel');
/**
 * This is used to log errors and debugging information.
 * @internal
 */
var TraceLogger = (function () {
    function TraceLogger() {
    }
    /*
    * Exception logging
    * This shoule be used whenever you want to log something that might in future help to debug failures.
    * The error parameter is the only required one and basically will be just converted to string and
    * logged to Debug stream (RealibilityLogs in SLAPI).
    * It will also be uploaded to the server immediately and not wait for next batch log upload.
    * If you don't specify second parameter:eventName
    * the event name for all errors logged that way will be same "CaughtError" with
    * appropriate prefix ("ModernPublish.CaughtError" etc.)
    * These two parameters "eventName and resultCode" are there to be used from Qos.
    * It is not encouraged to use them directly from ErrorHelper but if you do,
    * the log will be written with custom event name of following format:
    * <ApplicationName>.<eventName>.<resultCode>.Failure, ApplicationName is set in ApplicationLogSettings
    **/
    TraceLogger.logError = function (source, error, eventName, resultCode) {
        if (!error) {
            throw new Error('error is invalid');
        }
        this._log(source, error, eventName, true, resultCode);
    };
    /*
     * Trace logging
     * The idea here is that verbose logs don't get uploaded to the server unless
     * a failure is logged using ErrorHelper.log method.
     * There is a circular buffer that holds last 50 verbose logs from all scenarios and
     * it is only flushed and uploaded in case a failure is logged.
     * That way whenever you get a failure event with message you also have all supportive verbose messages
     * you logged throughout your scenario execution (or other scenarios).
     * And hopefully that would help you get to the bottom of what exactly went wrong.
     * If no failure happens and your scenario succeeds, verbose logs will be just left in the buffer
     * and most likely overriden by next scenario that logs something verbose.
    **/
    TraceLogger.logVerbose = function (source, message, eventName) {
        if (!message || message.length === 0) {
            throw new Error('message is invalid');
        }
        this._log(source, message, eventName, false, undefined);
    };
    /*
    * Exception logging With LogEntry
    * error message should be packed into logProperties
    * LogType should be LogType.Error and LogProperties should have {error:errorMessage}
    * Do NOT add PII data!
    **/
    TraceLogger.logErrorWithLogEntry = function (source, logEntry, eventName, resultCode) {
        if (!logEntry) {
            throw new Error('LogEntry is invalid');
        }
        this._log(source, logEntry.toString(), eventName, true, resultCode);
    };
    /*
    * Trace logging with LogEntry
    * The same with above other than wrapped log into logEntry
    * Trace message should be packed into logProperties
    * LogType should be LogType.Trace and LogProperties should have somthing like{errors:errorMessage}
    * Do NOT add PII data!
    **/
    TraceLogger.logVerboseWithLogEntry = function (source, logEntry, eventName) {
        if (!logEntry) {
            throw new Error('LogEntry is invalid');
        }
        this._log(source, logEntry.toString(), eventName, false, undefined);
    };
    TraceLogger._log = function (source, data, eventName, isError, resultCode) {
        // TODO (VSO #163792): move the initialization to shell start.
        ApplicationLogSettings_1.default.initialize();
        var enhancedEventName = this._addEventPrefix(source, eventName);
        if (isError) {
            odsp_utilities_bundle_1.ErrorHelper.log(data, enhancedEventName, resultCode);
            LogEvent_1.default.log(enhancedEventName, data, LogLevel_1.LogLevel.Error);
        }
        else {
            odsp_utilities_bundle_1.ErrorHelper.verbose(data.toString(), enhancedEventName);
            LogEvent_1.default.log(enhancedEventName, data.toString(), LogLevel_1.LogLevel.Verbose);
        }
        this._writeToConsole(data.toString(), enhancedEventName, isError, resultCode);
    };
    /*
    * EventName is:
    * sourceId.eventName or sourceId if eventName is not provided.
    */
    TraceLogger._addEventPrefix = function (source, eventName) {
        if (!eventName) {
            return source.id;
        }
        else {
            return source.id + "." + eventName;
        }
    };
    /*
    * The log message in console is:
    * [eventName]: data.
    */
    TraceLogger._writeToConsole = function (data, eventName, isError, resultCode) {
        var errorString = "[" + eventName + "] " + data;
        if (resultCode) {
            errorString += ". resultCode: " + resultCode;
        }
        // Task 191596: only write to console when a condition is satisfied (e.g., a query parameter provided).
        if (isError) {
            console.error(errorString);
        }
        else {
            console.log(errorString);
        }
    };
    return TraceLogger;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TraceLogger;

//# sourceMappingURL=TraceLogger.js.map
