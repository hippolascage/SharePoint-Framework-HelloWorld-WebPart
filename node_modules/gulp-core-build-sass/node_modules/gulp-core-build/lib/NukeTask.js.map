{"version":3,"sources":["NukeTask.ts"],"names":[],"mappings":";;;;;;AAAA,yBAAyB,YAAY,CAAC,CAAA;AAMtC;IAA8B,4BAAqB;IAAnD;QAA8B,8BAAqB;QAC1C,SAAI,GAAG,MAAM,CAAC;QAEd,eAAU,GAAgB,EAChC,CAAC;IA2CJ,CAAC;IAzCQ,8BAAW,GAAlB,UACE,IAAe,EACf,gBAAwC;QAExC,IAAI,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;QACzB,IAAA,qBAA0E,EAApE,0BAAU,EAAE,wBAAS,EAAE,8BAAY,EAAE,0BAAU,CAAsB;QAC3E,IAAI,SAAS,GAAG;YACd,UAAU;YACV,YAAY;YACZ,SAAS;YACT,UAAU;SACX,CAAC;QAEF,wEAAwE;QACxE,GAAG,CAAC,CAAmB,UAA4B,EAA5B,KAAA,IAAI,CAAC,WAAW,CAAC,WAAW,EAA5B,cAA4B,EAA5B,IAA4B,CAAC;YAA/C,IAAI,UAAU,SAAA;YACjB,EAAE,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC;gBAC5B,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,YAAY,EAAE,CAAC,CAAC;YAC1D,CAAC;SACF;QAED,IAAI,WAAW,GAAG,EAAE,CAAC;QAErB,uEAAuE;QACvE,SAAS,CAAC,OAAO,CAAC,UAAA,IAAI;YACpB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACX,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YAC3B,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,kDAAkD;QAClD,SAAS,GAAG,EAAE,CAAC;QACf,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,WAAW,CAAC,CAAC,CAAC;YAC7B,EAAE,CAAC,CAAC,WAAW,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvB,CAAC;QACH,CAAC;QAED,GAAG,CAAC,SAAS,CAAC;aACX,IAAI,CAAC,cAAM,OAAA,gBAAgB,EAAE,EAAlB,CAAkB,CAAC;aAC9B,KAAK,CAAC,UAAC,KAAK,IAAK,OAAA,gBAAgB,CAAC,KAAK,CAAC,EAAvB,CAAuB,CAAC,CAAC;IAC/C,CAAC;IACH,eAAC;AAAD,CA/CA,AA+CC,CA/C6B,mBAAQ,GA+CrC;AA/CY,gBAAQ,WA+CpB,CAAA","file":"NukeTask.js","sourcesContent":["import { GulpTask } from './GulpTask';\nimport gulp = require('gulp');\n\nexport interface INukeConfig {\n}\n\nexport class NukeTask extends GulpTask<INukeConfig> {\n  public name = 'nuke';\n\n  public taskConfig: INukeConfig = {\n  };\n\n  public executeTask(\n    gulp: gulp.Gulp,\n    completeCallback: (result?: any) => void\n  ): Promise<any> | NodeJS.ReadWriteStream | void {\n    let del = require('del');\n    let { distFolder, libFolder, libAMDFolder, tempFolder } = this.buildConfig;\n    let nukePaths = [\n      distFolder,\n      libAMDFolder,\n      libFolder,\n      tempFolder\n    ];\n\n    // Give each registered task an opportunity to add their own nuke paths.\n    for (let executable of this.buildConfig.uniqueTasks) {\n      if (executable.getNukeMatch) {\n        nukePaths = nukePaths.concat(executable.getNukeMatch());\n      }\n    }\n\n    let uniquePaths = {};\n\n    // Create dictionary of unique paths. (Could be replaced with ES6 set.)\n    nukePaths.forEach(path => {\n      if (!!path) {\n        uniquePaths[path] = path;\n      }\n    });\n\n    // Reset nukePaths to only unique non-empty paths.\n    nukePaths = [];\n    for (let path in uniquePaths) {\n      if (uniquePaths.hasOwnProperty(path)) {\n        nukePaths.push(path);\n      }\n    }\n\n    del(nukePaths)\n      .then(() => completeCallback())\n      .catch((error) => completeCallback(error));\n  }\n}\n"],"sourceRoot":"/source/"}