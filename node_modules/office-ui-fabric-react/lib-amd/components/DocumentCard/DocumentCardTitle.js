var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define(["require", "exports", 'react', '../../utilities/eventGroup/EventGroup', './DocumentCardTitle.scss'], function (require, exports, React, EventGroup_1) {
    "use strict";
    var TRUNCATION_SEPARATOR = '&hellip;';
    var TRUNCATION_MINIMUM_LENGTH = 40;
    var TRUNCATION_MAXIMUM_LENGTH = 90 - TRUNCATION_SEPARATOR.length;
    var TRUNCATION_FIRST_PIECE_LONGER_BY = 10;
    var TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;
    var DocumentCardTitle = (function (_super) {
        __extends(DocumentCardTitle, _super);
        function DocumentCardTitle(props) {
            _super.call(this, props);
            this.state = {
                truncatedTitleFirstPiece: '',
                truncatedTitleSecondPiece: ''
            };
            this._events = new EventGroup_1.EventGroup(this);
            this._startTruncation = this._startTruncation.bind(this);
        }
        DocumentCardTitle.prototype.componentDidMount = function () {
            if (this.props.shouldTruncate) {
                this._startTruncation();
                this._events.on(window, 'resize', this._updateTruncation);
            }
        };
        DocumentCardTitle.prototype.componentWillUnmount = function () {
            this._events.dispose();
        };
        DocumentCardTitle.prototype.componentWillReceiveProps = function (newProps) {
            if ((newProps.title !== this.props.title) && this.props.shouldTruncate) {
                this._startTruncation();
            }
        };
        DocumentCardTitle.prototype.componentDidUpdate = function () {
            // If we're truncating, make sure the title fits
            if (this.props.shouldTruncate) {
                this._shrinkTitle();
            }
        };
        DocumentCardTitle.prototype.render = function () {
            var _a = this.props, title = _a.title, shouldTruncate = _a.shouldTruncate;
            var _b = this.state, truncatedTitleFirstPiece = _b.truncatedTitleFirstPiece, truncatedTitleSecondPiece = _b.truncatedTitleSecondPiece;
            var documentCardTitle;
            if (shouldTruncate && (truncatedTitleFirstPiece || truncatedTitleSecondPiece)) {
                documentCardTitle = (React.createElement("div", {className: 'ms-DocumentCardTitle', ref: 'titleElement', title: title}, truncatedTitleFirstPiece, "â€¦", truncatedTitleSecondPiece));
            }
            else {
                documentCardTitle = (React.createElement("div", {className: 'ms-DocumentCardTitle', ref: 'titleElement', title: title}, title));
            }
            return (React.createElement("div", null, documentCardTitle));
        };
        DocumentCardTitle.prototype._startTruncation = function () {
            var originalTitle = this.props.title;
            // If the title is really short, there's no need to truncate it
            if (originalTitle && originalTitle.length >= TRUNCATION_MINIMUM_LENGTH) {
                // Break the text into two pieces for assembly later
                if (originalTitle.length > TRUNCATION_MAXIMUM_LENGTH) {
                    // The text is really long, so we can take a chunk out of the middle so the two pieces combine for the maximum length
                    this.setState({
                        truncatedTitleFirstPiece: originalTitle.slice(0, TRUNCATION_MAXIMUM_LENGTH / 2 + TRUNCATION_FIRST_PIECE_LONGER_BY),
                        truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - (TRUNCATION_MAXIMUM_LENGTH / 2 - TRUNCATION_FIRST_PIECE_LONGER_BY))
                    });
                }
                else {
                    // The text is not so long, so we'll just break it into two pieces
                    this.setState({
                        truncatedTitleFirstPiece: originalTitle.slice(0, Math.ceil(originalTitle.length / 2) + TRUNCATION_FIRST_PIECE_LONGER_BY),
                        truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - Math.floor(originalTitle.length / 2) + TRUNCATION_FIRST_PIECE_LONGER_BY)
                    });
                }
            }
            // Save the width we just started truncation at, so that later we will only update truncation if necessary
            this._truncatedTitleAtWidth = this.refs.titleElement.clientWidth;
        };
        DocumentCardTitle.prototype._shrinkTitle = function () {
            if (this._doesTitleOverflow()) {
                var _a = this.state, truncatedTitleFirstPiece = _a.truncatedTitleFirstPiece, truncatedTitleSecondPiece = _a.truncatedTitleSecondPiece;
                this.setState({
                    truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),
                    truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1)
                });
            }
        };
        DocumentCardTitle.prototype._doesTitleOverflow = function () {
            var titleElement = this.refs.titleElement;
            return titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD || titleElement.scrollWidth > titleElement.clientWidth;
        };
        DocumentCardTitle.prototype._updateTruncation = function () {
            // Only update truncation if the title's size has changed since the last time we truncated
            if (this.refs.titleElement.clientWidth !== this._truncatedTitleAtWidth) {
                // Throttle truncation so that it doesn't happen during a window resize
                clearTimeout(this._scrollTimerId);
                this._scrollTimerId = setTimeout(this._startTruncation, 250);
            }
        };
        return DocumentCardTitle;
    }(React.Component));
    exports.DocumentCardTitle = DocumentCardTitle;
});
