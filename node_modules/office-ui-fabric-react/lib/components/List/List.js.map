{"version":3,"sources":["components/List/List.tsx"],"names":[],"mappings":"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","file":"components/List/List.js","sourcesContent":["import * as React from 'react';\nimport { BaseComponent } from '../../common/BaseComponent';\nimport { IListProps, IPage } from './List.Props';\nimport { css } from '../../utilities/css';\nimport { assign } from '../../utilities/object';\nimport { findIndex } from '../../utilities/array';\nimport { findScrollableParent } from '../../utilities/scrollUtilities';\n\nconst RESIZE_DELAY = 16;\nconst MIN_SCROLL_UPDATE_DELAY = 100;\nconst MAX_SCROLL_UPDATE_DELAY = 500;\nconst IDLE_DEBOUNCE_DELAY = 200;\nconst DEFAULT_ITEMS_PER_PAGE = 10;\nconst DEFAULT_PAGE_HEIGHT = 30;\nconst DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\nconst DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\n\nexport interface IListState {\n  pages?: IPage[];\n\n  /** The last versionstamp for  */\n  measureVersion?: number;\n}\n\nconst EMPTY_RECT = {\n  top: -1,\n  bottom: -1,\n  left: -1,\n  right: -1,\n  width: 0,\n  height: 0\n};\n\n// Naming expensive measures so that they're named in profiles.\nconst _measurePageRect = (element: HTMLElement) => element.getBoundingClientRect();\nconst _measureSurfaceRect = _measurePageRect;\n\n/**\n * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback if\n * provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if provided by\n * the caller, or by cached measurements if available, or by a running average, or a default fallback.\n *\n * The algorithm for rendering pages works like this:\n *\n * 1. Predict visible pages based on \"current measure data\" (page heights, surface position, visible window)\n * 2. If changes are necessary, apply changes (add/remove pages)\n * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect\n * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously\n *\n * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that\n * we can avoid re-measuring during operations that should not alter heights, like scrolling.\n *\n * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,\n * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion\n * number, which we associate with cached measurements and use to determine if a remeasure should occur.\n */\nexport class List extends BaseComponent<IListProps, IListState> {\n  public static defaultProps = {\n    startIndex: 0,\n    onRenderCell: (item, index, containsFocus) => (<div>{ (item && item.name) || '' }</div>),\n    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,\n    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND\n  };\n\n  public refs: {\n    [key: string]: React.ReactInstance,\n    root: HTMLElement,\n    surface: HTMLElement\n  };\n\n  private _estimatedPageHeight: number;\n  private _totalEstimates: number;\n  private _cachedPageHeights: { [key: string]: {\n    height: number,\n    measureVersion: number\n  } };\n  private _focusedIndex: number;\n  private _scrollElement: HTMLElement;\n  private _scrollingToIndex: number;\n  private _hasCompletedFirstRender: boolean;\n  private isFirstRenderRectUpdate: boolean;\n\n  // surface rect relative to window\n  private _surfaceRect: ClientRect;\n\n  // The visible rect that we're required to render given the current list state.\n  private _requiredRect: ClientRect;\n\n  // The visible rect that we're allowed to keep rendered. Pages outside of this rect will be removed.\n  private _allowedRect: ClientRect;\n\n  // materialized rect around visible items, relative to surface\n  private _materializedRect: ClientRect;\n\n  private _requiredWindowsAhead: number;\n  private _requiredWindowsBehind: number;\n\n  private _measureVersion: number;\n\n  constructor(props: IListProps) {\n    super(props);\n\n    this.state = {\n      pages: []\n    };\n\n    this._estimatedPageHeight = 0;\n    this._totalEstimates = 0;\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n    this.isFirstRenderRectUpdate = true;\n\n    // Track the measure version for everything.\n    this._measureVersion = 0;\n\n    // Ensure that scrolls are lazy updated.\n    this._onAsyncScroll = this._async.debounce(\n      this._onAsyncScroll,\n      MIN_SCROLL_UPDATE_DELAY,\n      {\n        leading: false,\n        maxWait: MAX_SCROLL_UPDATE_DELAY\n      });\n\n    this._onAsyncIdle = this._async.debounce(\n      this._onAsyncIdle,\n      IDLE_DEBOUNCE_DELAY, {\n        leading: false\n      });\n\n      this._onAsyncResize = this._async.debounce(\n        this._onAsyncResize,\n        RESIZE_DELAY,\n        {\n          leading: false\n        });\n\n    this._cachedPageHeights = {};\n    this._estimatedPageHeight = 0;\n    this._focusedIndex = -1;\n    this._scrollingToIndex = -1;\n  }\n\n  public componentDidMount() {\n\n    this._updatePages();\n    this._measureVersion++;\n    this._scrollElement = findScrollableParent(this.refs.root);\n\n    this._events.on(window, 'resize', this._onAsyncResize);\n    this._events.on(this.refs.root, 'focus', this._onFocus, true);\n    if (this._scrollElement) {\n      this._events.on(this._scrollElement, 'scroll', this._onScroll);\n      this._events.on(this._scrollElement, 'scroll', this._onAsyncScroll);\n    }\n  }\n\n  public componentWillReceiveProps(newProps: IListProps) {\n    if (newProps.items !== this.props.items ||\n      newProps.renderCount !== this.props.renderCount ||\n      newProps.startIndex !== this.props.startIndex) {\n\n      this._measureVersion++;\n      this._updatePages(newProps);\n    }\n  }\n\n  public shouldComponentUpdate(newProps: IListProps, newState: IListState) {\n    let { renderedWindowsAhead, renderedWindowsBehind } = this.props;\n    let { pages: oldPages } = this.state;\n    let { pages: newPages, measureVersion } = newState;\n    let shouldComponentUpdate = false;\n\n    if (\n      this._measureVersion === measureVersion &&\n      newProps.renderedWindowsAhead === renderedWindowsAhead,\n      newProps.renderedWindowsBehind === renderedWindowsBehind,\n      newProps.items === this.props.items &&\n      oldPages.length === newPages.length) {\n      for (let i = 0; i < oldPages.length; i++) {\n        let oldPage = oldPages[i];\n        let newPage = newPages[i];\n\n        if ((oldPage.key !== newPage.key ||\n          oldPage.itemCount !== newPage.itemCount)) {\n          shouldComponentUpdate = true;\n          break;\n        }\n      }\n    } else {\n      shouldComponentUpdate = true;\n    }\n\n    return shouldComponentUpdate;\n  }\n\n  public forceUpdate() {\n    // Ensure that when the list is force updated we update the pages first before render.\n    this._updateRenderRects(this.props, true);\n    this._updatePages();\n    this._measureVersion++;\n\n    super.forceUpdate();\n  }\n\n  public render() {\n    let { className } = this.props;\n    let { pages } = this.state;\n    let pageElements = [];\n\n    for (let i = 0; i < pages.length; i++) {\n      pageElements.push(this._renderPage(pages[i]));\n    }\n\n    return (\n      <div ref='root' className={ css('ms-List', className) } >\n        <div ref='surface' className='ms-List-surface'>\n          { pageElements }\n        </div>\n      </div>\n    );\n  }\n\n  private _renderPage(page: IPage): any {\n    let { onRenderCell } = this.props;\n    let cells = [];\n    let pageStyle = this._getPageStyle(page);\n\n    for (let i = 0; page.items && i < page.items.length; i++) {\n      let item = page.items[i];\n      let itemKey = (item ? item.key : null);\n\n      if (itemKey === null || itemKey === undefined) {\n        itemKey = page.startIndex + i;\n      }\n\n      cells.push(\n        <div className='ms-List-cell' key={ itemKey } data-list-index={ i + page.startIndex } data-automationid='ListCell'>\n          { onRenderCell(item, page.startIndex + i) }\n        </div>\n      );\n    }\n\n    return (\n      <div className='ms-List-page' key={ page.key } ref={ page.key } style={ pageStyle }>\n        { cells }\n      </div>\n    );\n  }\n\n  /** Generate the style object for the page. */\n  private _getPageStyle(page) {\n    let style;\n    let { getPageStyle } = this.props;\n\n    if (getPageStyle) {\n      style = getPageStyle(page);\n    }\n\n    if (!page.items) {\n      style = style || {};\n      style.height = page.height;\n    }\n\n    return style;\n  }\n\n  /** Track the last item index focused so that we ensure we keep it rendered. */\n  private _onFocus(ev) {\n    let target = ev.target as HTMLElement;\n\n    while (target !== this.refs.surface) {\n      let indexString = target.getAttribute('data-list-index');\n\n      if (indexString) {\n        this._focusedIndex = Number(indexString);\n        break;\n      }\n\n      target = target.parentElement;\n    }\n  }\n\n  /**\n   * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,\n   * we will call onAsyncIdle which will reset it back to it's correct value.\n   */\n  private _onScroll() {\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n  }\n\n  /**\n   * Debounced method to asynchronously update the visible region on a scroll event.\n   */\n  private _onAsyncScroll() {\n    this._updateRenderRects();\n\n    // Only update pages when the visible rect falls outside of the materialized rect.\n    if (!this._materializedRect || !_isContainedWithin(this._requiredRect, this._materializedRect)) {\n      this._updatePages();\n    } else {\n     // console.log('requiredRect contained in materialized', this._requiredRect, this._materializedRect);\n    }\n  }\n\n  /**\n   * This is an async debounced method that will try and increment the windows we render. If we can increment\n   * either, we increase the amount we render and re-evaluate.\n   */\n  private _onAsyncIdle() {\n    const { renderedWindowsAhead, renderedWindowsBehind } = this.props;\n    const {\n      _requiredWindowsAhead: requiredWindowsAhead,\n      _requiredWindowsBehind: requiredWindowsBehind\n    } = this;\n    const windowsAhead = Math.min(renderedWindowsAhead, requiredWindowsAhead + 1);\n    const windowsBehind = Math.min(renderedWindowsBehind, requiredWindowsBehind + 1);\n\n    if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {\n\n      // console.log('idling', windowsBehind, windowsAhead);\n\n      this._requiredWindowsAhead = windowsAhead;\n      this._requiredWindowsBehind = windowsBehind;\n      this._updateRenderRects();\n      this._updatePages();\n    }\n\n    if (renderedWindowsAhead > windowsAhead || renderedWindowsBehind > windowsBehind) {\n      // Async increment on next tick.\n      this._onAsyncIdle();\n    }\n  }\n\n  private _onAsyncResize() {\n    this.forceUpdate();\n  }\n\n  private _updatePages(props?: IListProps) {\n    let { items, startIndex, renderCount } = (props || this.props);\n\n    renderCount = this._getRenderCount(props);\n\n    // console.log('updating pages');\n\n    if (!this._requiredRect) {\n      this._updateRenderRects(props);\n    }\n\n    let newListState = this._buildPages(items, startIndex, renderCount);\n    let oldListPages = this.state.pages;\n\n    this.setState(newListState, () => {\n      // If measured version is invalid since we've updated the DOM\n      const heightsChanged = this._updatePageMeasurements(oldListPages, newListState.pages);\n\n      // On first render, we should re-measure so that we don't get a visual glitch.\n      if (heightsChanged) {\n        this._materializedRect = null;\n        if (!this._hasCompletedFirstRender) {\n          this._hasCompletedFirstRender = true;\n          this._updatePages();\n        } else {\n          this._onAsyncScroll();\n        }\n      } else {\n        // Enqueue an idle bump.\n        this._onAsyncIdle();\n      }\n    });\n  }\n\n  private _updatePageMeasurements(oldPages: IPage[], newPages: IPage[]) {\n    let renderedIndexes = {};\n    let heightChanged = false;\n    let renderCount = this._getRenderCount();\n\n    for (let i = 0; i < oldPages.length; i++) {\n      let page = oldPages[i];\n\n      if (page.items) {\n        renderedIndexes[page.startIndex] = page;\n      }\n    }\n\n    for (let i = 0; i < newPages.length; i++) {\n      let page = newPages[i];\n\n      if (page.items) {\n        // Only evaluate page height if the page contains less items than total.\n        if (page.items.length < renderCount) {\n          heightChanged = this._measurePage(page) || heightChanged;\n        }\n\n        if (!renderedIndexes[page.startIndex]) {\n          this._onPageAdded(page);\n        } else {\n          delete renderedIndexes[page.startIndex];\n        }\n      }\n    }\n\n    for (let index in renderedIndexes) {\n      if (renderedIndexes.hasOwnProperty(index)) {\n        this._onPageRemoved(renderedIndexes[index]);\n      }\n    }\n\n    return heightChanged;\n  }\n\n  /**\n   * Given a page, measure its dimensions, update cache.\n   * @returns True if the height has changed.\n   */\n  private _measurePage(page: IPage): boolean {\n    let hasChangedHeight = false;\n    let pageElement = this.refs[page.key] as HTMLElement;\n    let cachedHeight = this._cachedPageHeights[page.startIndex];\n\n    // console.log('   * measure attempt', page.startIndex, cachedHeight);\n\n    if (pageElement && (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)) {\n      let newClientRect = _measurePageRect(pageElement);\n\n      hasChangedHeight = page.height !== newClientRect.height;\n\n      // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);\n\n      page.height = newClientRect.height;\n\n      this._cachedPageHeights[page.startIndex] = {\n        height: newClientRect.height,\n        measureVersion: this._measureVersion\n      };\n\n      this._estimatedPageHeight = Math.round(\n        ((this._estimatedPageHeight * this._totalEstimates) + newClientRect.height) /\n        (this._totalEstimates + 1));\n\n      this._totalEstimates++;\n    }\n\n    return hasChangedHeight;\n  }\n\n  /** Called when a page has been added to the DOM. */\n  private _onPageAdded(page: IPage) {\n    let { onPageAdded } = this.props;\n\n    // console.log('page added', page.startIndex, this.state.pages.map(page=>page.key).join(', '));\n\n    if (onPageAdded) {\n      onPageAdded(page);\n    }\n  }\n\n  /** Called when a page has been removed from the DOM. */\n  private _onPageRemoved(page: IPage) {\n    let { onPageRemoved } = this.props;\n\n    // console.log('  --- page removed', page.startIndex, this.state.pages.map(page=>page.key).join(', '));\n\n    if (onPageRemoved) {\n      onPageRemoved(page);\n    }\n  }\n\n  /** Build up the pages that should be rendered. */\n  private _buildPages(items: any[], startIndex: number, renderCount: number): IListState {\n    let materializedRect = assign({}, EMPTY_RECT) as ClientRect;\n    let itemsPerPage = 1;\n    let pages = [];\n    let pageTop = 0;\n    let currentSpacer = null;\n    let focusedIndex = this._focusedIndex;\n    let endIndex = startIndex + renderCount;\n\n    // First render is very important to track; when we render cells, we have no idea of estimated page height.\n    // So we should default to rendering only the first page so that we can get information.\n    // However if the user provides a measure function, let's just assume they know the right heights.\n    let isFirstRender = this._estimatedPageHeight === 0 && !this.props.getPageHeight;\n\n    for (let itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      itemsPerPage = this._getItemCountForPage(itemIndex, this._allowedRect);\n\n      let pageHeight = this._getPageHeight(itemIndex, itemsPerPage, this._surfaceRect);\n      let pageBottom = pageTop + pageHeight - 1;\n\n      let isPageRendered = findIndex(this.state.pages, (page) => page.items && page.startIndex === itemIndex) > -1;\n      let isPageInAllowedRange = pageBottom >= this._allowedRect.top && pageTop <= this._allowedRect.bottom;\n      let isPageInRequiredRange = pageBottom >= this._requiredRect.top && pageTop <= this._requiredRect.bottom;\n      let isPageVisible = !isFirstRender && (isPageInRequiredRange || (isPageInAllowedRange && isPageRendered));\n      let isPageFocused = focusedIndex >= itemIndex && focusedIndex < (itemIndex + itemsPerPage);\n      let isFirstPage = itemIndex === startIndex;\n\n     // console.log('building page', itemIndex, 'pageTop: ' + pageTop, 'inAllowed: ' + isPageInAllowedRange, 'inRequired: ' + isPageInRequiredRange);\n\n      // Only render whats visible, focused, or first page.\n      if (isPageVisible || isPageFocused || isFirstPage) {\n        if (currentSpacer) {\n          pages.push(currentSpacer);\n          currentSpacer = null;\n        }\n\n        let itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);\n        let newPage = this._createPage(null, items.slice(itemIndex, itemIndex + itemsInPage), itemIndex);\n\n        newPage.top = pageTop;\n        newPage.height = pageHeight;\n\n        pages.push(newPage);\n\n        if (isPageInRequiredRange) {\n          _mergeRect(materializedRect, {\n            top: pageTop,\n            bottom: pageBottom,\n            height: pageHeight,\n            left: this._allowedRect.left,\n            right: this._allowedRect.right,\n            width: this._allowedRect.width\n          });\n        }\n\n      } else {\n        if (!currentSpacer) {\n          currentSpacer = this._createPage('spacer-' + itemIndex, null, itemIndex, 0);\n        }\n        currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;\n        currentSpacer.itemCount += itemsPerPage;\n      }\n      pageTop += (pageBottom - pageTop + 1);\n\n      if (isFirstRender) {\n        break;\n      }\n    }\n\n    if (currentSpacer) {\n      currentSpacer.key = 'spacer-end';\n      pages.push(currentSpacer);\n    }\n\n    this._materializedRect = materializedRect;\n\n    // console.log('materialized: ', materializedRect);\n    return {\n      pages: pages,\n      measureVersion: this._measureVersion\n    };\n  }\n\n  /**\n   * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to\n   * cached height, or estimated page height, or default page height.\n   */\n  private _getPageHeight(itemIndex: number, itemsPerPage: number, visibleRect: ClientRect): number {\n    if (this.props.getPageHeight) {\n      return this.props.getPageHeight(itemIndex, visibleRect);\n    } else {\n      let cachedHeight = (this._cachedPageHeights[itemIndex]);\n\n      return cachedHeight ? cachedHeight.height : (this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT);\n    }\n  }\n\n  private _getItemCountForPage(itemIndex: number, visibileRect: ClientRect): number {\n    let itemsPerPage = this.props.getItemCountForPage ? this.props.getItemCountForPage(itemIndex, visibileRect) : DEFAULT_ITEMS_PER_PAGE;\n\n    return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;\n  }\n\n  private _createPage(pageKey: string, items: any[], startIndex?: number, count?: number, style?: any): IPage {\n    pageKey = pageKey || ('page-' + startIndex);\n\n    // Fill undefined cells because array.map will ignore undefined cells.\n    if (items) {\n      for (let i = 0; i < items.length; i++) {\n        items[i] = items[i] || null;\n      }\n    }\n\n    return {\n      key: pageKey,\n      startIndex: startIndex === undefined ? -1 : startIndex,\n      itemCount: (count === undefined) ? (items ? items.length : 0) : count,\n      items: items,\n      style: style || {},\n      top: 0,\n      height: 0\n    };\n  }\n\n  private _getRenderCount(props?: IListProps): number {\n    let { items, startIndex, renderCount } = props || this.props;\n\n    return (renderCount === undefined ? (items ? items.length - startIndex : 0) : renderCount);\n  }\n\n  /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */\n  private _updateRenderRects(props?: IListProps, forceUpdate?: boolean) {\n    const { renderedWindowsAhead, renderedWindowsBehind } = (props || this.props);\n    const { pages } = this.state;\n    const renderCount = this._getRenderCount(props);\n    let surfaceRect = this._surfaceRect;\n\n    // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.\n    if (\n      forceUpdate ||\n      !pages ||\n      !this._surfaceRect ||\n      (pages.length > 0 && pages[0].items && pages[0].items.length < renderCount)) {\n       surfaceRect = this._surfaceRect = _measureSurfaceRect(this.refs.surface);\n    }\n\n    // If the surface is above the container top or below the container bottom, or if this is not the first\n    // render return empty rect.\n    // The first time the list gets rendered we need to calculate the rectangle. The width of the list is\n    // used to calculate the width of the list items.\n    if ( (surfaceRect.bottom < 0 ||\n      surfaceRect.top > window.innerHeight) && !this.isFirstRenderRectUpdate) {\n      this._requiredRect = EMPTY_RECT;\n      this._allowedRect = EMPTY_RECT;\n    } else {\n      this.isFirstRenderRectUpdate = false;\n      const visibleTop = Math.max(0, -surfaceRect.top);\n      const visibleRect = {\n        top: visibleTop,\n        left: surfaceRect.left,\n        bottom: visibleTop + window.innerHeight,\n        right: surfaceRect.right,\n        width: surfaceRect.width,\n        height: window.innerHeight\n      };\n\n      // The required/allowed rects are adjusted versions of the visible rect.\n      this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);\n      this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind, renderedWindowsAhead);\n    }\n  }\n}\n\nfunction _expandRect(rect, pagesBefore, pagesAfter): ClientRect {\n  const top = rect.top - (pagesBefore * rect.height);\n  const height = rect.height + ((pagesBefore + pagesAfter) * rect.height);\n\n  return {\n    top: top,\n    bottom: top + height,\n    height: height,\n    left: rect.left,\n    right: rect.right,\n    width: rect.width\n  };\n}\n\nfunction _isContainedWithin(innerRect: ClientRect, outerRect: ClientRect): boolean {\n  return (\n    innerRect.top >= outerRect.top &&\n    innerRect.left >= outerRect.left &&\n    innerRect.bottom <= outerRect.bottom &&\n    innerRect.right <= outerRect.right);\n}\n\nfunction _mergeRect(targetRect: ClientRect, newRect: ClientRect): ClientRect {\n  targetRect.top = (newRect.top < targetRect.top || targetRect.top === -1) ? newRect.top : targetRect.top;\n  targetRect.left = (newRect.left < targetRect.left || targetRect.left === -1) ? newRect.left : targetRect.left;\n  targetRect.bottom = (newRect.bottom > targetRect.bottom || targetRect.bottom === -1) ? newRect.bottom : targetRect.bottom;\n  targetRect.right = (newRect.right > targetRect.right || targetRect.right === -1) ? newRect.right : targetRect.right;\n  targetRect.width = targetRect.right - targetRect.left + 1;\n  targetRect.height = targetRect.bottom - targetRect.top + 1;\n\n  return targetRect;\n}"],"sourceRoot":"/src"}